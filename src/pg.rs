/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __llvm__: ::std::os::raw::c_uint = 1;
pub const __clang__: ::std::os::raw::c_uint = 1;
pub const __clang_major__: ::std::os::raw::c_uint = 3;
pub const __clang_minor__: ::std::os::raw::c_uint = 8;
pub const __clang_patchlevel__: ::std::os::raw::c_uint = 0;
pub const __clang_version__: &'static [u8; 31usize] =
    b"3.8.0 (tags/RELEASE_380/final)\x00";
pub const __GNUC_MINOR__: ::std::os::raw::c_uint = 2;
pub const __GNUC_PATCHLEVEL__: ::std::os::raw::c_uint = 1;
pub const __GNUC__: ::std::os::raw::c_uint = 4;
pub const __GXX_ABI_VERSION: ::std::os::raw::c_uint = 1002;
pub const __ATOMIC_RELAXED: ::std::os::raw::c_uint = 0;
pub const __ATOMIC_CONSUME: ::std::os::raw::c_uint = 1;
pub const __ATOMIC_ACQUIRE: ::std::os::raw::c_uint = 2;
pub const __ATOMIC_RELEASE: ::std::os::raw::c_uint = 3;
pub const __ATOMIC_ACQ_REL: ::std::os::raw::c_uint = 4;
pub const __ATOMIC_SEQ_CST: ::std::os::raw::c_uint = 5;
pub const __PRAGMA_REDEFINE_EXTNAME: ::std::os::raw::c_uint = 1;
pub const __VERSION__: &'static [u8; 54usize] =
    b"4.2.1 Compatible Clang 3.8.0 (tags/RELEASE_380/final)\x00";
pub const __CONSTANT_CFSTRINGS__: ::std::os::raw::c_uint = 1;
pub const __GXX_RTTI: ::std::os::raw::c_uint = 1;
pub const __ORDER_LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1234;
pub const __ORDER_BIG_ENDIAN__: ::std::os::raw::c_uint = 4321;
pub const __ORDER_PDP_ENDIAN__: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER__: ::std::os::raw::c_uint = 1234;
pub const __LITTLE_ENDIAN__: ::std::os::raw::c_uint = 1;
pub const _LP64: ::std::os::raw::c_uint = 1;
pub const __LP64__: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT__: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX__: ::std::os::raw::c_uint = 127;
pub const __SHRT_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __LONG_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_LONG_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __WCHAR_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INTMAX_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_MAX__: ::std::os::raw::c_int = -1;
pub const __UINTMAX_MAX__: ::std::os::raw::c_int = -1;
pub const __PTRDIFF_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INTPTR_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __UINTPTR_MAX__: ::std::os::raw::c_int = -1;
pub const __SIZEOF_DOUBLE__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_FLOAT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_LONG_DOUBLE__: ::std::os::raw::c_uint = 16;
pub const __SIZEOF_LONG_LONG__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_POINTER__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SHORT__: ::std::os::raw::c_uint = 2;
pub const __SIZEOF_PTRDIFF_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_SIZE_T__: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_WCHAR_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_WINT_T__: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_INT128__: ::std::os::raw::c_uint = 16;
pub const __INTMAX_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTMAX_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINTMAX_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTMAX_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTMAX_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTMAX_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __PTRDIFF_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __PTRDIFF_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __PTRDIFF_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __INTPTR_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INTPTR_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __INTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __SIZE_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __SIZE_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __SIZE_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __SIZE_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __SIZE_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __WCHAR_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __WINT_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_WIDTH__: ::std::os::raw::c_uint = 32;
pub const __SIG_ATOMIC_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINTMAX_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __UINTPTR_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINTPTR_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINTPTR_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINTPTR_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINTPTR_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __FLT_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __FLT_DIG__: ::std::os::raw::c_uint = 6;
pub const __FLT_DECIMAL_DIG__: ::std::os::raw::c_uint = 9;
pub const __FLT_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __FLT_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __FLT_MANT_DIG__: ::std::os::raw::c_uint = 24;
pub const __FLT_MAX_10_EXP__: ::std::os::raw::c_uint = 38;
pub const __FLT_MAX_EXP__: ::std::os::raw::c_uint = 128;
pub const __FLT_MIN_10_EXP__: ::std::os::raw::c_int = -37;
pub const __FLT_MIN_EXP__: ::std::os::raw::c_int = -125;
pub const __DBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __DBL_DIG__: ::std::os::raw::c_uint = 15;
pub const __DBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 17;
pub const __DBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __DBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __DBL_MANT_DIG__: ::std::os::raw::c_uint = 53;
pub const __DBL_MAX_10_EXP__: ::std::os::raw::c_uint = 308;
pub const __DBL_MAX_EXP__: ::std::os::raw::c_uint = 1024;
pub const __DBL_MIN_10_EXP__: ::std::os::raw::c_int = -307;
pub const __DBL_MIN_EXP__: ::std::os::raw::c_int = -1021;
pub const __LDBL_HAS_DENORM__: ::std::os::raw::c_uint = 1;
pub const __LDBL_DIG__: ::std::os::raw::c_uint = 18;
pub const __LDBL_DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __LDBL_HAS_INFINITY__: ::std::os::raw::c_uint = 1;
pub const __LDBL_HAS_QUIET_NAN__: ::std::os::raw::c_uint = 1;
pub const __LDBL_MANT_DIG__: ::std::os::raw::c_uint = 64;
pub const __LDBL_MAX_10_EXP__: ::std::os::raw::c_uint = 4932;
pub const __LDBL_MAX_EXP__: ::std::os::raw::c_uint = 16384;
pub const __LDBL_MIN_10_EXP__: ::std::os::raw::c_int = -4931;
pub const __LDBL_MIN_EXP__: ::std::os::raw::c_int = -16381;
pub const __POINTER_WIDTH__: ::std::os::raw::c_uint = 64;
pub const __BIGGEST_ALIGNMENT__: ::std::os::raw::c_uint = 16;
pub const __WINT_UNSIGNED__: ::std::os::raw::c_uint = 1;
pub const __INT8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __INT16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __INT32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __INT64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __UINT8_MAX__: ::std::os::raw::c_uint = 255;
pub const __INT8_MAX__: ::std::os::raw::c_uint = 127;
pub const __UINT16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __UINT16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __INT16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __UINT32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __UINT32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __INT32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __UINT64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __UINT64_MAX__: ::std::os::raw::c_int = -1;
pub const __INT64_MAX__: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __INT_LEAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_LEAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_LEAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_LEAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_LEAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_LEAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_LEAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_LEAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_LEAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_LEAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_LEAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_LEAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_LEAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_LEAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_LEAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_LEAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_LEAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_LEAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_LEAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_LEAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_LEAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_LEAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_LEAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_LEAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_LEAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_LEAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_LEAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_LEAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_LEAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_LEAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_LEAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_LEAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __INT_FAST8_MAX__: ::std::os::raw::c_uint = 127;
pub const __INT_FAST8_FMTd__: &'static [u8; 4usize] = b"hhd\x00";
pub const __INT_FAST8_FMTi__: &'static [u8; 4usize] = b"hhi\x00";
pub const __UINT_FAST8_MAX__: ::std::os::raw::c_uint = 255;
pub const __UINT_FAST8_FMTo__: &'static [u8; 4usize] = b"hho\x00";
pub const __UINT_FAST8_FMTu__: &'static [u8; 4usize] = b"hhu\x00";
pub const __UINT_FAST8_FMTx__: &'static [u8; 4usize] = b"hhx\x00";
pub const __UINT_FAST8_FMTX__: &'static [u8; 4usize] = b"hhX\x00";
pub const __INT_FAST16_MAX__: ::std::os::raw::c_uint = 32767;
pub const __INT_FAST16_FMTd__: &'static [u8; 3usize] = b"hd\x00";
pub const __INT_FAST16_FMTi__: &'static [u8; 3usize] = b"hi\x00";
pub const __UINT_FAST16_MAX__: ::std::os::raw::c_uint = 65535;
pub const __UINT_FAST16_FMTo__: &'static [u8; 3usize] = b"ho\x00";
pub const __UINT_FAST16_FMTu__: &'static [u8; 3usize] = b"hu\x00";
pub const __UINT_FAST16_FMTx__: &'static [u8; 3usize] = b"hx\x00";
pub const __UINT_FAST16_FMTX__: &'static [u8; 3usize] = b"hX\x00";
pub const __INT_FAST32_MAX__: ::std::os::raw::c_uint = 2147483647;
pub const __INT_FAST32_FMTd__: &'static [u8; 2usize] = b"d\x00";
pub const __INT_FAST32_FMTi__: &'static [u8; 2usize] = b"i\x00";
pub const __UINT_FAST32_MAX__: ::std::os::raw::c_uint = 4294967295;
pub const __UINT_FAST32_FMTo__: &'static [u8; 2usize] = b"o\x00";
pub const __UINT_FAST32_FMTu__: &'static [u8; 2usize] = b"u\x00";
pub const __UINT_FAST32_FMTx__: &'static [u8; 2usize] = b"x\x00";
pub const __UINT_FAST32_FMTX__: &'static [u8; 2usize] = b"X\x00";
pub const __INT_FAST64_MAX__: ::std::os::raw::c_ulonglong =
    9223372036854775807;
pub const __INT_FAST64_FMTd__: &'static [u8; 3usize] = b"ld\x00";
pub const __INT_FAST64_FMTi__: &'static [u8; 3usize] = b"li\x00";
pub const __UINT_FAST64_MAX__: ::std::os::raw::c_int = -1;
pub const __UINT_FAST64_FMTo__: &'static [u8; 3usize] = b"lo\x00";
pub const __UINT_FAST64_FMTu__: &'static [u8; 3usize] = b"lu\x00";
pub const __UINT_FAST64_FMTx__: &'static [u8; 3usize] = b"lx\x00";
pub const __UINT_FAST64_FMTX__: &'static [u8; 3usize] = b"lX\x00";
pub const __FINITE_MATH_ONLY__: ::std::os::raw::c_uint = 0;
pub const __GNUC_STDC_INLINE__: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: ::std::os::raw::c_uint = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: ::std::os::raw::c_uint = 2;
pub const __NO_INLINE__: ::std::os::raw::c_uint = 1;
pub const __FLT_EVAL_METHOD__: ::std::os::raw::c_uint = 0;
pub const __FLT_RADIX__: ::std::os::raw::c_uint = 2;
pub const __DECIMAL_DIG__: ::std::os::raw::c_uint = 21;
pub const __amd64__: ::std::os::raw::c_uint = 1;
pub const __amd64: ::std::os::raw::c_uint = 1;
pub const __x86_64: ::std::os::raw::c_uint = 1;
pub const __x86_64__: ::std::os::raw::c_uint = 1;
pub const __k8: ::std::os::raw::c_uint = 1;
pub const __k8__: ::std::os::raw::c_uint = 1;
pub const __tune_k8__: ::std::os::raw::c_uint = 1;
pub const __NO_MATH_INLINES: ::std::os::raw::c_uint = 1;
pub const __FXSR__: ::std::os::raw::c_uint = 1;
pub const __SSE2__: ::std::os::raw::c_uint = 1;
pub const __SSE2_MATH__: ::std::os::raw::c_uint = 1;
pub const __SSE__: ::std::os::raw::c_uint = 1;
pub const __SSE_MATH__: ::std::os::raw::c_uint = 1;
pub const __MMX__: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: ::std::os::raw::c_uint = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8: ::std::os::raw::c_uint = 1;
pub const unix: ::std::os::raw::c_uint = 1;
pub const __unix: ::std::os::raw::c_uint = 1;
pub const __unix__: ::std::os::raw::c_uint = 1;
pub const linux: ::std::os::raw::c_uint = 1;
pub const __linux: ::std::os::raw::c_uint = 1;
pub const __linux__: ::std::os::raw::c_uint = 1;
pub const __gnu_linux__: ::std::os::raw::c_uint = 1;
pub const __ELF__: ::std::os::raw::c_uint = 1;
pub const __STDC__: ::std::os::raw::c_uint = 1;
pub const __STDC_HOSTED__: ::std::os::raw::c_uint = 1;
pub const __STDC_VERSION__: ::std::os::raw::c_uint = 201112;
pub const __STDC_UTF_16__: ::std::os::raw::c_uint = 1;
pub const __STDC_UTF_32__: ::std::os::raw::c_uint = 1;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_1 {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_1>() , 4usize);
}
impl Clone for _bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
pub type __fsid_t = _bindgen_ty_1;
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize);
    assert_eq!(::std::mem::align_of::<_IO_FILE>() , 8usize);
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub __count: ::std::os::raw::c_int,
    pub __value: _bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2__bindgen_ty_1 {
    pub __wch: __BindgenUnionField<::std::os::raw::c_uint>,
    pub __wchb: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2__bindgen_ty_1>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2>() , 4usize);
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub type __mbstate_t = _bindgen_ty_2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_3>() , 8usize);
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
pub type _G_fpos_t = _bindgen_ty_3;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_4>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_4>() , 8usize);
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
pub type _G_fpos64_t = _bindgen_ty_4;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t([u8; 0]);
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize);
    assert_eq!(::std::mem::align_of::<_IO_marker>() , 8usize);
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus([u8; 0]);
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __sprintf_chk(__s: *mut ::std::os::raw::c_char,
                         __flag: ::std::os::raw::c_int, __slen: usize,
                         __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(__s: *mut ::std::os::raw::c_char,
                          __flag: ::std::os::raw::c_int, __slen: usize,
                          __format: *const ::std::os::raw::c_char,
                          __ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(__s: *mut ::std::os::raw::c_char, __n: usize,
                          __flag: ::std::os::raw::c_int, __slen: usize,
                          __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(__s: *mut ::std::os::raw::c_char, __n: usize,
                           __flag: ::std::os::raw::c_int, __slen: usize,
                           __format: *const ::std::os::raw::c_char,
                           __ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fprintf_chk(__stream: *mut FILE, __flag: ::std::os::raw::c_int,
                         __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __printf_chk(__flag: ::std::os::raw::c_int,
                        __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vfprintf_chk(__stream: *mut FILE, __flag: ::std::os::raw::c_int,
                          __format: *const ::std::os::raw::c_char,
                          __ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vprintf_chk(__flag: ::std::os::raw::c_int,
                         __format: *const ::std::os::raw::c_char,
                         __ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dprintf_chk(__fd: ::std::os::raw::c_int,
                         __flag: ::std::os::raw::c_int,
                         __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vdprintf_chk(__fd: ::std::os::raw::c_int,
                          __flag: ::std::os::raw::c_int,
                          __fmt: *const ::std::os::raw::c_char,
                          __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fgets_chk(__s: *mut ::std::os::raw::c_char, __size: usize,
                       __n: ::std::os::raw::c_int, __stream: *mut FILE)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __fread_chk(__ptr: *mut ::std::os::raw::c_void, __ptrlen: usize,
                       __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn __fread_unlocked_chk(__ptr: *mut ::std::os::raw::c_void,
                                __ptrlen: usize, __size: usize, __n: usize,
                                __stream: *mut FILE) -> usize;
}
pub type wchar_t = ::std::os::raw::c_int;
pub const P_ALL: _bindgen_ty_5 = _bindgen_ty_5::P_ALL;
pub const P_PID: _bindgen_ty_5 = _bindgen_ty_5::P_PID;
pub const P_PGID: _bindgen_ty_5 = _bindgen_ty_5::P_PGID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_5 { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub use self::_bindgen_ty_5 as idtype_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait {
    pub w_status: __BindgenUnionField<::std::os::raw::c_int>,
    pub __wait_terminated: __BindgenUnionField<wait__bindgen_ty_1>,
    pub __wait_stopped: __BindgenUnionField<wait__bindgen_ty_2>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>() , 4usize);
    assert_eq!(::std::mem::align_of::<wait__bindgen_ty_1>() , 4usize);
}
impl Clone for wait__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (127usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(127usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (127usize as u32);
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (128usize as u32)) >>
                                       7u32) as u32)
        }
    }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(128usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 7u32) & (128usize as u32);
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65280usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn at_offset_16(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294901760usize as u32)) >> 16u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_at_offset_16(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>() , 4usize);
    assert_eq!(::std::mem::align_of::<wait__bindgen_ty_2>() , 4usize);
}
impl Clone for wait__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (255usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(255usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (255usize as u32);
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65280usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(65280usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (65280usize as u32);
    }
    #[inline]
    pub fn at_offset_16(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294901760usize as u32)) >> 16u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_at_offset_16(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294901760usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (4294901760usize as u32);
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>() , 4usize);
    assert_eq!(::std::mem::align_of::<wait>() , 4usize);
}
impl Clone for wait {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_6 {
    pub __uptr: __BindgenUnionField<*mut wait>,
    pub __iptr: __BindgenUnionField<*mut ::std::os::raw::c_int>,
    pub bindgen_union_field: u64,
}
impl Clone for _bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
pub type __WAIT_STATUS = _bindgen_ty_6;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7>() , 4usize);
}
impl Clone for _bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
pub type div_t = _bindgen_ty_7;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_8 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_8>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_8>() , 8usize);
}
impl Clone for _bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
pub type ldiv_t = _bindgen_ty_8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_9 {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_9>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_9>() , 8usize);
}
impl Clone for _bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
pub type lldiv_t = _bindgen_ty_9;
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_10 {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_10>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_10>() , 8usize);
}
impl Clone for _bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = _bindgen_ty_10;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize);
    assert_eq!(::std::mem::align_of::<timespec>() , 8usize);
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize);
    assert_eq!(::std::mem::align_of::<timeval>() , 8usize);
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_11 {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11>() , 8usize);
}
impl Clone for _bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
pub type fd_set = _bindgen_ty_11;
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fdelt_chk(__d: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __fdelt_warn(__d: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize);
    assert_eq!(::std::mem::align_of::<pthread_attr_t>() , 8usize);
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize);
    assert_eq!(::std::mem::align_of::<__pthread_internal_list>() , 8usize);
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12 {
    pub __data: __BindgenUnionField<_bindgen_ty_12___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12___pthread_mutex_s>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12___pthread_mutex_s>() ,
               8usize);
}
impl Clone for _bindgen_ty_12___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12>() , 8usize);
}
impl Clone for _bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_mutex_t = _bindgen_ty_12;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_13 {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_13>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_13>() , 4usize);
}
impl Clone for _bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_mutexattr_t = _bindgen_ty_13;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_14 {
    pub __data: __BindgenUnionField<_bindgen_ty_14__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_14__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_14__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14__bindgen_ty_1>() ,
               48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_14__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_14__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_14>() , 8usize);
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_cond_t = _bindgen_ty_14;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_15 {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_15>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_15>() , 4usize);
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_condattr_t = _bindgen_ty_15;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16 {
    pub __data: __BindgenUnionField<_bindgen_ty_16__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_16__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_char,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_16__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16__bindgen_ty_1>() ,
               56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_16__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16>() , 8usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_rwlock_t = _bindgen_ty_16;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_17 {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_17>() , 8usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_rwlockattr_t = _bindgen_ty_17;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_18 {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_18>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_18>() , 8usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrier_t = _bindgen_ty_18;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_19 {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_19() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_19>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_19>() , 4usize);
}
impl Clone for _bindgen_ty_19 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrierattr_t = _bindgen_ty_19;
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize);
    assert_eq!(::std::mem::align_of::<random_data>() , 8usize);
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize);
    assert_eq!(::std::mem::align_of::<drand48_data>() , 8usize);
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __realpath_chk(__name: *const ::std::os::raw::c_char,
                          __resolved: *mut ::std::os::raw::c_char,
                          __resolvedlen: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __ptsname_r_chk(__fd: ::std::os::raw::c_int,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __nreal: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ptsname_r"]
    pub fn __ptsname_r_alias(__fd: ::std::os::raw::c_int,
                             __buf: *mut ::std::os::raw::c_char,
                             __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __wctomb_chk(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t,
                        __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mbstowcs_chk(__dst: *mut wchar_t,
                          __src: *const ::std::os::raw::c_char, __len: usize,
                          __dstlen: usize) -> usize;
}
extern "C" {
    pub fn __wcstombs_chk(__dst: *mut ::std::os::raw::c_char,
                          __src: *const wchar_t, __len: usize,
                          __dstlen: usize) -> usize;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_struct___locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct___locale_data([u8; 0]);
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize);
    assert_eq!(::std::mem::align_of::<__locale_struct>() , 8usize);
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __rawmemchr(__s: *const ::std::os::raw::c_void,
                       __c: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __strcspn_c1(__s: *const ::std::os::raw::c_char,
                        __reject: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __strcspn_c2(__s: *const ::std::os::raw::c_char,
                        __reject1: ::std::os::raw::c_int,
                        __reject2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __strcspn_c3(__s: *const ::std::os::raw::c_char,
                        __reject1: ::std::os::raw::c_int,
                        __reject2: ::std::os::raw::c_int,
                        __reject3: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __strspn_c1(__s: *const ::std::os::raw::c_char,
                       __accept: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __strspn_c2(__s: *const ::std::os::raw::c_char,
                       __accept1: ::std::os::raw::c_int,
                       __accept2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __strspn_c3(__s: *const ::std::os::raw::c_char,
                       __accept1: ::std::os::raw::c_int,
                       __accept2: ::std::os::raw::c_int,
                       __accept3: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __strpbrk_c2(__s: *const ::std::os::raw::c_char,
                        __accept1: ::std::os::raw::c_int,
                        __accept2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strpbrk_c3(__s: *const ::std::os::raw::c_char,
                        __accept1: ::std::os::raw::c_int,
                        __accept2: ::std::os::raw::c_int,
                        __accept3: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r_1c(__s: *mut ::std::os::raw::c_char,
                         __sep: ::std::os::raw::c_char,
                         __nextp: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strsep_g(__stringp: *mut *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strsep_1c(__s: *mut *mut ::std::os::raw::c_char,
                       __reject: ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strsep_2c(__s: *mut *mut ::std::os::raw::c_char,
                       __reject1: ::std::os::raw::c_char,
                       __reject2: ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strsep_3c(__s: *mut *mut ::std::os::raw::c_char,
                       __reject1: ::std::os::raw::c_char,
                       __reject2: ::std::os::raw::c_char,
                       __reject3: ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strdup(__string: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy_chk(__dest: *mut ::std::os::raw::c_char,
                         __src: *const ::std::os::raw::c_char, __n: usize,
                         __destlen: usize) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_20 {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __max_align_ld: f64,
}
impl Clone for _bindgen_ty_20 {
    fn clone(&self) -> Self { *self }
}
pub type max_align_t = _bindgen_ty_20;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    assert_eq!(::std::mem::size_of::<lconv>() , 96usize);
    assert_eq!(::std::mem::align_of::<lconv>() , 8usize);
}
impl Clone for lconv {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setlocale(__category: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn newlocale(__category_mask: ::std::os::raw::c_int,
                     __locale: *const ::std::os::raw::c_char,
                     __base: __locale_t) -> __locale_t;
}
extern "C" {
    pub fn duplocale(__dataset: __locale_t) -> __locale_t;
}
extern "C" {
    pub fn freelocale(__dataset: __locale_t);
}
extern "C" {
    pub fn uselocale(__dataset: __locale_t) -> __locale_t;
}
extern "C" {
    pub fn gettext(__msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dgettext(__domainname: *const ::std::os::raw::c_char,
                    __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __dgettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dcgettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid: *const ::std::os::raw::c_char,
                     __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __dcgettext(__domainname: *const ::std::os::raw::c_char,
                       __msgid: *const ::std::os::raw::c_char,
                       __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ngettext(__msgid1: *const ::std::os::raw::c_char,
                    __msgid2: *const ::std::os::raw::c_char,
                    __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dngettext(__domainname: *const ::std::os::raw::c_char,
                     __msgid1: *const ::std::os::raw::c_char,
                     __msgid2: *const ::std::os::raw::c_char,
                     __n: ::std::os::raw::c_ulong)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dcngettext(__domainname: *const ::std::os::raw::c_char,
                      __msgid1: *const ::std::os::raw::c_char,
                      __msgid2: *const ::std::os::raw::c_char,
                      __n: ::std::os::raw::c_ulong,
                      __category: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn textdomain(__domainname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bindtextdomain(__domainname: *const ::std::os::raw::c_char,
                          __dirname: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bind_textdomain_codeset(__domainname:
                                       *const ::std::os::raw::c_char,
                                   __codeset: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type bool_ = ::std::os::raw::c_char;
pub type BoolPtr = *mut bool_;
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_char;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int128 = [u64; 2usize];
pub type uint128 = [u64; 2usize];
pub type Size = usize;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_21 {
    pub indx: [::std::os::raw::c_int; 6usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_21() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_21>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_21>() , 4usize);
}
impl Clone for _bindgen_ty_21 {
    fn clone(&self) -> Self { *self }
}
pub type IntArray = _bindgen_ty_21;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_varlena() {
    assert_eq!(::std::mem::size_of::<varlena>() , 4usize);
    assert_eq!(::std::mem::align_of::<varlena>() , 1usize);
}
impl Clone for varlena {
    fn clone(&self) -> Self { *self }
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_22 {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: *mut int16,
}
#[test]
fn bindgen_test_layout__bindgen_ty_22() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_22>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_22>() , 4usize);
}
impl Clone for _bindgen_ty_22 {
    fn clone(&self) -> Self { *self }
}
pub type int2vector = _bindgen_ty_22;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_23 {
    pub vl_len_: int32,
    pub ndim: ::std::os::raw::c_int,
    pub dataoffset: int32,
    pub elemtype: Oid,
    pub dim1: ::std::os::raw::c_int,
    pub lbound1: ::std::os::raw::c_int,
    pub values: *mut Oid,
}
#[test]
fn bindgen_test_layout__bindgen_ty_23() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_23>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_23>() , 4usize);
}
impl Clone for _bindgen_ty_23 {
    fn clone(&self) -> Self { *self }
}
pub type oidvector = _bindgen_ty_23;
#[repr(C)]
pub struct nameData {
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_nameData() {
    assert_eq!(::std::mem::size_of::<nameData>() , 64usize);
    assert_eq!(::std::mem::align_of::<nameData>() , 1usize);
}
pub type NameData = nameData;
pub type Name = *mut NameData;
pub const _ISupper: _bindgen_ty_24 = _bindgen_ty_24::_ISupper;
pub const _ISlower: _bindgen_ty_24 = _bindgen_ty_24::_ISlower;
pub const _ISalpha: _bindgen_ty_24 = _bindgen_ty_24::_ISalpha;
pub const _ISdigit: _bindgen_ty_24 = _bindgen_ty_24::_ISdigit;
pub const _ISxdigit: _bindgen_ty_24 = _bindgen_ty_24::_ISxdigit;
pub const _ISspace: _bindgen_ty_24 = _bindgen_ty_24::_ISspace;
pub const _ISprint: _bindgen_ty_24 = _bindgen_ty_24::_ISprint;
pub const _ISgraph: _bindgen_ty_24 = _bindgen_ty_24::_ISgraph;
pub const _ISblank: _bindgen_ty_24 = _bindgen_ty_24::_ISblank;
pub const _IScntrl: _bindgen_ty_24 = _bindgen_ty_24::_IScntrl;
pub const _ISpunct: _bindgen_ty_24 = _bindgen_ty_24::_ISpunct;
pub const _ISalnum: _bindgen_ty_24 = _bindgen_ty_24::_ISalnum;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_24 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize);
    assert_eq!(::std::mem::align_of::<iovec>() , 8usize);
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn readv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                 __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn writev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn preadv(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                  __count: ::std::os::raw::c_int, __offset: __off_t) -> isize;
}
extern "C" {
    pub fn pwritev(__fd: ::std::os::raw::c_int, __iovec: *const iovec,
                   __count: ::std::os::raw::c_int, __offset: __off_t)
     -> isize;
}
pub type socklen_t = __socklen_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __socket_type {
    SOCK_STREAM = 1,
    SOCK_DGRAM = 2,
    SOCK_RAW = 3,
    SOCK_RDM = 4,
    SOCK_SEQPACKET = 5,
    SOCK_DCCP = 6,
    SOCK_PACKET = 10,
    SOCK_CLOEXEC = 524288,
    SOCK_NONBLOCK = 2048,
}
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::std::mem::size_of::<sockaddr>() , 16usize);
    assert_eq!(::std::mem::align_of::<sockaddr>() , 2usize);
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::std::mem::size_of::<sockaddr_storage>() , 128usize);
    assert_eq!(::std::mem::align_of::<sockaddr_storage>() , 8usize);
}
pub const MSG_OOB: _bindgen_ty_25 = _bindgen_ty_25::MSG_OOB;
pub const MSG_PEEK: _bindgen_ty_25 = _bindgen_ty_25::MSG_PEEK;
pub const MSG_DONTROUTE: _bindgen_ty_25 = _bindgen_ty_25::MSG_DONTROUTE;
pub const MSG_CTRUNC: _bindgen_ty_25 = _bindgen_ty_25::MSG_CTRUNC;
pub const MSG_PROXY: _bindgen_ty_25 = _bindgen_ty_25::MSG_PROXY;
pub const MSG_TRUNC: _bindgen_ty_25 = _bindgen_ty_25::MSG_TRUNC;
pub const MSG_DONTWAIT: _bindgen_ty_25 = _bindgen_ty_25::MSG_DONTWAIT;
pub const MSG_EOR: _bindgen_ty_25 = _bindgen_ty_25::MSG_EOR;
pub const MSG_WAITALL: _bindgen_ty_25 = _bindgen_ty_25::MSG_WAITALL;
pub const MSG_FIN: _bindgen_ty_25 = _bindgen_ty_25::MSG_FIN;
pub const MSG_SYN: _bindgen_ty_25 = _bindgen_ty_25::MSG_SYN;
pub const MSG_CONFIRM: _bindgen_ty_25 = _bindgen_ty_25::MSG_CONFIRM;
pub const MSG_RST: _bindgen_ty_25 = _bindgen_ty_25::MSG_RST;
pub const MSG_ERRQUEUE: _bindgen_ty_25 = _bindgen_ty_25::MSG_ERRQUEUE;
pub const MSG_NOSIGNAL: _bindgen_ty_25 = _bindgen_ty_25::MSG_NOSIGNAL;
pub const MSG_MORE: _bindgen_ty_25 = _bindgen_ty_25::MSG_MORE;
pub const MSG_WAITFORONE: _bindgen_ty_25 = _bindgen_ty_25::MSG_WAITFORONE;
pub const MSG_FASTOPEN: _bindgen_ty_25 = _bindgen_ty_25::MSG_FASTOPEN;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_25 = _bindgen_ty_25::MSG_CMSG_CLOEXEC;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_25 {
    MSG_OOB = 1,
    MSG_PEEK = 2,
    MSG_DONTROUTE = 4,
    MSG_CTRUNC = 8,
    MSG_PROXY = 16,
    MSG_TRUNC = 32,
    MSG_DONTWAIT = 64,
    MSG_EOR = 128,
    MSG_WAITALL = 256,
    MSG_FIN = 512,
    MSG_SYN = 1024,
    MSG_CONFIRM = 2048,
    MSG_RST = 4096,
    MSG_ERRQUEUE = 8192,
    MSG_NOSIGNAL = 16384,
    MSG_MORE = 32768,
    MSG_WAITFORONE = 65536,
    MSG_FASTOPEN = 536870912,
    MSG_CMSG_CLOEXEC = 1073741824,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: usize,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: usize,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::std::mem::size_of::<msghdr>() , 56usize);
    assert_eq!(::std::mem::align_of::<msghdr>() , 8usize);
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cmsghdr {
    pub cmsg_len: usize,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
    pub __cmsg_data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::std::mem::size_of::<cmsghdr>() , 16usize);
    assert_eq!(::std::mem::align_of::<cmsghdr>() , 8usize);
}
impl Clone for cmsghdr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __cmsg_nxthdr(__mhdr: *mut msghdr, __cmsg: *mut cmsghdr)
     -> *mut cmsghdr;
}
pub const SCM_RIGHTS: _bindgen_ty_26 = _bindgen_ty_26::SCM_RIGHTS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_26 { SCM_RIGHTS = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::std::mem::size_of::<linger>() , 8usize);
    assert_eq!(::std::mem::align_of::<linger>() , 4usize);
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_uchar; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::std::mem::size_of::<osockaddr>() , 16usize);
    assert_eq!(::std::mem::align_of::<osockaddr>() , 2usize);
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
pub const SHUT_RD: _bindgen_ty_27 = _bindgen_ty_27::SHUT_RD;
pub const SHUT_WR: _bindgen_ty_27 = _bindgen_ty_27::SHUT_WR;
pub const SHUT_RDWR: _bindgen_ty_27 = _bindgen_ty_27::SHUT_RDWR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_27 { SHUT_RD = 0, SHUT_WR = 1, SHUT_RDWR = 2, }
extern "C" {
    pub fn socket(__domain: ::std::os::raw::c_int,
                  __type: ::std::os::raw::c_int,
                  __protocol: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn socketpair(__domain: ::std::os::raw::c_int,
                      __type: ::std::os::raw::c_int,
                      __protocol: ::std::os::raw::c_int,
                      __fds: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bind(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsockname(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn connect(__fd: ::std::os::raw::c_int, __addr: *const sockaddr,
                   __len: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeername(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                       __len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn send(__fd: ::std::os::raw::c_int,
                __buf: *const ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recv(__fd: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_void, __n: usize,
                __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn sendto(__fd: ::std::os::raw::c_int,
                  __buf: *const ::std::os::raw::c_void, __n: usize,
                  __flags: ::std::os::raw::c_int, __addr: *const sockaddr,
                  __addr_len: socklen_t) -> isize;
}
extern "C" {
    pub fn recvfrom(__fd: ::std::os::raw::c_int,
                    __buf: *mut ::std::os::raw::c_void, __n: usize,
                    __flags: ::std::os::raw::c_int, __addr: *mut sockaddr,
                    __addr_len: *mut socklen_t) -> isize;
}
extern "C" {
    pub fn sendmsg(__fd: ::std::os::raw::c_int, __message: *const msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn recvmsg(__fd: ::std::os::raw::c_int, __message: *mut msghdr,
                   __flags: ::std::os::raw::c_int) -> isize;
}
extern "C" {
    pub fn getsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *mut ::std::os::raw::c_void,
                      __optlen: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsockopt(__fd: ::std::os::raw::c_int,
                      __level: ::std::os::raw::c_int,
                      __optname: ::std::os::raw::c_int,
                      __optval: *const ::std::os::raw::c_void,
                      __optlen: socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn listen(__fd: ::std::os::raw::c_int, __n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn accept(__fd: ::std::os::raw::c_int, __addr: *mut sockaddr,
                  __addr_len: *mut socklen_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn shutdown(__fd: ::std::os::raw::c_int, __how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sockatmark(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isfdtype(__fd: ::std::os::raw::c_int,
                    __fdtype: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __recv_chk(__fd: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_void, __n: usize,
                      __buflen: usize, __flags: ::std::os::raw::c_int)
     -> isize;
}
extern "C" {
    pub fn __recvfrom_chk(__fd: ::std::os::raw::c_int,
                          __buf: *mut ::std::os::raw::c_void, __n: usize,
                          __buflen: usize, __flags: ::std::os::raw::c_int,
                          __addr: *mut sockaddr, __addr_len: *mut socklen_t)
     -> isize;
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::std::mem::size_of::<in_addr>() , 4usize);
    assert_eq!(::std::mem::align_of::<in_addr>() , 4usize);
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(::std::mem::size_of::<ip_opts>() , 44usize);
    assert_eq!(::std::mem::align_of::<ip_opts>() , 4usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(::std::mem::size_of::<ip_mreqn>() , 12usize);
    assert_eq!(::std::mem::align_of::<ip_mreqn>() , 4usize);
}
impl Clone for ip_mreqn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(::std::mem::size_of::<in_pktinfo>() , 12usize);
    assert_eq!(::std::mem::align_of::<in_pktinfo>() , 4usize);
}
impl Clone for in_pktinfo {
    fn clone(&self) -> Self { *self }
}
pub const IPPROTO_IP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_IP;
pub const IPPROTO_ICMP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_ICMP;
pub const IPPROTO_IGMP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_IGMP;
pub const IPPROTO_IPIP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_IPIP;
pub const IPPROTO_TCP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_TCP;
pub const IPPROTO_EGP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_EGP;
pub const IPPROTO_PUP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_PUP;
pub const IPPROTO_UDP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_UDP;
pub const IPPROTO_IDP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_IDP;
pub const IPPROTO_TP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_TP;
pub const IPPROTO_DCCP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_DCCP;
pub const IPPROTO_IPV6: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_IPV6;
pub const IPPROTO_RSVP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_RSVP;
pub const IPPROTO_GRE: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_GRE;
pub const IPPROTO_ESP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_ESP;
pub const IPPROTO_AH: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_AH;
pub const IPPROTO_MTP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_MTP;
pub const IPPROTO_BEETPH: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_BEETPH;
pub const IPPROTO_ENCAP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_ENCAP;
pub const IPPROTO_PIM: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_PIM;
pub const IPPROTO_COMP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_COMP;
pub const IPPROTO_SCTP: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_SCTP;
pub const IPPROTO_UDPLITE: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_UDPLITE;
pub const IPPROTO_MPLS: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_MPLS;
pub const IPPROTO_RAW: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_RAW;
pub const IPPROTO_MAX: _bindgen_ty_28 = _bindgen_ty_28::IPPROTO_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_28 {
    IPPROTO_IP = 0,
    IPPROTO_ICMP = 1,
    IPPROTO_IGMP = 2,
    IPPROTO_IPIP = 4,
    IPPROTO_TCP = 6,
    IPPROTO_EGP = 8,
    IPPROTO_PUP = 12,
    IPPROTO_UDP = 17,
    IPPROTO_IDP = 22,
    IPPROTO_TP = 29,
    IPPROTO_DCCP = 33,
    IPPROTO_IPV6 = 41,
    IPPROTO_RSVP = 46,
    IPPROTO_GRE = 47,
    IPPROTO_ESP = 50,
    IPPROTO_AH = 51,
    IPPROTO_MTP = 92,
    IPPROTO_BEETPH = 94,
    IPPROTO_ENCAP = 98,
    IPPROTO_PIM = 103,
    IPPROTO_COMP = 108,
    IPPROTO_SCTP = 132,
    IPPROTO_UDPLITE = 136,
    IPPROTO_MPLS = 137,
    IPPROTO_RAW = 255,
    IPPROTO_MAX = 256,
}
pub const IPPROTO_HOPOPTS: _bindgen_ty_29 = _bindgen_ty_29::IPPROTO_HOPOPTS;
pub const IPPROTO_ROUTING: _bindgen_ty_29 = _bindgen_ty_29::IPPROTO_ROUTING;
pub const IPPROTO_FRAGMENT: _bindgen_ty_29 = _bindgen_ty_29::IPPROTO_FRAGMENT;
pub const IPPROTO_ICMPV6: _bindgen_ty_29 = _bindgen_ty_29::IPPROTO_ICMPV6;
pub const IPPROTO_NONE: _bindgen_ty_29 = _bindgen_ty_29::IPPROTO_NONE;
pub const IPPROTO_DSTOPTS: _bindgen_ty_29 = _bindgen_ty_29::IPPROTO_DSTOPTS;
pub const IPPROTO_MH: _bindgen_ty_29 = _bindgen_ty_29::IPPROTO_MH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_29 {
    IPPROTO_HOPOPTS = 0,
    IPPROTO_ROUTING = 43,
    IPPROTO_FRAGMENT = 44,
    IPPROTO_ICMPV6 = 58,
    IPPROTO_NONE = 59,
    IPPROTO_DSTOPTS = 60,
    IPPROTO_MH = 135,
}
pub type in_port_t = u16;
pub const IPPORT_ECHO: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_ECHO;
pub const IPPORT_DISCARD: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_DISCARD;
pub const IPPORT_SYSTAT: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_SYSTAT;
pub const IPPORT_DAYTIME: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_DAYTIME;
pub const IPPORT_NETSTAT: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_NETSTAT;
pub const IPPORT_FTP: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_FTP;
pub const IPPORT_TELNET: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_TELNET;
pub const IPPORT_SMTP: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_SMTP;
pub const IPPORT_TIMESERVER: _bindgen_ty_30 =
    _bindgen_ty_30::IPPORT_TIMESERVER;
pub const IPPORT_NAMESERVER: _bindgen_ty_30 =
    _bindgen_ty_30::IPPORT_NAMESERVER;
pub const IPPORT_WHOIS: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_WHOIS;
pub const IPPORT_MTP: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_MTP;
pub const IPPORT_TFTP: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_TFTP;
pub const IPPORT_RJE: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_RJE;
pub const IPPORT_FINGER: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_FINGER;
pub const IPPORT_TTYLINK: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_TTYLINK;
pub const IPPORT_SUPDUP: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_SUPDUP;
pub const IPPORT_EXECSERVER: _bindgen_ty_30 =
    _bindgen_ty_30::IPPORT_EXECSERVER;
pub const IPPORT_LOGINSERVER: _bindgen_ty_30 =
    _bindgen_ty_30::IPPORT_LOGINSERVER;
pub const IPPORT_CMDSERVER: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_CMDSERVER;
pub const IPPORT_EFSSERVER: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_EFSSERVER;
pub const IPPORT_BIFFUDP: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_EXECSERVER;
pub const IPPORT_WHOSERVER: _bindgen_ty_30 =
    _bindgen_ty_30::IPPORT_LOGINSERVER;
pub const IPPORT_ROUTESERVER: _bindgen_ty_30 =
    _bindgen_ty_30::IPPORT_EFSSERVER;
pub const IPPORT_RESERVED: _bindgen_ty_30 = _bindgen_ty_30::IPPORT_RESERVED;
pub const IPPORT_USERRESERVED: _bindgen_ty_30 =
    _bindgen_ty_30::IPPORT_USERRESERVED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_30 {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,
    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,
    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,
    IPPORT_RESERVED = 1024,
    IPPORT_USERRESERVED = 5000,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<in6_addr__bindgen_ty_1>() , 16usize);
    assert_eq!(::std::mem::align_of::<in6_addr__bindgen_ty_1>() , 4usize);
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::std::mem::size_of::<in6_addr>() , 16usize);
    assert_eq!(::std::mem::align_of::<in6_addr>() , 4usize);
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(::std::mem::size_of::<sockaddr_in>() , 16usize);
    assert_eq!(::std::mem::align_of::<sockaddr_in>() , 4usize);
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(::std::mem::size_of::<sockaddr_in6>() , 28usize);
    assert_eq!(::std::mem::align_of::<sockaddr_in6>() , 4usize);
}
impl Clone for sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(::std::mem::size_of::<ip_mreq>() , 8usize);
    assert_eq!(::std::mem::align_of::<ip_mreq>() , 4usize);
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
    pub imr_sourceaddr: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(::std::mem::size_of::<ip_mreq_source>() , 12usize);
    assert_eq!(::std::mem::align_of::<ip_mreq_source>() , 4usize);
}
impl Clone for ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(::std::mem::size_of::<ipv6_mreq>() , 20usize);
    assert_eq!(::std::mem::align_of::<ipv6_mreq>() , 4usize);
}
impl Clone for ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(::std::mem::size_of::<group_req>() , 136usize);
    assert_eq!(::std::mem::align_of::<group_req>() , 8usize);
}
#[repr(C)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(::std::mem::size_of::<group_source_req>() , 264usize);
    assert_eq!(::std::mem::align_of::<group_source_req>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ip_msfilter {
    pub imsf_multiaddr: in_addr,
    pub imsf_interface: in_addr,
    pub imsf_fmode: u32,
    pub imsf_numsrc: u32,
    pub imsf_slist: [in_addr; 1usize],
}
#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(::std::mem::size_of::<ip_msfilter>() , 20usize);
    assert_eq!(::std::mem::align_of::<ip_msfilter>() , 4usize);
}
impl Clone for ip_msfilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct group_filter {
    pub gf_interface: u32,
    pub gf_group: sockaddr_storage,
    pub gf_fmode: u32,
    pub gf_numsrc: u32,
    pub gf_slist: [sockaddr_storage; 1usize],
}
#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(::std::mem::size_of::<group_filter>() , 272usize);
    assert_eq!(::std::mem::align_of::<group_filter>() , 8usize);
}
extern "C" {
    pub fn ntohl(__netlong: u32) -> u32;
}
extern "C" {
    pub fn ntohs(__netshort: u16) -> u16;
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    pub fn bindresvport(__sockfd: ::std::os::raw::c_int,
                        __sock_in: *mut sockaddr_in) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bindresvport6(__sockfd: ::std::os::raw::c_int,
                         __sock_in: *mut sockaddr_in6)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rpcent {
    pub r_name: *mut ::std::os::raw::c_char,
    pub r_aliases: *mut *mut ::std::os::raw::c_char,
    pub r_number: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rpcent() {
    assert_eq!(::std::mem::size_of::<rpcent>() , 24usize);
    assert_eq!(::std::mem::align_of::<rpcent>() , 8usize);
}
impl Clone for rpcent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setrpcent(__stayopen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endrpcent();
}
extern "C" {
    pub fn getrpcbyname(__name: *const ::std::os::raw::c_char) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbynumber(__number: ::std::os::raw::c_int) -> *mut rpcent;
}
extern "C" {
    pub fn getrpcent() -> *mut rpcent;
}
extern "C" {
    pub fn getrpcbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut rpcent,
                          __buffer: *mut ::std::os::raw::c_char,
                          __buflen: usize, __result: *mut *mut rpcent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcbynumber_r(__number: ::std::os::raw::c_int,
                            __result_buf: *mut rpcent,
                            __buffer: *mut ::std::os::raw::c_char,
                            __buflen: usize, __result: *mut *mut rpcent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrpcent_r(__result_buf: *mut rpcent,
                       __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                       __result: *mut *mut rpcent) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct netent {
    pub n_name: *mut ::std::os::raw::c_char,
    pub n_aliases: *mut *mut ::std::os::raw::c_char,
    pub n_addrtype: ::std::os::raw::c_int,
    pub n_net: u32,
}
#[test]
fn bindgen_test_layout_netent() {
    assert_eq!(::std::mem::size_of::<netent>() , 24usize);
    assert_eq!(::std::mem::align_of::<netent>() , 8usize);
}
impl Clone for netent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __h_errno_location() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn herror(__str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn hstrerror(__err_num: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hostent {
    pub h_name: *mut ::std::os::raw::c_char,
    pub h_aliases: *mut *mut ::std::os::raw::c_char,
    pub h_addrtype: ::std::os::raw::c_int,
    pub h_length: ::std::os::raw::c_int,
    pub h_addr_list: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hostent() {
    assert_eq!(::std::mem::size_of::<hostent>() , 32usize);
    assert_eq!(::std::mem::align_of::<hostent>() , 8usize);
}
impl Clone for hostent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sethostent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endhostent();
}
extern "C" {
    pub fn gethostent() -> *mut hostent;
}
extern "C" {
    pub fn gethostbyaddr(__addr: *const ::std::os::raw::c_void,
                         __len: __socklen_t, __type: ::std::os::raw::c_int)
     -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname(__name: *const ::std::os::raw::c_char)
     -> *mut hostent;
}
extern "C" {
    pub fn gethostbyname2(__name: *const ::std::os::raw::c_char,
                          __af: ::std::os::raw::c_int) -> *mut hostent;
}
extern "C" {
    pub fn gethostent_r(__result_buf: *mut hostent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                        __result: *mut *mut hostent,
                        __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyaddr_r(__addr: *const ::std::os::raw::c_void,
                           __len: __socklen_t, __type: ::std::os::raw::c_int,
                           __result_buf: *mut hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname_r(__name: *const ::std::os::raw::c_char,
                           __result_buf: *mut hostent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut hostent,
                           __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostbyname2_r(__name: *const ::std::os::raw::c_char,
                            __af: ::std::os::raw::c_int,
                            __result_buf: *mut hostent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: usize, __result: *mut *mut hostent,
                            __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endnetent();
}
extern "C" {
    pub fn getnetent() -> *mut netent;
}
extern "C" {
    pub fn getnetbyaddr(__net: u32, __type: ::std::os::raw::c_int)
     -> *mut netent;
}
extern "C" {
    pub fn getnetbyname(__name: *const ::std::os::raw::c_char) -> *mut netent;
}
extern "C" {
    pub fn getnetent_r(__result_buf: *mut netent,
                       __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                       __result: *mut *mut netent,
                       __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyaddr_r(__net: u32, __type: ::std::os::raw::c_int,
                          __result_buf: *mut netent,
                          __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                          __result: *mut *mut netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetbyname_r(__name: *const ::std::os::raw::c_char,
                          __result_buf: *mut netent,
                          __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                          __result: *mut *mut netent,
                          __h_errnop: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct servent {
    pub s_name: *mut ::std::os::raw::c_char,
    pub s_aliases: *mut *mut ::std::os::raw::c_char,
    pub s_port: ::std::os::raw::c_int,
    pub s_proto: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_servent() {
    assert_eq!(::std::mem::size_of::<servent>() , 32usize);
    assert_eq!(::std::mem::align_of::<servent>() , 8usize);
}
impl Clone for servent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setservent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endservent();
}
extern "C" {
    pub fn getservent() -> *mut servent;
}
extern "C" {
    pub fn getservbyname(__name: *const ::std::os::raw::c_char,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut servent;
}
extern "C" {
    pub fn getservbyport(__port: ::std::os::raw::c_int,
                         __proto: *const ::std::os::raw::c_char)
     -> *mut servent;
}
extern "C" {
    pub fn getservent_r(__result_buf: *mut servent,
                        __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                        __result: *mut *mut servent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyname_r(__name: *const ::std::os::raw::c_char,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut servent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getservbyport_r(__port: ::std::os::raw::c_int,
                           __proto: *const ::std::os::raw::c_char,
                           __result_buf: *mut servent,
                           __buf: *mut ::std::os::raw::c_char,
                           __buflen: usize, __result: *mut *mut servent)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct protoent {
    pub p_name: *mut ::std::os::raw::c_char,
    pub p_aliases: *mut *mut ::std::os::raw::c_char,
    pub p_proto: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_protoent() {
    assert_eq!(::std::mem::size_of::<protoent>() , 24usize);
    assert_eq!(::std::mem::align_of::<protoent>() , 8usize);
}
impl Clone for protoent {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setprotoent(__stay_open: ::std::os::raw::c_int);
}
extern "C" {
    pub fn endprotoent();
}
extern "C" {
    pub fn getprotoent() -> *mut protoent;
}
extern "C" {
    pub fn getprotobyname(__name: *const ::std::os::raw::c_char)
     -> *mut protoent;
}
extern "C" {
    pub fn getprotobynumber(__proto: ::std::os::raw::c_int) -> *mut protoent;
}
extern "C" {
    pub fn getprotoent_r(__result_buf: *mut protoent,
                         __buf: *mut ::std::os::raw::c_char, __buflen: usize,
                         __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobyname_r(__name: *const ::std::os::raw::c_char,
                            __result_buf: *mut protoent,
                            __buf: *mut ::std::os::raw::c_char,
                            __buflen: usize, __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprotobynumber_r(__proto: ::std::os::raw::c_int,
                              __result_buf: *mut protoent,
                              __buf: *mut ::std::os::raw::c_char,
                              __buflen: usize, __result: *mut *mut protoent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setnetgrent(__netgroup: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn endnetgrent();
}
extern "C" {
    pub fn getnetgrent(__hostp: *mut *mut ::std::os::raw::c_char,
                       __userp: *mut *mut ::std::os::raw::c_char,
                       __domainp: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn innetgr(__netgroup: *const ::std::os::raw::c_char,
                   __host: *const ::std::os::raw::c_char,
                   __user: *const ::std::os::raw::c_char,
                   __domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getnetgrent_r(__hostp: *mut *mut ::std::os::raw::c_char,
                         __userp: *mut *mut ::std::os::raw::c_char,
                         __domainp: *mut *mut ::std::os::raw::c_char,
                         __buffer: *mut ::std::os::raw::c_char,
                         __buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd(__ahost: *mut *mut ::std::os::raw::c_char,
                __rport: ::std::os::raw::c_ushort,
                __locuser: *const ::std::os::raw::c_char,
                __remuser: *const ::std::os::raw::c_char,
                __cmd: *const ::std::os::raw::c_char,
                __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rcmd_af(__ahost: *mut *mut ::std::os::raw::c_char,
                   __rport: ::std::os::raw::c_ushort,
                   __locuser: *const ::std::os::raw::c_char,
                   __remuser: *const ::std::os::raw::c_char,
                   __cmd: *const ::std::os::raw::c_char,
                   __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec(__ahost: *mut *mut ::std::os::raw::c_char,
                 __rport: ::std::os::raw::c_int,
                 __name: *const ::std::os::raw::c_char,
                 __pass: *const ::std::os::raw::c_char,
                 __cmd: *const ::std::os::raw::c_char,
                 __fd2p: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rexec_af(__ahost: *mut *mut ::std::os::raw::c_char,
                    __rport: ::std::os::raw::c_int,
                    __name: *const ::std::os::raw::c_char,
                    __pass: *const ::std::os::raw::c_char,
                    __cmd: *const ::std::os::raw::c_char,
                    __fd2p: *mut ::std::os::raw::c_int, __af: sa_family_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok(__rhost: *const ::std::os::raw::c_char,
                   __suser: ::std::os::raw::c_int,
                   __remuser: *const ::std::os::raw::c_char,
                   __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ruserok_af(__rhost: *const ::std::os::raw::c_char,
                      __suser: ::std::os::raw::c_int,
                      __remuser: *const ::std::os::raw::c_char,
                      __locuser: *const ::std::os::raw::c_char,
                      __af: sa_family_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok(__raddr: u32, __suser: ::std::os::raw::c_int,
                    __remuser: *const ::std::os::raw::c_char,
                    __locuser: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iruserok_af(__raddr: *const ::std::os::raw::c_void,
                       __suser: ::std::os::raw::c_int,
                       __remuser: *const ::std::os::raw::c_char,
                       __locuser: *const ::std::os::raw::c_char,
                       __af: sa_family_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport(__alport: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rresvport_af(__alport: *mut ::std::os::raw::c_int,
                        __af: sa_family_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_socktype: ::std::os::raw::c_int,
    pub ai_protocol: ::std::os::raw::c_int,
    pub ai_addrlen: socklen_t,
    pub ai_addr: *mut sockaddr,
    pub ai_canonname: *mut ::std::os::raw::c_char,
    pub ai_next: *mut addrinfo,
}
#[test]
fn bindgen_test_layout_addrinfo() {
    assert_eq!(::std::mem::size_of::<addrinfo>() , 48usize);
    assert_eq!(::std::mem::align_of::<addrinfo>() , 8usize);
}
impl Clone for addrinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn getaddrinfo(__name: *const ::std::os::raw::c_char,
                       __service: *const ::std::os::raw::c_char,
                       __req: *const addrinfo, __pai: *mut *mut addrinfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn freeaddrinfo(__ai: *mut addrinfo);
}
extern "C" {
    pub fn gai_strerror(__ecode: ::std::os::raw::c_int)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn getnameinfo(__sa: *const sockaddr, __salen: socklen_t,
                       __host: *mut ::std::os::raw::c_char,
                       __hostlen: socklen_t,
                       __serv: *mut ::std::os::raw::c_char,
                       __servlen: socklen_t, __flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct passwd {
    pub pw_name: *mut ::std::os::raw::c_char,
    pub pw_passwd: *mut ::std::os::raw::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut ::std::os::raw::c_char,
    pub pw_dir: *mut ::std::os::raw::c_char,
    pub pw_shell: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_passwd() {
    assert_eq!(::std::mem::size_of::<passwd>() , 48usize);
    assert_eq!(::std::mem::align_of::<passwd>() , 8usize);
}
impl Clone for passwd {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn setpwent();
}
extern "C" {
    pub fn endpwent();
}
extern "C" {
    pub fn getpwent() -> *mut passwd;
}
extern "C" {
    pub fn fgetpwent(__stream: *mut FILE) -> *mut passwd;
}
extern "C" {
    pub fn putpwent(__p: *const passwd, __f: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwuid(__uid: __uid_t) -> *mut passwd;
}
extern "C" {
    pub fn getpwnam(__name: *const ::std::os::raw::c_char) -> *mut passwd;
}
extern "C" {
    pub fn getpwent_r(__resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwuid_r(__uid: __uid_t, __resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpwnam_r(__name: *const ::std::os::raw::c_char,
                      __resultbuf: *mut passwd,
                      __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                      __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpwent_r(__stream: *mut FILE, __resultbuf: *mut passwd,
                       __buffer: *mut ::std::os::raw::c_char, __buflen: usize,
                       __result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
pub type pgsocket = ::std::os::raw::c_int;
extern "C" {
    pub fn pg_set_noblock(sock: pgsocket) -> bool_;
}
extern "C" {
    pub fn pg_set_block(sock: pgsocket) -> bool_;
}
extern "C" {
    pub fn has_drive_prefix(filename: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn first_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn last_dir_separator(filename: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn first_path_var_separator(pathlist: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn join_path_components(ret_path: *mut ::std::os::raw::c_char,
                                head: *const ::std::os::raw::c_char,
                                tail: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn canonicalize_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn make_native_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn cleanup_path(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn path_contains_parent_reference(path: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn path_is_relative_and_below_cwd(path: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn path_is_prefix_of_path(path1: *const ::std::os::raw::c_char,
                                  path2: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn make_absolute_path(path: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_progname(argv0: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_share_path(my_exec_path: *const ::std::os::raw::c_char,
                          ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_etc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_include_path(my_exec_path: *const ::std::os::raw::c_char,
                            ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_pkginclude_path(my_exec_path: *const ::std::os::raw::c_char,
                               ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_includeserver_path(my_exec_path: *const ::std::os::raw::c_char,
                                  ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_lib_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_pkglib_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_locale_path(my_exec_path: *const ::std::os::raw::c_char,
                           ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_doc_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_html_path(my_exec_path: *const ::std::os::raw::c_char,
                         ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_man_path(my_exec_path: *const ::std::os::raw::c_char,
                        ret_path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn get_home_path(ret_path: *mut ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn get_parent_directory(path: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pgfnames(path: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pgfnames_cleanup(filenames: *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn set_pglocale_pgservice(argv0: *const ::std::os::raw::c_char,
                                  app: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn find_my_exec(argv0: *const ::std::os::raw::c_char,
                        retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn find_other_exec(argv0: *const ::std::os::raw::c_char,
                           target: *const ::std::os::raw::c_char,
                           versionstr: *const ::std::os::raw::c_char,
                           retpath: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_usleep(microsec: ::std::os::raw::c_long);
}
extern "C" {
    pub fn pg_strcasecmp(s1: *const ::std::os::raw::c_char,
                         s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_strncasecmp(s1: *const ::std::os::raw::c_char,
                          s2: *const ::std::os::raw::c_char, n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn simple_prompt(prompt: *const ::std::os::raw::c_char,
                         maxlen: ::std::os::raw::c_int, echo: bool_)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pclose_check(stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmtree(path: *const ::std::os::raw::c_char, rmtopdir: bool_)
     -> bool_;
}
extern "C" {
    pub fn pg_erand48(xseed: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn pg_lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn pg_srand48(seed: ::std::os::raw::c_long);
}
extern "C" {
    pub fn fls(mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpeereid(sock: ::std::os::raw::c_int, uid: *mut uid_t,
                      gid: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlcat(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: usize) -> usize;
}
extern "C" {
    pub fn strlcpy(dst: *mut ::std::os::raw::c_char,
                   src: *const ::std::os::raw::c_char, siz: usize) -> usize;
}
extern "C" {
    pub fn pqStrerror(errnum: ::std::os::raw::c_int,
                      strerrbuf: *mut ::std::os::raw::c_char, buflen: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pqGetpwuid(uid: uid_t, resultbuf: *mut passwd,
                      buffer: *mut ::std::os::raw::c_char, buflen: usize,
                      result: *mut *mut passwd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pqGethostbyname(name: *const ::std::os::raw::c_char,
                           resultbuf: *mut hostent,
                           buffer: *mut ::std::os::raw::c_char, buflen: usize,
                           result: *mut *mut hostent,
                           herrno: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_qsort(base: *mut ::std::os::raw::c_void, nel: usize,
                    elsize: usize,
                    cmp:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::std::os::raw::c_void,
                                                                   arg2:
                                                                       *const ::std::os::raw::c_void)
                                                  -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn pg_qsort_strcmp(a: *const ::std::os::raw::c_void,
                           b: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
pub type qsort_arg_comparator =
    ::std::option::Option<unsafe extern "C" fn(a:
                                                   *const ::std::os::raw::c_void,
                                               b:
                                                   *const ::std::os::raw::c_void,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn qsort_arg(base: *mut ::std::os::raw::c_void, nel: usize,
                     elsize: usize, cmp: qsort_arg_comparator,
                     arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pg_get_encoding_from_locale(ctype: *const ::std::os::raw::c_char,
                                       write_message: bool_)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_net_ntop(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_void,
                         bits: ::std::os::raw::c_int,
                         dst: *mut ::std::os::raw::c_char, size: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_check_dir(dir: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_mkdir_p(path: *mut ::std::os::raw::c_char,
                      omode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type pqsigfunc =
    ::std::option::Option<unsafe extern "C" fn(signo: ::std::os::raw::c_int)>;
extern "C" {
    pub fn pqsignal(signo: ::std::os::raw::c_int, func: pqsigfunc)
     -> pqsigfunc;
}
extern "C" {
    pub fn escape_single_quotes_ascii(src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wait_result_to_str(exit_status: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(::std::mem::size_of::<__jmp_buf_tag>() , 200usize);
    assert_eq!(::std::mem::align_of::<__jmp_buf_tag>() , 8usize);
}
impl Clone for __jmp_buf_tag {
    fn clone(&self) -> Self { *self }
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag,
                       __savemask: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _setjmp(__env: *mut __jmp_buf_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _longjmp(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
extern "C" {
    pub fn siglongjmp(__env: *mut __jmp_buf_tag,
                      __val: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "__longjmp_chk"]
    pub fn longjmp1(__env: *mut __jmp_buf_tag, __val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn errstart(elevel: ::std::os::raw::c_int,
                    filename: *const ::std::os::raw::c_char,
                    lineno: ::std::os::raw::c_int,
                    funcname: *const ::std::os::raw::c_char,
                    domain: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn errfinish(dummy: ::std::os::raw::c_int, ...);
}
extern "C" {
    pub fn errcode(sqlerrcode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errcode_for_file_access() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errcode_for_socket_access() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errmsg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errmsg_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errmsg_plural(fmt_singular: *const ::std::os::raw::c_char,
                         fmt_plural: *const ::std::os::raw::c_char,
                         n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_internal(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_log(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_log_plural(fmt_singular: *const ::std::os::raw::c_char,
                                fmt_plural: *const ::std::os::raw::c_char,
                                n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdetail_plural(fmt_singular: *const ::std::os::raw::c_char,
                            fmt_plural: *const ::std::os::raw::c_char,
                            n: ::std::os::raw::c_ulong, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errhint(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_errcontext_domain(domain: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errcontext_msg(fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errhidestmt(hide_stmt: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errhidecontext(hide_ctx: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errfunction(funcname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn internalerrposition(cursorpos: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn internalerrquery(query: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn err_generic_string(field: ::std::os::raw::c_int,
                              str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geterrcode() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geterrposition() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getinternalerrposition() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn elog_start(filename: *const ::std::os::raw::c_char,
                      lineno: ::std::os::raw::c_int,
                      funcname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn elog_finish(elevel: ::std::os::raw::c_int,
                       fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn pre_format_elog_string(errnumber: ::std::os::raw::c_int,
                                  domain: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn format_elog_string(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ErrorContextCallback {
    pub previous: *mut ErrorContextCallback,
    pub callback: ::std::option::Option<unsafe extern "C" fn(arg:
                                                                 *mut ::std::os::raw::c_void)>,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ErrorContextCallback() {
    assert_eq!(::std::mem::size_of::<ErrorContextCallback>() , 24usize);
    assert_eq!(::std::mem::align_of::<ErrorContextCallback>() , 8usize);
}
impl Clone for ErrorContextCallback {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "error_context_stack"]
    pub static mut error_context_stack: *mut ErrorContextCallback;
}
extern "C" {
    #[link_name = "PG_exception_stack"]
    pub static mut PG_exception_stack: *mut sigjmp_buf;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ErrorData {
    pub elevel: ::std::os::raw::c_int,
    pub output_to_server: bool_,
    pub output_to_client: bool_,
    pub show_funcname: bool_,
    pub hide_stmt: bool_,
    pub hide_ctx: bool_,
    pub filename: *const ::std::os::raw::c_char,
    pub lineno: ::std::os::raw::c_int,
    pub funcname: *const ::std::os::raw::c_char,
    pub domain: *const ::std::os::raw::c_char,
    pub context_domain: *const ::std::os::raw::c_char,
    pub sqlerrcode: ::std::os::raw::c_int,
    pub message: *mut ::std::os::raw::c_char,
    pub detail: *mut ::std::os::raw::c_char,
    pub detail_log: *mut ::std::os::raw::c_char,
    pub hint: *mut ::std::os::raw::c_char,
    pub context: *mut ::std::os::raw::c_char,
    pub message_id: *const ::std::os::raw::c_char,
    pub schema_name: *mut ::std::os::raw::c_char,
    pub table_name: *mut ::std::os::raw::c_char,
    pub column_name: *mut ::std::os::raw::c_char,
    pub datatype_name: *mut ::std::os::raw::c_char,
    pub constraint_name: *mut ::std::os::raw::c_char,
    pub cursorpos: ::std::os::raw::c_int,
    pub internalpos: ::std::os::raw::c_int,
    pub internalquery: *mut ::std::os::raw::c_char,
    pub saved_errno: ::std::os::raw::c_int,
    pub assoc_context: *mut ErrorData_MemoryContextData,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ErrorData_MemoryContextData([u8; 0]);
#[test]
fn bindgen_test_layout_ErrorData() {
    assert_eq!(::std::mem::size_of::<ErrorData>() , 184usize);
    assert_eq!(::std::mem::align_of::<ErrorData>() , 8usize);
}
impl Clone for ErrorData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn EmitErrorReport();
}
extern "C" {
    pub fn CopyErrorData() -> *mut ErrorData;
}
extern "C" {
    pub fn FreeErrorData(edata: *mut ErrorData);
}
extern "C" {
    pub fn FlushErrorState();
}
extern "C" {
    pub fn ReThrowError(edata: *mut ErrorData);
}
extern "C" {
    pub fn ThrowErrorData(edata: *mut ErrorData);
}
extern "C" {
    pub fn pg_re_throw();
}
extern "C" {
    pub fn GetErrorContextStack() -> *mut ::std::os::raw::c_char;
}
pub type emit_log_hook_type =
    ::std::option::Option<unsafe extern "C" fn(edata: *mut ErrorData)>;
extern "C" {
    #[link_name = "emit_log_hook"]
    pub static mut emit_log_hook: emit_log_hook_type;
}
pub const PGERROR_TERSE: _bindgen_ty_31 = _bindgen_ty_31::PGERROR_TERSE;
pub const PGERROR_DEFAULT: _bindgen_ty_31 = _bindgen_ty_31::PGERROR_DEFAULT;
pub const PGERROR_VERBOSE: _bindgen_ty_31 = _bindgen_ty_31::PGERROR_VERBOSE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_31 {
    PGERROR_TERSE = 0,
    PGERROR_DEFAULT = 1,
    PGERROR_VERBOSE = 2,
}
pub use self::_bindgen_ty_31 as PGErrorVerbosity;
extern "C" {
    #[link_name = "Log_error_verbosity"]
    pub static mut Log_error_verbosity: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "Log_line_prefix"]
    pub static mut Log_line_prefix: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "Log_destination"]
    pub static mut Log_destination: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "Log_destination_string"]
    pub static mut Log_destination_string: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "syslog_sequence_numbers"]
    pub static mut syslog_sequence_numbers: bool_;
}
extern "C" {
    #[link_name = "syslog_split_messages"]
    pub static mut syslog_split_messages: bool_;
}
extern "C" {
    pub fn DebugFileOpen();
}
extern "C" {
    pub fn unpack_sql_state(sql_state: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn in_error_recursion_trouble() -> bool_;
}
extern "C" {
    pub fn set_syslog_parameters(ident: *const ::std::os::raw::c_char,
                                 facility: ::std::os::raw::c_int);
}
extern "C" {
    pub fn write_stderr(fmt: *const ::std::os::raw::c_char, ...);
}
pub type MemoryContext = *mut ErrorData_MemoryContextData;
pub type MemoryContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MemoryContextCallback {
    pub func: MemoryContextCallbackFunction,
    pub arg: *mut ::std::os::raw::c_void,
    pub next: *mut MemoryContextCallback,
}
#[test]
fn bindgen_test_layout_MemoryContextCallback() {
    assert_eq!(::std::mem::size_of::<MemoryContextCallback>() , 24usize);
    assert_eq!(::std::mem::align_of::<MemoryContextCallback>() , 8usize);
}
impl Clone for MemoryContextCallback {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "CurrentMemoryContext"]
    pub static mut CurrentMemoryContext: MemoryContext;
}
extern "C" {
    pub fn MemoryContextAlloc(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextAllocZero(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextAllocZeroAligned(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextAllocExtended(context: MemoryContext, size: Size,
                                      flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn palloc(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn palloc0(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn palloc_extended(size: Size, flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn repalloc(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pfree(pointer: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn MemoryContextAllocHuge(context: MemoryContext, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn repalloc_huge(pointer: *mut ::std::os::raw::c_void, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MemoryContextRegisterResetCallback(context: MemoryContext,
                                              cb: *mut MemoryContextCallback);
}
extern "C" {
    pub fn MemoryContextStrdup(context: MemoryContext,
                               string: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pstrdup(in_: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pnstrdup(in_: *const ::std::os::raw::c_char, len: Size)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn psprintf(fmt: *const ::std::os::raw::c_char, ...)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pvsnprintf(buf: *mut ::std::os::raw::c_char, len: usize,
                      fmt: *const ::std::os::raw::c_char,
                      args: *mut __va_list_tag) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extsize: int32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
#[test]
fn bindgen_test_layout_varatt_external() {
    assert_eq!(::std::mem::size_of::<varatt_external>() , 16usize);
    assert_eq!(::std::mem::align_of::<varatt_external>() , 4usize);
}
impl Clone for varatt_external {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct varatt_indirect {
    pub pointer: *mut varlena,
}
#[test]
fn bindgen_test_layout_varatt_indirect() {
    assert_eq!(::std::mem::size_of::<varatt_indirect>() , 8usize);
    assert_eq!(::std::mem::align_of::<varatt_indirect>() , 8usize);
}
impl Clone for varatt_indirect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedObjectHeader([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
#[test]
fn bindgen_test_layout_varatt_expanded() {
    assert_eq!(::std::mem::size_of::<varatt_expanded>() , 8usize);
    assert_eq!(::std::mem::align_of::<varatt_expanded>() , 8usize);
}
impl Clone for varatt_expanded {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum vartag_external {
    VARTAG_INDIRECT = 1,
    VARTAG_EXPANDED_RO = 2,
    VARTAG_EXPANDED_RW = 3,
    VARTAG_ONDISK = 18,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_32 {
    pub va_4byte: __BindgenUnionField<_bindgen_ty_32__bindgen_ty_1>,
    pub va_compressed: __BindgenUnionField<_bindgen_ty_32__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_32__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_32__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_32__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_32__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _bindgen_ty_32__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_32__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_rawsize: uint32,
    pub va_data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_32__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_32__bindgen_ty_2>() ,
               8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_32__bindgen_ty_2>() ,
               4usize);
}
impl Clone for _bindgen_ty_32__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_32() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_32>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_32>() , 4usize);
}
impl Clone for _bindgen_ty_32 {
    fn clone(&self) -> Self { *self }
}
pub type varattrib_4b = _bindgen_ty_32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_33 {
    pub va_header: uint8,
    pub va_data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_33() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_33>() , 1usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_33>() , 1usize);
}
impl Clone for _bindgen_ty_33 {
    fn clone(&self) -> Self { *self }
}
pub type varattrib_1b = _bindgen_ty_33;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_34 {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_34() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_34>() , 2usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_34>() , 1usize);
}
impl Clone for _bindgen_ty_34 {
    fn clone(&self) -> Self { *self }
}
pub type varattrib_1b_e = _bindgen_ty_34;
pub type Datum = usize;
pub type DatumPtr = *mut Datum;
extern "C" {
    pub fn DatumGetFloat4(X: Datum) -> float4;
}
extern "C" {
    pub fn Float4GetDatum(X: float4) -> Datum;
}
extern "C" {
    pub fn DatumGetFloat8(X: Datum) -> float8;
}
extern "C" {
    pub fn Float8GetDatum(X: float8) -> Datum;
}
extern "C" {
    pub fn ExceptionalCondition(conditionName: *const ::std::os::raw::c_char,
                                errorType: *const ::std::os::raw::c_char,
                                fileName: *const ::std::os::raw::c_char,
                                lineNumber: ::std::os::raw::c_int);
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ScanDirection {
    BackwardScanDirection = -1,
    NoMovementScanDirection = 0,
    ForwardScanDirection = 1,
}
pub type AttrNumber = int16;
pub type StrategyNumber = uint16;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Node {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_Node() {
    assert_eq!(::std::mem::size_of::<Node>() , 4usize);
    assert_eq!(::std::mem::align_of::<Node>() , 4usize);
}
impl Clone for Node {
    fn clone(&self) -> Self { *self }
}
pub type fmNodePtr = *mut Node;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Aggref {
    pub xpr: Expr,
    pub aggfnoid: Oid,
    pub aggtype: Oid,
    pub aggcollid: Oid,
    pub inputcollid: Oid,
    pub aggtranstype: Oid,
    pub aggargtypes: *mut List,
    pub aggdirectargs: *mut List,
    pub args: *mut List,
    pub aggorder: *mut List,
    pub aggdistinct: *mut List,
    pub aggfilter: *mut Expr,
    pub aggstar: bool_,
    pub aggvariadic: bool_,
    pub aggkind: ::std::os::raw::c_char,
    pub agglevelsup: Index,
    pub aggsplit: AggSplit,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Aggref() {
    assert_eq!(::std::mem::size_of::<Aggref>() , 88usize);
    assert_eq!(::std::mem::align_of::<Aggref>() , 8usize);
}
impl Clone for Aggref {
    fn clone(&self) -> Self { *self }
}
pub type fmAggrefPtr = *mut Aggref;
pub type fmExprContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StringInfoData {
    pub data: *mut ::std::os::raw::c_char,
    pub len: ::std::os::raw::c_int,
    pub maxlen: ::std::os::raw::c_int,
    pub cursor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StringInfoData() {
    assert_eq!(::std::mem::size_of::<StringInfoData>() , 24usize);
    assert_eq!(::std::mem::align_of::<StringInfoData>() , 8usize);
}
impl Clone for StringInfoData {
    fn clone(&self) -> Self { *self }
}
pub type fmStringInfo = *mut StringInfoData;
#[repr(C)]
pub struct FunctionCallInfoData {
    pub flinfo: *mut FmgrInfo,
    pub context: fmNodePtr,
    pub resultinfo: fmNodePtr,
    pub fncollation: Oid,
    pub isnull: bool_,
    pub nargs: ::std::os::raw::c_short,
    pub arg: [Datum; 100usize],
    pub argnull: [bool_; 100usize],
}
#[test]
fn bindgen_test_layout_FunctionCallInfoData() {
    assert_eq!(::std::mem::size_of::<FunctionCallInfoData>() , 936usize);
    assert_eq!(::std::mem::align_of::<FunctionCallInfoData>() , 8usize);
}
pub type FunctionCallInfo = *mut FunctionCallInfoData;
pub type PGFunction =
    ::std::option::Option<unsafe extern "C" fn(fcinfo: FunctionCallInfo)
                              -> ::std::os::raw::c_ulong>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FmgrInfo {
    pub fn_addr: PGFunction,
    pub fn_oid: Oid,
    pub fn_nargs: ::std::os::raw::c_short,
    pub fn_strict: bool_,
    pub fn_retset: bool_,
    pub fn_stats: ::std::os::raw::c_uchar,
    pub fn_extra: *mut ::std::os::raw::c_void,
    pub fn_mcxt: MemoryContext,
    pub fn_expr: fmNodePtr,
}
#[test]
fn bindgen_test_layout_FmgrInfo() {
    assert_eq!(::std::mem::size_of::<FmgrInfo>() , 48usize);
    assert_eq!(::std::mem::align_of::<FmgrInfo>() , 8usize);
}
impl Clone for FmgrInfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn fmgr_info(functionId: Oid, finfo: *mut FmgrInfo);
}
extern "C" {
    pub fn fmgr_info_cxt(functionId: Oid, finfo: *mut FmgrInfo,
                         mcxt: MemoryContext);
}
extern "C" {
    pub fn fmgr_info_copy(dstinfo: *mut FmgrInfo, srcinfo: *mut FmgrInfo,
                          destcxt: MemoryContext);
}
extern "C" {
    pub fn pg_detoast_datum(datum: *mut varlena) -> *mut varlena;
}
extern "C" {
    pub fn pg_detoast_datum_copy(datum: *mut varlena) -> *mut varlena;
}
extern "C" {
    pub fn pg_detoast_datum_slice(datum: *mut varlena, first: int32,
                                  count: int32) -> *mut varlena;
}
extern "C" {
    pub fn pg_detoast_datum_packed(datum: *mut varlena) -> *mut varlena;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_35 {
    pub api_version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_35() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_35>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_35>() , 4usize);
}
impl Clone for _bindgen_ty_35 {
    fn clone(&self) -> Self { *self }
}
pub type Pg_finfo_record = _bindgen_ty_35;
pub type PGFInfoFunction =
    ::std::option::Option<unsafe extern "C" fn() -> *const _bindgen_ty_35>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_36 {
    pub len: ::std::os::raw::c_int,
    pub version: ::std::os::raw::c_int,
    pub funcmaxargs: ::std::os::raw::c_int,
    pub indexmaxkeys: ::std::os::raw::c_int,
    pub namedatalen: ::std::os::raw::c_int,
    pub float4byval: ::std::os::raw::c_int,
    pub float8byval: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_36() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_36>() , 28usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_36>() , 4usize);
}
impl Clone for _bindgen_ty_36 {
    fn clone(&self) -> Self { *self }
}
pub type Pg_magic_struct = _bindgen_ty_36;
pub type PGModuleMagicFunction =
    ::std::option::Option<unsafe extern "C" fn() -> *const _bindgen_ty_36>;
extern "C" {
    pub fn DirectFunctionCall1Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall2Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall3Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum)
     -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall4Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall5Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall6Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum)
     -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall7Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall8Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum) -> Datum;
}
extern "C" {
    pub fn DirectFunctionCall9Coll(func: PGFunction, collation: Oid,
                                   arg1: Datum, arg2: Datum, arg3: Datum,
                                   arg4: Datum, arg5: Datum, arg6: Datum,
                                   arg7: Datum, arg8: Datum, arg9: Datum)
     -> Datum;
}
extern "C" {
    pub fn FunctionCall1Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall2Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall3Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall4Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall5Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall6Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall7Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall8Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum) -> Datum;
}
extern "C" {
    pub fn FunctionCall9Coll(flinfo: *mut FmgrInfo, collation: Oid,
                             arg1: Datum, arg2: Datum, arg3: Datum,
                             arg4: Datum, arg5: Datum, arg6: Datum,
                             arg7: Datum, arg8: Datum, arg9: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall0Coll(functionId: Oid, collation: Oid) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall1Coll(functionId: Oid, collation: Oid, arg1: Datum)
     -> Datum;
}
extern "C" {
    pub fn OidFunctionCall2Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall3Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall4Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum)
     -> Datum;
}
extern "C" {
    pub fn OidFunctionCall5Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall6Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall7Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum)
     -> Datum;
}
extern "C" {
    pub fn OidFunctionCall8Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum) -> Datum;
}
extern "C" {
    pub fn OidFunctionCall9Coll(functionId: Oid, collation: Oid, arg1: Datum,
                                arg2: Datum, arg3: Datum, arg4: Datum,
                                arg5: Datum, arg6: Datum, arg7: Datum,
                                arg8: Datum, arg9: Datum) -> Datum;
}
extern "C" {
    pub fn InputFunctionCall(flinfo: *mut FmgrInfo,
                             str: *mut ::std::os::raw::c_char,
                             typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn OidInputFunctionCall(functionId: Oid,
                                str: *mut ::std::os::raw::c_char,
                                typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn OutputFunctionCall(flinfo: *mut FmgrInfo, val: Datum)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OidOutputFunctionCall(functionId: Oid, val: Datum)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ReceiveFunctionCall(flinfo: *mut FmgrInfo, buf: fmStringInfo,
                               typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn OidReceiveFunctionCall(functionId: Oid, buf: fmStringInfo,
                                  typioparam: Oid, typmod: int32) -> Datum;
}
extern "C" {
    pub fn SendFunctionCall(flinfo: *mut FmgrInfo, val: Datum) -> *mut bytea;
}
extern "C" {
    pub fn OidSendFunctionCall(functionId: Oid, val: Datum) -> *mut bytea;
}
extern "C" {
    pub fn fetch_finfo_record(filehandle: *mut ::std::os::raw::c_void,
                              funcname: *mut ::std::os::raw::c_char)
     -> *const Pg_finfo_record;
}
extern "C" {
    pub fn clear_external_function_hash(filehandle:
                                            *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn fmgr_internal_function(proname: *const ::std::os::raw::c_char)
     -> Oid;
}
extern "C" {
    pub fn get_fn_expr_rettype(flinfo: *mut FmgrInfo) -> Oid;
}
extern "C" {
    pub fn get_fn_expr_argtype(flinfo: *mut FmgrInfo,
                               argnum: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn get_call_expr_argtype(expr: fmNodePtr,
                                 argnum: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn get_fn_expr_arg_stable(flinfo: *mut FmgrInfo,
                                  argnum: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn get_call_expr_arg_stable(expr: fmNodePtr,
                                    argnum: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn get_fn_expr_variadic(flinfo: *mut FmgrInfo) -> bool_;
}
extern "C" {
    pub fn CheckFunctionValidatorAccess(validatorOid: Oid, functionOid: Oid)
     -> bool_;
}
extern "C" {
    #[link_name = "Dynamic_library_path"]
    pub static mut Dynamic_library_path: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn load_external_function(filename: *mut ::std::os::raw::c_char,
                                  funcname: *mut ::std::os::raw::c_char,
                                  signalNotFound: bool_,
                                  filehandle:
                                      *mut *mut ::std::os::raw::c_void)
     -> PGFunction;
}
extern "C" {
    pub fn lookup_external_function(filehandle: *mut ::std::os::raw::c_void,
                                    funcname: *mut ::std::os::raw::c_char)
     -> PGFunction;
}
extern "C" {
    pub fn load_file(filename: *const ::std::os::raw::c_char,
                     restricted: bool_);
}
extern "C" {
    pub fn find_rendezvous_variable(varName: *const ::std::os::raw::c_char)
     -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn EstimateLibraryStateSpace() -> Size;
}
extern "C" {
    pub fn SerializeLibraryState(maxsize: Size,
                                 start_address: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn RestoreLibraryState(start_address: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn AggCheckCallContext(fcinfo: FunctionCallInfo,
                               aggcontext: *mut MemoryContext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AggGetAggref(fcinfo: FunctionCallInfo) -> fmAggrefPtr;
}
extern "C" {
    pub fn AggGetTempMemoryContext(fcinfo: FunctionCallInfo) -> MemoryContext;
}
extern "C" {
    pub fn AggRegisterCallback(fcinfo: FunctionCallInfo,
                               func: fmExprContextCallbackFunction,
                               arg: Datum);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FmgrHookEventType { FHET_START = 0, FHET_END = 1, FHET_ABORT = 2, }
pub type needs_fmgr_hook_type =
    ::std::option::Option<unsafe extern "C" fn(fn_oid: Oid)
                              -> ::std::os::raw::c_char>;
pub type fmgr_hook_type =
    ::std::option::Option<unsafe extern "C" fn(event: FmgrHookEventType,
                                               flinfo: *mut FmgrInfo,
                                               arg: *mut Datum)>;
extern "C" {
    #[link_name = "needs_fmgr_hook"]
    pub static mut needs_fmgr_hook: needs_fmgr_hook_type;
}
extern "C" {
    #[link_name = "fmgr_hook"]
    pub static mut fmgr_hook: fmgr_hook_type;
}
extern "C" {
    pub fn fmgr(procedureId: Oid, ...) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScanKeyData {
    pub sk_flags: ::std::os::raw::c_int,
    pub sk_attno: AttrNumber,
    pub sk_strategy: StrategyNumber,
    pub sk_subtype: Oid,
    pub sk_collation: Oid,
    pub sk_func: FmgrInfo,
    pub sk_argument: Datum,
}
#[test]
fn bindgen_test_layout_ScanKeyData() {
    assert_eq!(::std::mem::size_of::<ScanKeyData>() , 72usize);
    assert_eq!(::std::mem::align_of::<ScanKeyData>() , 8usize);
}
impl Clone for ScanKeyData {
    fn clone(&self) -> Self { *self }
}
pub type ScanKey = *mut ScanKeyData;
extern "C" {
    pub fn ScanKeyInit(entry: ScanKey, attributeNumber: AttrNumber,
                       strategy: StrategyNumber, procedure: RegProcedure,
                       argument: Datum);
}
extern "C" {
    pub fn ScanKeyEntryInitialize(entry: ScanKey,
                                  flags: ::std::os::raw::c_int,
                                  attributeNumber: AttrNumber,
                                  strategy: StrategyNumber, subtype: Oid,
                                  collation: Oid, procedure: RegProcedure,
                                  argument: Datum);
}
extern "C" {
    pub fn ScanKeyEntryInitializeWithInfo(entry: ScanKey,
                                          flags: ::std::os::raw::c_int,
                                          attributeNumber: AttrNumber,
                                          strategy: StrategyNumber,
                                          subtype: Oid, collation: Oid,
                                          finfo: *mut FmgrInfo,
                                          argument: Datum);
}
pub type BlockNumber = uint32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BlockIdData {
    pub bi_hi: uint16,
    pub bi_lo: uint16,
}
#[test]
fn bindgen_test_layout_BlockIdData() {
    assert_eq!(::std::mem::size_of::<BlockIdData>() , 4usize);
    assert_eq!(::std::mem::align_of::<BlockIdData>() , 2usize);
}
impl Clone for BlockIdData {
    fn clone(&self) -> Self { *self }
}
pub type BlockId = *mut BlockIdData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ItemIdData {
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout_ItemIdData() {
    assert_eq!(::std::mem::size_of::<ItemIdData>() , 4usize);
    assert_eq!(::std::mem::align_of::<ItemIdData>() , 4usize);
}
impl Clone for ItemIdData {
    fn clone(&self) -> Self { *self }
}
impl ItemIdData {
    #[inline]
    pub fn lp_off(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32767usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_lp_off(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(32767usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (32767usize as u32);
    }
    #[inline]
    pub fn lp_flags(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (98304usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_lp_flags(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(98304usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (98304usize as u32);
    }
    #[inline]
    pub fn lp_len(&self) -> ::std::os::raw::c_uint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (4294836224usize as u32)) >> 17u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_lp_len(&mut self, val: ::std::os::raw::c_uint) {
        self._bitfield_1 &= !(4294836224usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (4294836224usize as u32);
    }
}
pub type ItemId = *mut ItemIdData;
pub type ItemOffset = uint16;
pub type ItemLength = uint16;
pub type OffsetNumber = uint16;
#[repr(C, packed)]
#[derive(Debug, Copy)]
pub struct ItemPointerData {
    pub ip_blkid: BlockIdData,
    pub ip_posid: OffsetNumber,
}
impl Clone for ItemPointerData {
    fn clone(&self) -> Self { *self }
}
pub type ItemPointer = *mut ItemPointerData;
extern "C" {
    pub fn ItemPointerEquals(pointer1: ItemPointer, pointer2: ItemPointer)
     -> bool_;
}
extern "C" {
    pub fn ItemPointerCompare(arg1: ItemPointer, arg2: ItemPointer) -> int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TIDBitmap([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBMIterator([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_37 {
    pub blockno: BlockNumber,
    pub ntuples: ::std::os::raw::c_int,
    pub recheck: bool_,
    pub offsets: *mut OffsetNumber,
}
#[test]
fn bindgen_test_layout__bindgen_ty_37() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_37>() , 12usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_37>() , 4usize);
}
impl Clone for _bindgen_ty_37 {
    fn clone(&self) -> Self { *self }
}
pub type TBMIterateResult = _bindgen_ty_37;
extern "C" {
    pub fn tbm_create(maxbytes: ::std::os::raw::c_long) -> *mut TIDBitmap;
}
extern "C" {
    pub fn tbm_free(tbm: *mut TIDBitmap);
}
extern "C" {
    pub fn tbm_add_tuples(tbm: *mut TIDBitmap, tids: ItemPointer,
                          ntids: ::std::os::raw::c_int, recheck: bool_);
}
extern "C" {
    pub fn tbm_add_page(tbm: *mut TIDBitmap, pageno: BlockNumber);
}
extern "C" {
    pub fn tbm_union(a: *mut TIDBitmap, b: *const TIDBitmap);
}
extern "C" {
    pub fn tbm_intersect(a: *mut TIDBitmap, b: *const TIDBitmap);
}
extern "C" {
    pub fn tbm_is_empty(tbm: *const TIDBitmap) -> bool_;
}
extern "C" {
    pub fn tbm_begin_iterate(tbm: *mut TIDBitmap) -> *mut TBMIterator;
}
extern "C" {
    pub fn tbm_iterate(iterator: *mut TBMIterator) -> *mut TBMIterateResult;
}
extern "C" {
    pub fn tbm_end_iterate(iterator: *mut TBMIterator);
}
pub type LOCKMASK = ::std::os::raw::c_int;
pub type LOCKMODE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xl_standby_lock {
    pub xid: TransactionId,
    pub dbOid: Oid,
    pub relOid: Oid,
}
#[test]
fn bindgen_test_layout_xl_standby_lock() {
    assert_eq!(::std::mem::size_of::<xl_standby_lock>() , 12usize);
    assert_eq!(::std::mem::align_of::<xl_standby_lock>() , 4usize);
}
impl Clone for xl_standby_lock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct FormData_pg_attribute {
    pub attrelid: Oid,
    pub attname: NameData,
    pub atttypid: Oid,
    pub attstattarget: int32,
    pub attlen: int16,
    pub attnum: int16,
    pub attndims: int32,
    pub attcacheoff: int32,
    pub atttypmod: int32,
    pub attbyval: bool_,
    pub attstorage: ::std::os::raw::c_char,
    pub attalign: ::std::os::raw::c_char,
    pub attnotnull: bool_,
    pub atthasdef: bool_,
    pub attisdropped: bool_,
    pub attislocal: bool_,
    pub attinhcount: int32,
    pub attcollation: Oid,
}
#[test]
fn bindgen_test_layout_FormData_pg_attribute() {
    assert_eq!(::std::mem::size_of::<FormData_pg_attribute>() , 108usize);
    assert_eq!(::std::mem::align_of::<FormData_pg_attribute>() , 4usize);
}
pub type Form_pg_attribute = *mut FormData_pg_attribute;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NodeTag {
    T_Invalid = 0,
    T_IndexInfo = 10,
    T_ExprContext = 11,
    T_ProjectionInfo = 12,
    T_JunkFilter = 13,
    T_ResultRelInfo = 14,
    T_EState = 15,
    T_TupleTableSlot = 16,
    T_Plan = 100,
    T_Result = 101,
    T_ModifyTable = 102,
    T_Append = 103,
    T_MergeAppend = 104,
    T_RecursiveUnion = 105,
    T_BitmapAnd = 106,
    T_BitmapOr = 107,
    T_Scan = 108,
    T_SeqScan = 109,
    T_SampleScan = 110,
    T_IndexScan = 111,
    T_IndexOnlyScan = 112,
    T_BitmapIndexScan = 113,
    T_BitmapHeapScan = 114,
    T_TidScan = 115,
    T_SubqueryScan = 116,
    T_FunctionScan = 117,
    T_ValuesScan = 118,
    T_CteScan = 119,
    T_WorkTableScan = 120,
    T_ForeignScan = 121,
    T_CustomScan = 122,
    T_Join = 123,
    T_NestLoop = 124,
    T_MergeJoin = 125,
    T_HashJoin = 126,
    T_Material = 127,
    T_Sort = 128,
    T_Group = 129,
    T_Agg = 130,
    T_WindowAgg = 131,
    T_Unique = 132,
    T_Gather = 133,
    T_Hash = 134,
    T_SetOp = 135,
    T_LockRows = 136,
    T_Limit = 137,
    T_NestLoopParam = 138,
    T_PlanRowMark = 139,
    T_PlanInvalItem = 140,
    T_PlanState = 200,
    T_ResultState = 201,
    T_ModifyTableState = 202,
    T_AppendState = 203,
    T_MergeAppendState = 204,
    T_RecursiveUnionState = 205,
    T_BitmapAndState = 206,
    T_BitmapOrState = 207,
    T_ScanState = 208,
    T_SeqScanState = 209,
    T_SampleScanState = 210,
    T_IndexScanState = 211,
    T_IndexOnlyScanState = 212,
    T_BitmapIndexScanState = 213,
    T_BitmapHeapScanState = 214,
    T_TidScanState = 215,
    T_SubqueryScanState = 216,
    T_FunctionScanState = 217,
    T_ValuesScanState = 218,
    T_CteScanState = 219,
    T_WorkTableScanState = 220,
    T_ForeignScanState = 221,
    T_CustomScanState = 222,
    T_JoinState = 223,
    T_NestLoopState = 224,
    T_MergeJoinState = 225,
    T_HashJoinState = 226,
    T_MaterialState = 227,
    T_SortState = 228,
    T_GroupState = 229,
    T_AggState = 230,
    T_WindowAggState = 231,
    T_UniqueState = 232,
    T_GatherState = 233,
    T_HashState = 234,
    T_SetOpState = 235,
    T_LockRowsState = 236,
    T_LimitState = 237,
    T_Alias = 300,
    T_RangeVar = 301,
    T_Expr = 302,
    T_Var = 303,
    T_Const = 304,
    T_Param = 305,
    T_Aggref = 306,
    T_GroupingFunc = 307,
    T_WindowFunc = 308,
    T_ArrayRef = 309,
    T_FuncExpr = 310,
    T_NamedArgExpr = 311,
    T_OpExpr = 312,
    T_DistinctExpr = 313,
    T_NullIfExpr = 314,
    T_ScalarArrayOpExpr = 315,
    T_BoolExpr = 316,
    T_SubLink = 317,
    T_SubPlan = 318,
    T_AlternativeSubPlan = 319,
    T_FieldSelect = 320,
    T_FieldStore = 321,
    T_RelabelType = 322,
    T_CoerceViaIO = 323,
    T_ArrayCoerceExpr = 324,
    T_ConvertRowtypeExpr = 325,
    T_CollateExpr = 326,
    T_CaseExpr = 327,
    T_CaseWhen = 328,
    T_CaseTestExpr = 329,
    T_ArrayExpr = 330,
    T_RowExpr = 331,
    T_RowCompareExpr = 332,
    T_CoalesceExpr = 333,
    T_MinMaxExpr = 334,
    T_XmlExpr = 335,
    T_NullTest = 336,
    T_BooleanTest = 337,
    T_CoerceToDomain = 338,
    T_CoerceToDomainValue = 339,
    T_SetToDefault = 340,
    T_CurrentOfExpr = 341,
    T_InferenceElem = 342,
    T_TargetEntry = 343,
    T_RangeTblRef = 344,
    T_JoinExpr = 345,
    T_FromExpr = 346,
    T_OnConflictExpr = 347,
    T_IntoClause = 348,
    T_ExprState = 400,
    T_GenericExprState = 401,
    T_WholeRowVarExprState = 402,
    T_AggrefExprState = 403,
    T_GroupingFuncExprState = 404,
    T_WindowFuncExprState = 405,
    T_ArrayRefExprState = 406,
    T_FuncExprState = 407,
    T_ScalarArrayOpExprState = 408,
    T_BoolExprState = 409,
    T_SubPlanState = 410,
    T_AlternativeSubPlanState = 411,
    T_FieldSelectState = 412,
    T_FieldStoreState = 413,
    T_CoerceViaIOState = 414,
    T_ArrayCoerceExprState = 415,
    T_ConvertRowtypeExprState = 416,
    T_CaseExprState = 417,
    T_CaseWhenState = 418,
    T_ArrayExprState = 419,
    T_RowExprState = 420,
    T_RowCompareExprState = 421,
    T_CoalesceExprState = 422,
    T_MinMaxExprState = 423,
    T_XmlExprState = 424,
    T_NullTestState = 425,
    T_CoerceToDomainState = 426,
    T_DomainConstraintState = 427,
    T_PlannerInfo = 500,
    T_PlannerGlobal = 501,
    T_RelOptInfo = 502,
    T_IndexOptInfo = 503,
    T_ForeignKeyOptInfo = 504,
    T_ParamPathInfo = 505,
    T_Path = 506,
    T_IndexPath = 507,
    T_BitmapHeapPath = 508,
    T_BitmapAndPath = 509,
    T_BitmapOrPath = 510,
    T_TidPath = 511,
    T_SubqueryScanPath = 512,
    T_ForeignPath = 513,
    T_CustomPath = 514,
    T_NestPath = 515,
    T_MergePath = 516,
    T_HashPath = 517,
    T_AppendPath = 518,
    T_MergeAppendPath = 519,
    T_ResultPath = 520,
    T_MaterialPath = 521,
    T_UniquePath = 522,
    T_GatherPath = 523,
    T_ProjectionPath = 524,
    T_SortPath = 525,
    T_GroupPath = 526,
    T_UpperUniquePath = 527,
    T_AggPath = 528,
    T_GroupingSetsPath = 529,
    T_MinMaxAggPath = 530,
    T_WindowAggPath = 531,
    T_SetOpPath = 532,
    T_RecursiveUnionPath = 533,
    T_LockRowsPath = 534,
    T_ModifyTablePath = 535,
    T_LimitPath = 536,
    T_EquivalenceClass = 537,
    T_EquivalenceMember = 538,
    T_PathKey = 539,
    T_PathTarget = 540,
    T_RestrictInfo = 541,
    T_PlaceHolderVar = 542,
    T_SpecialJoinInfo = 543,
    T_AppendRelInfo = 544,
    T_PlaceHolderInfo = 545,
    T_MinMaxAggInfo = 546,
    T_PlannerParamItem = 547,
    T_MemoryContext = 600,
    T_AllocSetContext = 601,
    T_Value = 650,
    T_Integer = 651,
    T_Float = 652,
    T_String = 653,
    T_BitString = 654,
    T_Null = 655,
    T_List = 656,
    T_IntList = 657,
    T_OidList = 658,
    T_ExtensibleNode = 659,
    T_Query = 700,
    T_PlannedStmt = 701,
    T_InsertStmt = 702,
    T_DeleteStmt = 703,
    T_UpdateStmt = 704,
    T_SelectStmt = 705,
    T_AlterTableStmt = 706,
    T_AlterTableCmd = 707,
    T_AlterDomainStmt = 708,
    T_SetOperationStmt = 709,
    T_GrantStmt = 710,
    T_GrantRoleStmt = 711,
    T_AlterDefaultPrivilegesStmt = 712,
    T_ClosePortalStmt = 713,
    T_ClusterStmt = 714,
    T_CopyStmt = 715,
    T_CreateStmt = 716,
    T_DefineStmt = 717,
    T_DropStmt = 718,
    T_TruncateStmt = 719,
    T_CommentStmt = 720,
    T_FetchStmt = 721,
    T_IndexStmt = 722,
    T_CreateFunctionStmt = 723,
    T_AlterFunctionStmt = 724,
    T_DoStmt = 725,
    T_RenameStmt = 726,
    T_RuleStmt = 727,
    T_NotifyStmt = 728,
    T_ListenStmt = 729,
    T_UnlistenStmt = 730,
    T_TransactionStmt = 731,
    T_ViewStmt = 732,
    T_LoadStmt = 733,
    T_CreateDomainStmt = 734,
    T_CreatedbStmt = 735,
    T_DropdbStmt = 736,
    T_VacuumStmt = 737,
    T_ExplainStmt = 738,
    T_CreateTableAsStmt = 739,
    T_CreateSeqStmt = 740,
    T_AlterSeqStmt = 741,
    T_VariableSetStmt = 742,
    T_VariableShowStmt = 743,
    T_DiscardStmt = 744,
    T_CreateTrigStmt = 745,
    T_CreatePLangStmt = 746,
    T_CreateRoleStmt = 747,
    T_AlterRoleStmt = 748,
    T_DropRoleStmt = 749,
    T_LockStmt = 750,
    T_ConstraintsSetStmt = 751,
    T_ReindexStmt = 752,
    T_CheckPointStmt = 753,
    T_CreateSchemaStmt = 754,
    T_AlterDatabaseStmt = 755,
    T_AlterDatabaseSetStmt = 756,
    T_AlterRoleSetStmt = 757,
    T_CreateConversionStmt = 758,
    T_CreateCastStmt = 759,
    T_CreateOpClassStmt = 760,
    T_CreateOpFamilyStmt = 761,
    T_AlterOpFamilyStmt = 762,
    T_PrepareStmt = 763,
    T_ExecuteStmt = 764,
    T_DeallocateStmt = 765,
    T_DeclareCursorStmt = 766,
    T_CreateTableSpaceStmt = 767,
    T_DropTableSpaceStmt = 768,
    T_AlterObjectDependsStmt = 769,
    T_AlterObjectSchemaStmt = 770,
    T_AlterOwnerStmt = 771,
    T_AlterOperatorStmt = 772,
    T_DropOwnedStmt = 773,
    T_ReassignOwnedStmt = 774,
    T_CompositeTypeStmt = 775,
    T_CreateEnumStmt = 776,
    T_CreateRangeStmt = 777,
    T_AlterEnumStmt = 778,
    T_AlterTSDictionaryStmt = 779,
    T_AlterTSConfigurationStmt = 780,
    T_CreateFdwStmt = 781,
    T_AlterFdwStmt = 782,
    T_CreateForeignServerStmt = 783,
    T_AlterForeignServerStmt = 784,
    T_CreateUserMappingStmt = 785,
    T_AlterUserMappingStmt = 786,
    T_DropUserMappingStmt = 787,
    T_AlterTableSpaceOptionsStmt = 788,
    T_AlterTableMoveAllStmt = 789,
    T_SecLabelStmt = 790,
    T_CreateForeignTableStmt = 791,
    T_ImportForeignSchemaStmt = 792,
    T_CreateExtensionStmt = 793,
    T_AlterExtensionStmt = 794,
    T_AlterExtensionContentsStmt = 795,
    T_CreateEventTrigStmt = 796,
    T_AlterEventTrigStmt = 797,
    T_RefreshMatViewStmt = 798,
    T_ReplicaIdentityStmt = 799,
    T_AlterSystemStmt = 800,
    T_CreatePolicyStmt = 801,
    T_AlterPolicyStmt = 802,
    T_CreateTransformStmt = 803,
    T_CreateAmStmt = 804,
    T_A_Expr = 900,
    T_ColumnRef = 901,
    T_ParamRef = 902,
    T_A_Const = 903,
    T_FuncCall = 904,
    T_A_Star = 905,
    T_A_Indices = 906,
    T_A_Indirection = 907,
    T_A_ArrayExpr = 908,
    T_ResTarget = 909,
    T_MultiAssignRef = 910,
    T_TypeCast = 911,
    T_CollateClause = 912,
    T_SortBy = 913,
    T_WindowDef = 914,
    T_RangeSubselect = 915,
    T_RangeFunction = 916,
    T_RangeTableSample = 917,
    T_TypeName = 918,
    T_ColumnDef = 919,
    T_IndexElem = 920,
    T_Constraint = 921,
    T_DefElem = 922,
    T_RangeTblEntry = 923,
    T_RangeTblFunction = 924,
    T_TableSampleClause = 925,
    T_WithCheckOption = 926,
    T_SortGroupClause = 927,
    T_GroupingSet = 928,
    T_WindowClause = 929,
    T_FuncWithArgs = 930,
    T_AccessPriv = 931,
    T_CreateOpClassItem = 932,
    T_TableLikeClause = 933,
    T_FunctionParameter = 934,
    T_LockingClause = 935,
    T_RowMarkClause = 936,
    T_XmlSerialize = 937,
    T_WithClause = 938,
    T_InferClause = 939,
    T_OnConflictClause = 940,
    T_CommonTableExpr = 941,
    T_RoleSpec = 942,
    T_IdentifySystemCmd = 943,
    T_BaseBackupCmd = 944,
    T_CreateReplicationSlotCmd = 945,
    T_DropReplicationSlotCmd = 946,
    T_StartReplicationCmd = 947,
    T_TimeLineHistoryCmd = 948,
    T_TriggerData = 950,
    T_EventTriggerData = 951,
    T_ReturnSetInfo = 952,
    T_WindowObjectData = 953,
    T_TIDBitmap = 954,
    T_InlineCodeBlock = 955,
    T_FdwRoutine = 956,
    T_IndexAmRoutine = 957,
    T_TsmRoutine = 958,
    T_ForeignKeyCacheInfo = 959,
}
extern "C" {
    pub fn nodeToString(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Bitmapset {
    pub nwords: ::std::os::raw::c_int,
    pub words: *mut bitmapword,
}
#[test]
fn bindgen_test_layout_Bitmapset() {
    assert_eq!(::std::mem::size_of::<Bitmapset>() , 4usize);
    assert_eq!(::std::mem::align_of::<Bitmapset>() , 4usize);
}
impl Clone for Bitmapset {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn outNode(str: *mut StringInfoData,
                   obj: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn outToken(str: *mut StringInfoData,
                    s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn outBitmapset(str: *mut StringInfoData, bms: *const Bitmapset);
}
extern "C" {
    pub fn outDatum(str: *mut StringInfoData, value: usize,
                    typlen: ::std::os::raw::c_int, typbyval: bool_);
}
extern "C" {
    pub fn stringToNode(str: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn readBitmapset() -> *mut Bitmapset;
}
extern "C" {
    pub fn readDatum(typbyval: bool_) -> usize;
}
extern "C" {
    pub fn readBoolCols(numCols: ::std::os::raw::c_int) -> *mut bool_;
}
extern "C" {
    pub fn readIntCols(numCols: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn readOidCols(numCols: ::std::os::raw::c_int) -> *mut Oid;
}
extern "C" {
    pub fn readAttrNumberCols(numCols: ::std::os::raw::c_int) -> *mut int16;
}
extern "C" {
    pub fn copyObject(obj: *const ::std::os::raw::c_void)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn equal(a: *const ::std::os::raw::c_void,
                 b: *const ::std::os::raw::c_void) -> bool_;
}
pub type Selectivity = f64;
pub type Cost = f64;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CmdType {
    CMD_UNKNOWN = 0,
    CMD_SELECT = 1,
    CMD_UPDATE = 2,
    CMD_INSERT = 3,
    CMD_DELETE = 4,
    CMD_UTILITY = 5,
    CMD_NOTHING = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum JoinType {
    JOIN_INNER = 0,
    JOIN_LEFT = 1,
    JOIN_FULL = 2,
    JOIN_RIGHT = 3,
    JOIN_SEMI = 4,
    JOIN_ANTI = 5,
    JOIN_UNIQUE_OUTER = 6,
    JOIN_UNIQUE_INNER = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AggStrategy { AGG_PLAIN = 0, AGG_SORTED = 1, AGG_HASHED = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AggSplit {
    AGGSPLIT_SIMPLE = 0,
    AGGSPLIT_INITIAL_SERIAL = 6,
    AGGSPLIT_FINAL_DESERIAL = 9,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetOpCmd {
    SETOPCMD_INTERSECT = 0,
    SETOPCMD_INTERSECT_ALL = 1,
    SETOPCMD_EXCEPT = 2,
    SETOPCMD_EXCEPT_ALL = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetOpStrategy { SETOP_SORTED = 0, SETOP_HASHED = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OnConflictAction {
    ONCONFLICT_NONE = 0,
    ONCONFLICT_NOTHING = 1,
    ONCONFLICT_UPDATE = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ListCell {
    pub data: ListCell__bindgen_ty_1,
    pub next: *mut ListCell,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ListCell__bindgen_ty_1 {
    pub ptr_value: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub int_value: __BindgenUnionField<::std::os::raw::c_int>,
    pub oid_value: __BindgenUnionField<Oid>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_ListCell__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ListCell__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<ListCell__bindgen_ty_1>() , 8usize);
}
impl Clone for ListCell__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ListCell() {
    assert_eq!(::std::mem::size_of::<ListCell>() , 16usize);
    assert_eq!(::std::mem::align_of::<ListCell>() , 8usize);
}
impl Clone for ListCell {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct List {
    pub type_: NodeTag,
    pub length: ::std::os::raw::c_int,
    pub head: *mut ListCell,
    pub tail: *mut ListCell,
}
#[test]
fn bindgen_test_layout_List() {
    assert_eq!(::std::mem::size_of::<List>() , 24usize);
    assert_eq!(::std::mem::align_of::<List>() , 8usize);
}
impl Clone for List {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn lappend(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn lappend_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
}
extern "C" {
    pub fn lappend_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    pub fn lappend_cell(list: *mut List, prev: *mut ListCell,
                        datum: *mut ::std::os::raw::c_void) -> *mut ListCell;
}
extern "C" {
    pub fn lappend_cell_int(list: *mut List, prev: *mut ListCell,
                            datum: ::std::os::raw::c_int) -> *mut ListCell;
}
extern "C" {
    pub fn lappend_cell_oid(list: *mut List, prev: *mut ListCell, datum: Oid)
     -> *mut ListCell;
}
extern "C" {
    pub fn lcons(datum: *mut ::std::os::raw::c_void, list: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn lcons_int(datum: ::std::os::raw::c_int, list: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn lcons_oid(datum: Oid, list: *mut List) -> *mut List;
}
extern "C" {
    pub fn list_concat(list1: *mut List, list2: *mut List) -> *mut List;
}
extern "C" {
    pub fn list_truncate(list: *mut List, new_size: ::std::os::raw::c_int)
     -> *mut List;
}
extern "C" {
    pub fn list_nth_cell(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ListCell;
}
extern "C" {
    pub fn list_nth(list: *const List, n: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn list_nth_int(list: *const List, n: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn list_nth_oid(list: *const List, n: ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn list_member(list: *const List,
                       datum: *const ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn list_member_ptr(list: *const List,
                           datum: *const ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn list_member_int(list: *const List, datum: ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn list_member_oid(list: *const List, datum: Oid) -> bool_;
}
extern "C" {
    pub fn list_delete(list: *mut List, datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn list_delete_ptr(list: *mut List,
                           datum: *mut ::std::os::raw::c_void) -> *mut List;
}
extern "C" {
    pub fn list_delete_int(list: *mut List, datum: ::std::os::raw::c_int)
     -> *mut List;
}
extern "C" {
    pub fn list_delete_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    pub fn list_delete_first(list: *mut List) -> *mut List;
}
extern "C" {
    pub fn list_delete_cell(list: *mut List, cell: *mut ListCell,
                            prev: *mut ListCell) -> *mut List;
}
extern "C" {
    pub fn list_union(list1: *const List, list2: *const List) -> *mut List;
}
extern "C" {
    pub fn list_union_ptr(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_union_int(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_union_oid(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_intersection(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_intersection_int(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference_ptr(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference_int(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_difference_oid(list1: *const List, list2: *const List)
     -> *mut List;
}
extern "C" {
    pub fn list_append_unique(list: *mut List,
                              datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn list_append_unique_ptr(list: *mut List,
                                  datum: *mut ::std::os::raw::c_void)
     -> *mut List;
}
extern "C" {
    pub fn list_append_unique_int(list: *mut List,
                                  datum: ::std::os::raw::c_int) -> *mut List;
}
extern "C" {
    pub fn list_append_unique_oid(list: *mut List, datum: Oid) -> *mut List;
}
extern "C" {
    pub fn list_concat_unique(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_concat_unique_ptr(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_concat_unique_int(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_concat_unique_oid(list1: *mut List, list2: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn list_free(list: *mut List);
}
extern "C" {
    pub fn list_free_deep(list: *mut List);
}
extern "C" {
    pub fn list_copy(list: *const List) -> *mut List;
}
extern "C" {
    pub fn list_copy_tail(list: *const List, nskip: ::std::os::raw::c_int)
     -> *mut List;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct attrDefault {
    pub adnum: AttrNumber,
    pub adbin: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_attrDefault() {
    assert_eq!(::std::mem::size_of::<attrDefault>() , 16usize);
    assert_eq!(::std::mem::align_of::<attrDefault>() , 8usize);
}
impl Clone for attrDefault {
    fn clone(&self) -> Self { *self }
}
pub type AttrDefault = attrDefault;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct constrCheck {
    pub ccname: *mut ::std::os::raw::c_char,
    pub ccbin: *mut ::std::os::raw::c_char,
    pub ccvalid: bool_,
    pub ccnoinherit: bool_,
}
#[test]
fn bindgen_test_layout_constrCheck() {
    assert_eq!(::std::mem::size_of::<constrCheck>() , 24usize);
    assert_eq!(::std::mem::align_of::<constrCheck>() , 8usize);
}
impl Clone for constrCheck {
    fn clone(&self) -> Self { *self }
}
pub type ConstrCheck = constrCheck;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tupleConstr {
    pub defval: *mut AttrDefault,
    pub check: *mut ConstrCheck,
    pub num_defval: uint16,
    pub num_check: uint16,
    pub has_not_null: bool_,
}
#[test]
fn bindgen_test_layout_tupleConstr() {
    assert_eq!(::std::mem::size_of::<tupleConstr>() , 24usize);
    assert_eq!(::std::mem::align_of::<tupleConstr>() , 8usize);
}
impl Clone for tupleConstr {
    fn clone(&self) -> Self { *self }
}
pub type TupleConstr = tupleConstr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tupleDesc {
    pub natts: ::std::os::raw::c_int,
    pub attrs: *mut Form_pg_attribute,
    pub constr: *mut TupleConstr,
    pub tdtypeid: Oid,
    pub tdtypmod: int32,
    pub tdhasoid: bool_,
    pub tdrefcount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tupleDesc() {
    assert_eq!(::std::mem::size_of::<tupleDesc>() , 40usize);
    assert_eq!(::std::mem::align_of::<tupleDesc>() , 8usize);
}
impl Clone for tupleDesc {
    fn clone(&self) -> Self { *self }
}
pub type TupleDesc = *mut tupleDesc;
extern "C" {
    pub fn CreateTemplateTupleDesc(natts: ::std::os::raw::c_int,
                                   hasoid: bool_) -> TupleDesc;
}
extern "C" {
    pub fn CreateTupleDesc(natts: ::std::os::raw::c_int, hasoid: bool_,
                           attrs: *mut Form_pg_attribute) -> TupleDesc;
}
extern "C" {
    pub fn CreateTupleDescCopy(tupdesc: TupleDesc) -> TupleDesc;
}
extern "C" {
    pub fn CreateTupleDescCopyConstr(tupdesc: TupleDesc) -> TupleDesc;
}
extern "C" {
    pub fn TupleDescCopyEntry(dst: TupleDesc, dstAttno: AttrNumber,
                              src: TupleDesc, srcAttno: AttrNumber);
}
extern "C" {
    pub fn FreeTupleDesc(tupdesc: TupleDesc);
}
extern "C" {
    pub fn IncrTupleDescRefCount(tupdesc: TupleDesc);
}
extern "C" {
    pub fn DecrTupleDescRefCount(tupdesc: TupleDesc);
}
extern "C" {
    pub fn equalTupleDescs(tupdesc1: TupleDesc, tupdesc2: TupleDesc) -> bool_;
}
extern "C" {
    pub fn TupleDescInitEntry(desc: TupleDesc, attributeNumber: AttrNumber,
                              attributeName: *const ::std::os::raw::c_char,
                              oidtypeid: Oid, typmod: int32,
                              attdim: ::std::os::raw::c_int);
}
extern "C" {
    pub fn TupleDescInitEntryCollation(desc: TupleDesc,
                                       attributeNumber: AttrNumber,
                                       collationid: Oid);
}
extern "C" {
    pub fn BuildDescForRelation(schema: *mut List) -> TupleDesc;
}
extern "C" {
    pub fn BuildDescFromLists(names: *mut List, types: *mut List,
                              typmods: *mut List, collations: *mut List)
     -> TupleDesc;
}
pub type bitmapword = uint32;
pub type signedbitmapword = int32;
pub const BMS_EQUAL: _bindgen_ty_38 = _bindgen_ty_38::BMS_EQUAL;
pub const BMS_SUBSET1: _bindgen_ty_38 = _bindgen_ty_38::BMS_SUBSET1;
pub const BMS_SUBSET2: _bindgen_ty_38 = _bindgen_ty_38::BMS_SUBSET2;
pub const BMS_DIFFERENT: _bindgen_ty_38 = _bindgen_ty_38::BMS_DIFFERENT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_38 {
    BMS_EQUAL = 0,
    BMS_SUBSET1 = 1,
    BMS_SUBSET2 = 2,
    BMS_DIFFERENT = 3,
}
pub use self::_bindgen_ty_38 as BMS_Comparison;
pub const BMS_EMPTY_SET: _bindgen_ty_39 = _bindgen_ty_39::BMS_EMPTY_SET;
pub const BMS_SINGLETON: _bindgen_ty_39 = _bindgen_ty_39::BMS_SINGLETON;
pub const BMS_MULTIPLE: _bindgen_ty_39 = _bindgen_ty_39::BMS_MULTIPLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_39 {
    BMS_EMPTY_SET = 0,
    BMS_SINGLETON = 1,
    BMS_MULTIPLE = 2,
}
pub use self::_bindgen_ty_39 as BMS_Membership;
extern "C" {
    pub fn bms_copy(a: *const Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_equal(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_make_singleton(x: ::std::os::raw::c_int) -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_free(a: *mut Bitmapset);
}
extern "C" {
    pub fn bms_union(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_intersect(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_is_subset(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_subset_compare(a: *const Bitmapset, b: *const Bitmapset)
     -> BMS_Comparison;
}
extern "C" {
    pub fn bms_is_member(x: ::std::os::raw::c_int, a: *const Bitmapset)
     -> bool_;
}
extern "C" {
    pub fn bms_overlap(a: *const Bitmapset, b: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_nonempty_difference(a: *const Bitmapset, b: *const Bitmapset)
     -> bool_;
}
extern "C" {
    pub fn bms_singleton_member(a: *const Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_get_singleton_member(a: *const Bitmapset,
                                    member: *mut ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn bms_num_members(a: *const Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_membership(a: *const Bitmapset) -> BMS_Membership;
}
extern "C" {
    pub fn bms_is_empty(a: *const Bitmapset) -> bool_;
}
extern "C" {
    pub fn bms_add_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_del_member(a: *mut Bitmapset, x: ::std::os::raw::c_int)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_add_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_int_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_del_members(a: *mut Bitmapset, b: *const Bitmapset)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_join(a: *mut Bitmapset, b: *mut Bitmapset) -> *mut Bitmapset;
}
extern "C" {
    pub fn bms_first_member(a: *mut Bitmapset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_next_member(a: *const Bitmapset,
                           prevbit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bms_hash_value(a: *const Bitmapset) -> uint32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RelationData {
    pub rd_node: RelFileNode,
    pub rd_smgr: *mut RelationData_SMgrRelationData,
    pub rd_refcnt: ::std::os::raw::c_int,
    pub rd_backend: BackendId,
    pub rd_islocaltemp: bool_,
    pub rd_isnailed: bool_,
    pub rd_isvalid: bool_,
    pub rd_indexvalid: ::std::os::raw::c_char,
    pub rd_createSubid: SubTransactionId,
    pub rd_newRelfilenodeSubid: SubTransactionId,
    pub rd_rel: Form_pg_class,
    pub rd_att: TupleDesc,
    pub rd_id: Oid,
    pub rd_lockInfo: LockInfoData,
    pub rd_rules: *mut RuleLock,
    pub rd_rulescxt: MemoryContext,
    pub trigdesc: *mut TriggerDesc,
    pub rd_rsdesc: *mut RelationData_RowSecurityDesc,
    pub rd_fkeylist: *mut List,
    pub rd_fkeyvalid: bool_,
    pub rd_indexlist: *mut List,
    pub rd_oidindex: Oid,
    pub rd_replidindex: Oid,
    pub rd_indexattr: *mut Bitmapset,
    pub rd_keyattr: *mut Bitmapset,
    pub rd_idattr: *mut Bitmapset,
    pub rd_options: *mut bytea,
    pub rd_index: Form_pg_index,
    pub rd_indextuple: *mut HeapTupleData,
    pub rd_amhandler: Oid,
    pub rd_indexcxt: MemoryContext,
    pub rd_amroutine: *mut IndexAmRoutine,
    pub rd_opfamily: *mut Oid,
    pub rd_opcintype: *mut Oid,
    pub rd_support: *mut RegProcedure,
    pub rd_supportinfo: *mut FmgrInfo,
    pub rd_indoption: *mut int16,
    pub rd_indexprs: *mut List,
    pub rd_indpred: *mut List,
    pub rd_exclops: *mut Oid,
    pub rd_exclprocs: *mut Oid,
    pub rd_exclstrats: *mut uint16,
    pub rd_amcache: *mut ::std::os::raw::c_void,
    pub rd_indcollation: *mut Oid,
    pub rd_fdwroutine: *mut ResultRelInfo_FdwRoutine,
    pub rd_toastoid: Oid,
    pub pgstat_info: *mut RelationData_PgStat_TableStatus,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelationData_SMgrRelationData([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelationData_RowSecurityDesc([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RelationData_PgStat_TableStatus([u8; 0]);
#[test]
fn bindgen_test_layout_RelationData() {
    assert_eq!(::std::mem::size_of::<RelationData>() , 336usize);
    assert_eq!(::std::mem::align_of::<RelationData>() , 8usize);
}
impl Clone for RelationData {
    fn clone(&self) -> Self { *self }
}
pub type Relation = *mut RelationData;
pub type RelationPtr = *mut Relation;
extern "C" {
    pub fn RelationIdGetRelation(relationId: Oid) -> Relation;
}
extern "C" {
    pub fn RelationClose(relation: Relation);
}
extern "C" {
    pub fn RelationGetFKeyList(relation: Relation) -> *mut List;
}
extern "C" {
    pub fn RelationGetIndexList(relation: Relation) -> *mut List;
}
extern "C" {
    pub fn RelationGetOidIndex(relation: Relation) -> Oid;
}
extern "C" {
    pub fn RelationGetReplicaIndex(relation: Relation) -> Oid;
}
extern "C" {
    pub fn RelationGetIndexExpressions(relation: Relation) -> *mut List;
}
extern "C" {
    pub fn RelationGetIndexPredicate(relation: Relation) -> *mut List;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IndexAttrBitmapKind {
    INDEX_ATTR_BITMAP_ALL = 0,
    INDEX_ATTR_BITMAP_KEY = 1,
    INDEX_ATTR_BITMAP_IDENTITY_KEY = 2,
}
extern "C" {
    pub fn RelationGetIndexAttrBitmap(relation: Relation,
                                      keyAttrs: IndexAttrBitmapKind)
     -> *mut Bitmapset;
}
extern "C" {
    pub fn RelationGetExclusionInfo(indexRelation: Relation,
                                    operators: *mut *mut Oid,
                                    procs: *mut *mut Oid,
                                    strategies: *mut *mut uint16);
}
extern "C" {
    pub fn RelationSetIndexList(relation: Relation, indexIds: *mut List,
                                oidIndex: Oid);
}
extern "C" {
    pub fn RelationInitIndexAccessInfo(relation: Relation);
}
extern "C" {
    pub fn errtable(rel: Relation) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errtablecol(rel: Relation, attnum: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errtablecolname(rel: Relation,
                           colname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errtableconstraint(rel: Relation,
                              conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RelationCacheInitialize();
}
extern "C" {
    pub fn RelationCacheInitializePhase2();
}
extern "C" {
    pub fn RelationCacheInitializePhase3();
}
extern "C" {
    pub fn RelationBuildLocalRelation(relname: *const ::std::os::raw::c_char,
                                      relnamespace: Oid, tupDesc: TupleDesc,
                                      relid: Oid, relfilenode: Oid,
                                      reltablespace: Oid,
                                      shared_relation: bool_,
                                      mapped_relation: bool_,
                                      relpersistence: ::std::os::raw::c_char,
                                      relkind: ::std::os::raw::c_char)
     -> Relation;
}
extern "C" {
    pub fn RelationSetNewRelfilenode(relation: Relation,
                                     persistence: ::std::os::raw::c_char,
                                     freezeXid: TransactionId,
                                     minmulti: MultiXactId);
}
extern "C" {
    pub fn RelationForgetRelation(rid: Oid);
}
extern "C" {
    pub fn RelationCacheInvalidateEntry(relationId: Oid);
}
extern "C" {
    pub fn RelationCacheInvalidate();
}
extern "C" {
    pub fn RelationCloseSmgrByOid(relationId: Oid);
}
extern "C" {
    pub fn AtEOXact_RelationCache(isCommit: bool_);
}
extern "C" {
    pub fn AtEOSubXact_RelationCache(isCommit: bool_,
                                     mySubid: SubTransactionId,
                                     parentSubid: SubTransactionId);
}
extern "C" {
    pub fn RelationIdIsInInitFile(relationId: Oid) -> bool_;
}
extern "C" {
    pub fn RelationCacheInitFilePreInvalidate();
}
extern "C" {
    pub fn RelationCacheInitFilePostInvalidate();
}
extern "C" {
    pub fn RelationCacheInitFileRemove();
}
extern "C" {
    #[link_name = "criticalRelcachesBuilt"]
    pub static mut criticalRelcachesBuilt: bool_;
}
extern "C" {
    #[link_name = "criticalSharedRelcachesBuilt"]
    pub static mut criticalSharedRelcachesBuilt: bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapTupleHeaderData([u8; 0]);
pub type HeapTupleHeader = *mut HeapTupleHeaderData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinimalTupleData([u8; 0]);
pub type MinimalTuple = *mut MinimalTupleData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HeapTupleData {
    pub t_len: uint32,
    pub t_self: ItemPointerData,
    pub t_tableOid: Oid,
    pub t_data: HeapTupleHeader,
}
#[test]
fn bindgen_test_layout_HeapTupleData() {
    assert_eq!(::std::mem::size_of::<HeapTupleData>() , 24usize);
    assert_eq!(::std::mem::align_of::<HeapTupleData>() , 8usize);
}
impl Clone for HeapTupleData {
    fn clone(&self) -> Self { *self }
}
pub type HeapTuple = *mut HeapTupleData;
extern "C" {
    pub fn HeapTupleHeaderGetCmin(tup: HeapTupleHeader) -> CommandId;
}
extern "C" {
    pub fn HeapTupleHeaderGetCmax(tup: HeapTupleHeader) -> CommandId;
}
extern "C" {
    pub fn HeapTupleHeaderAdjustCmax(tup: HeapTupleHeader,
                                     cmax: *mut CommandId,
                                     iscombo: *mut bool_);
}
extern "C" {
    pub fn HeapTupleGetUpdateXid(tuple: HeapTupleHeader) -> TransactionId;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct flock {
    pub l_type: ::std::os::raw::c_short,
    pub l_whence: ::std::os::raw::c_short,
    pub l_start: __off_t,
    pub l_len: __off_t,
    pub l_pid: __pid_t,
}
#[test]
fn bindgen_test_layout_flock() {
    assert_eq!(::std::mem::size_of::<flock>() , 32usize);
    assert_eq!(::std::mem::align_of::<flock>() , 8usize);
}
impl Clone for flock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: ::std::os::raw::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3usize],
}
#[test]
fn bindgen_test_layout_stat() {
    assert_eq!(::std::mem::size_of::<stat>() , 144usize);
    assert_eq!(::std::mem::align_of::<stat>() , 8usize);
}
impl Clone for stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn fcntl(__fd: ::std::os::raw::c_int,
                 __cmd: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn open(__file: *const ::std::os::raw::c_char,
                __oflag: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn openat(__fd: ::std::os::raw::c_int,
                  __file: *const ::std::os::raw::c_char,
                  __oflag: ::std::os::raw::c_int, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn creat(__file: *const ::std::os::raw::c_char, __mode: mode_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lockf(__fd: ::std::os::raw::c_int, __cmd: ::std::os::raw::c_int,
                 __len: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fadvise(__fd: ::std::os::raw::c_int, __offset: off_t,
                         __len: off_t, __advise: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn posix_fallocate(__fd: ::std::os::raw::c_int, __offset: off_t,
                           __len: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __open_2(__path: *const ::std::os::raw::c_char,
                    __oflag: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __open_too_many_args();
}
extern "C" {
    pub fn __open_missing_mode();
}
extern "C" {
    pub fn __openat_2(__fd: ::std::os::raw::c_int,
                      __path: *const ::std::os::raw::c_char,
                      __oflag: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __openat_too_many_args();
}
extern "C" {
    pub fn __openat_missing_mode();
}
pub type XLogRecPtr = uint64;
pub type XLogSegNo = uint64;
pub type TimeLineID = uint32;
pub type RepOriginId = uint16;
pub type StringInfo = *mut StringInfoData;
extern "C" {
    pub fn makeStringInfo() -> StringInfo;
}
extern "C" {
    pub fn initStringInfo(str: StringInfo);
}
extern "C" {
    pub fn resetStringInfo(str: StringInfo);
}
extern "C" {
    pub fn appendStringInfo(str: StringInfo,
                            fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn appendStringInfoVA(str: StringInfo,
                              fmt: *const ::std::os::raw::c_char,
                              args: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn appendStringInfoString(str: StringInfo,
                                  s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn appendStringInfoChar(str: StringInfo, ch: ::std::os::raw::c_char);
}
extern "C" {
    pub fn appendStringInfoSpaces(str: StringInfo,
                                  count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn appendBinaryStringInfo(str: StringInfo,
                                  data: *const ::std::os::raw::c_char,
                                  datalen: ::std::os::raw::c_int);
}
extern "C" {
    pub fn enlargeStringInfo(str: StringInfo, needed: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pairingheap_node {
    pub first_child: *mut pairingheap_node,
    pub next_sibling: *mut pairingheap_node,
    pub prev_or_parent: *mut pairingheap_node,
}
#[test]
fn bindgen_test_layout_pairingheap_node() {
    assert_eq!(::std::mem::size_of::<pairingheap_node>() , 24usize);
    assert_eq!(::std::mem::align_of::<pairingheap_node>() , 8usize);
}
impl Clone for pairingheap_node {
    fn clone(&self) -> Self { *self }
}
pub type pairingheap_comparator =
    ::std::option::Option<unsafe extern "C" fn(a: *const pairingheap_node,
                                               b: *const pairingheap_node,
                                               arg:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pairingheap {
    pub ph_compare: pairingheap_comparator,
    pub ph_arg: *mut ::std::os::raw::c_void,
    pub ph_root: *mut pairingheap_node,
}
#[test]
fn bindgen_test_layout_pairingheap() {
    assert_eq!(::std::mem::size_of::<pairingheap>() , 24usize);
    assert_eq!(::std::mem::align_of::<pairingheap>() , 8usize);
}
impl Clone for pairingheap {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn pairingheap_allocate(compare: pairingheap_comparator,
                                arg: *mut ::std::os::raw::c_void)
     -> *mut pairingheap;
}
extern "C" {
    pub fn pairingheap_free(heap: *mut pairingheap);
}
extern "C" {
    pub fn pairingheap_add(heap: *mut pairingheap,
                           node: *mut pairingheap_node);
}
extern "C" {
    pub fn pairingheap_first(heap: *mut pairingheap) -> *mut pairingheap_node;
}
extern "C" {
    pub fn pairingheap_remove_first(heap: *mut pairingheap)
     -> *mut pairingheap_node;
}
extern "C" {
    pub fn pairingheap_remove(heap: *mut pairingheap,
                              node: *mut pairingheap_node);
}
pub type Buffer = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferAccessStrategyData([u8; 0]);
pub type BufferAccessStrategy = *mut BufferAccessStrategyData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SnapshotData {
    pub satisfies: SnapshotSatisfiesFunc,
    pub xmin: TransactionId,
    pub xmax: TransactionId,
    pub xip: *mut TransactionId,
    pub xcnt: uint32,
    pub subxip: *mut TransactionId,
    pub subxcnt: int32,
    pub suboverflowed: bool_,
    pub takenDuringRecovery: bool_,
    pub copied: bool_,
    pub curcid: CommandId,
    pub speculativeToken: uint32,
    pub active_count: uint32,
    pub regd_count: uint32,
    pub ph_node: pairingheap_node,
    pub whenTaken: int64,
    pub lsn: XLogRecPtr,
}
#[test]
fn bindgen_test_layout_SnapshotData() {
    assert_eq!(::std::mem::size_of::<SnapshotData>() , 104usize);
    assert_eq!(::std::mem::align_of::<SnapshotData>() , 8usize);
}
impl Clone for SnapshotData {
    fn clone(&self) -> Self { *self }
}
pub type Snapshot = *mut SnapshotData;
pub type SnapshotSatisfiesFunc =
    ::std::option::Option<unsafe extern "C" fn(htup: HeapTuple,
                                               snapshot: Snapshot,
                                               buffer: Buffer)
                              -> ::std::os::raw::c_char>;
pub const HeapTupleMayBeUpdated: _bindgen_ty_40 =
    _bindgen_ty_40::HeapTupleMayBeUpdated;
pub const HeapTupleInvisible: _bindgen_ty_40 =
    _bindgen_ty_40::HeapTupleInvisible;
pub const HeapTupleSelfUpdated: _bindgen_ty_40 =
    _bindgen_ty_40::HeapTupleSelfUpdated;
pub const HeapTupleUpdated: _bindgen_ty_40 = _bindgen_ty_40::HeapTupleUpdated;
pub const HeapTupleBeingUpdated: _bindgen_ty_40 =
    _bindgen_ty_40::HeapTupleBeingUpdated;
pub const HeapTupleWouldBlock: _bindgen_ty_40 =
    _bindgen_ty_40::HeapTupleWouldBlock;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_40 {
    HeapTupleMayBeUpdated = 0,
    HeapTupleInvisible = 1,
    HeapTupleSelfUpdated = 2,
    HeapTupleUpdated = 3,
    HeapTupleBeingUpdated = 4,
    HeapTupleWouldBlock = 5,
}
pub use self::_bindgen_ty_40 as HTSU_Result;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexBuildResult {
    pub heap_tuples: f64,
    pub index_tuples: f64,
}
#[test]
fn bindgen_test_layout_IndexBuildResult() {
    assert_eq!(::std::mem::size_of::<IndexBuildResult>() , 16usize);
    assert_eq!(::std::mem::align_of::<IndexBuildResult>() , 8usize);
}
impl Clone for IndexBuildResult {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexVacuumInfo {
    pub index: Relation,
    pub analyze_only: bool_,
    pub estimated_count: bool_,
    pub message_level: ::std::os::raw::c_int,
    pub num_heap_tuples: f64,
    pub strategy: BufferAccessStrategy,
}
#[test]
fn bindgen_test_layout_IndexVacuumInfo() {
    assert_eq!(::std::mem::size_of::<IndexVacuumInfo>() , 32usize);
    assert_eq!(::std::mem::align_of::<IndexVacuumInfo>() , 8usize);
}
impl Clone for IndexVacuumInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexBulkDeleteResult {
    pub num_pages: BlockNumber,
    pub pages_removed: BlockNumber,
    pub estimated_count: bool_,
    pub num_index_tuples: f64,
    pub tuples_removed: f64,
    pub pages_deleted: BlockNumber,
    pub pages_free: BlockNumber,
}
#[test]
fn bindgen_test_layout_IndexBulkDeleteResult() {
    assert_eq!(::std::mem::size_of::<IndexBulkDeleteResult>() , 40usize);
    assert_eq!(::std::mem::align_of::<IndexBulkDeleteResult>() , 8usize);
}
impl Clone for IndexBulkDeleteResult {
    fn clone(&self) -> Self { *self }
}
pub type IndexBulkDeleteCallback =
    ::std::option::Option<unsafe extern "C" fn(itemptr: ItemPointer,
                                               state:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_char>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IndexScanDescData([u8; 0]);
pub type IndexScanDesc = *mut IndexScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysScanDescData([u8; 0]);
pub type SysScanDesc = *mut SysScanDescData;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IndexUniqueCheck {
    UNIQUE_CHECK_NO = 0,
    UNIQUE_CHECK_YES = 1,
    UNIQUE_CHECK_PARTIAL = 2,
    UNIQUE_CHECK_EXISTING = 3,
}
extern "C" {
    pub fn index_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn index_close(relation: Relation, lockmode: LOCKMODE);
}
extern "C" {
    pub fn index_insert(indexRelation: Relation, values: *mut Datum,
                        isnull: *mut bool_, heap_t_ctid: ItemPointer,
                        heapRelation: Relation, checkUnique: IndexUniqueCheck)
     -> bool_;
}
extern "C" {
    pub fn index_beginscan(heapRelation: Relation, indexRelation: Relation,
                           snapshot: Snapshot, nkeys: ::std::os::raw::c_int,
                           norderbys: ::std::os::raw::c_int) -> IndexScanDesc;
}
extern "C" {
    pub fn index_beginscan_bitmap(indexRelation: Relation, snapshot: Snapshot,
                                  nkeys: ::std::os::raw::c_int)
     -> IndexScanDesc;
}
extern "C" {
    pub fn index_rescan(scan: IndexScanDesc, keys: ScanKey,
                        nkeys: ::std::os::raw::c_int, orderbys: ScanKey,
                        norderbys: ::std::os::raw::c_int);
}
extern "C" {
    pub fn index_endscan(scan: IndexScanDesc);
}
extern "C" {
    pub fn index_markpos(scan: IndexScanDesc);
}
extern "C" {
    pub fn index_restrpos(scan: IndexScanDesc);
}
extern "C" {
    pub fn index_getnext_tid(scan: IndexScanDesc, direction: ScanDirection)
     -> ItemPointer;
}
extern "C" {
    pub fn index_fetch_heap(scan: IndexScanDesc) -> HeapTuple;
}
extern "C" {
    pub fn index_getnext(scan: IndexScanDesc, direction: ScanDirection)
     -> HeapTuple;
}
extern "C" {
    pub fn index_getbitmap(scan: IndexScanDesc, bitmap: *mut TIDBitmap)
     -> int64;
}
extern "C" {
    pub fn index_bulk_delete(info: *mut IndexVacuumInfo,
                             stats: *mut IndexBulkDeleteResult,
                             callback: IndexBulkDeleteCallback,
                             callback_state: *mut ::std::os::raw::c_void)
     -> *mut IndexBulkDeleteResult;
}
extern "C" {
    pub fn index_vacuum_cleanup(info: *mut IndexVacuumInfo,
                                stats: *mut IndexBulkDeleteResult)
     -> *mut IndexBulkDeleteResult;
}
extern "C" {
    pub fn index_can_return(indexRelation: Relation,
                            attno: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn index_getprocid(irel: Relation, attnum: AttrNumber,
                           procnum: uint16) -> RegProcedure;
}
extern "C" {
    pub fn index_getprocinfo(irel: Relation, attnum: AttrNumber,
                             procnum: uint16) -> *mut FmgrInfo;
}
extern "C" {
    pub fn RelationGetIndexScan(indexRelation: Relation,
                                nkeys: ::std::os::raw::c_int,
                                norderbys: ::std::os::raw::c_int)
     -> IndexScanDesc;
}
extern "C" {
    pub fn IndexScanEnd(scan: IndexScanDesc);
}
extern "C" {
    pub fn BuildIndexValueDescription(indexRelation: Relation,
                                      values: *mut Datum, isnull: *mut bool_)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn systable_beginscan(heapRelation: Relation, indexId: Oid,
                              indexOK: bool_, snapshot: Snapshot,
                              nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> SysScanDesc;
}
extern "C" {
    pub fn systable_getnext(sysscan: SysScanDesc) -> HeapTuple;
}
extern "C" {
    pub fn systable_recheck_tuple(sysscan: SysScanDesc, tup: HeapTuple)
     -> bool_;
}
extern "C" {
    pub fn systable_endscan(sysscan: SysScanDesc);
}
extern "C" {
    pub fn systable_beginscan_ordered(heapRelation: Relation,
                                      indexRelation: Relation,
                                      snapshot: Snapshot,
                                      nkeys: ::std::os::raw::c_int,
                                      key: ScanKey) -> SysScanDesc;
}
extern "C" {
    pub fn systable_getnext_ordered(sysscan: SysScanDesc,
                                    direction: ScanDirection) -> HeapTuple;
}
extern "C" {
    pub fn systable_endscan_ordered(sysscan: SysScanDesc);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlannerInfo {
    pub type_: NodeTag,
    pub parse: *mut Query,
    pub glob: *mut PlannerGlobal,
    pub query_level: Index,
    pub parent_root: *mut PlannerInfo,
    pub plan_params: *mut List,
    pub outer_params: *mut Bitmapset,
    pub simple_rel_array: *mut *mut PlannerInfo_RelOptInfo,
    pub simple_rel_array_size: ::std::os::raw::c_int,
    pub simple_rte_array: *mut *mut RangeTblEntry,
    pub all_baserels: Relids,
    pub nullable_baserels: Relids,
    pub join_rel_list: *mut List,
    pub join_rel_hash: *mut HTAB,
    pub join_rel_level: *mut *mut List,
    pub join_cur_level: ::std::os::raw::c_int,
    pub init_plans: *mut List,
    pub cte_plan_ids: *mut List,
    pub multiexpr_params: *mut List,
    pub eq_classes: *mut List,
    pub canon_pathkeys: *mut List,
    pub left_join_clauses: *mut List,
    pub right_join_clauses: *mut List,
    pub full_join_clauses: *mut List,
    pub join_info_list: *mut List,
    pub append_rel_list: *mut List,
    pub rowMarks: *mut List,
    pub placeholder_list: *mut List,
    pub fkey_list: *mut List,
    pub query_pathkeys: *mut List,
    pub group_pathkeys: *mut List,
    pub window_pathkeys: *mut List,
    pub distinct_pathkeys: *mut List,
    pub sort_pathkeys: *mut List,
    pub initial_rels: *mut List,
    pub upper_rels: [*mut List; 6usize],
    pub upper_targets: [*mut PlannerInfo_PathTarget; 6usize],
    pub processed_tlist: *mut List,
    pub grouping_map: *mut AttrNumber,
    pub minmax_aggs: *mut List,
    pub planner_cxt: MemoryContext,
    pub total_table_pages: f64,
    pub tuple_fraction: f64,
    pub limit_tuples: f64,
    pub hasInheritedTarget: bool_,
    pub hasJoinRTEs: bool_,
    pub hasLateralRTEs: bool_,
    pub hasDeletedRTEs: bool_,
    pub hasHavingQual: bool_,
    pub hasPseudoConstantQuals: bool_,
    pub hasRecursion: bool_,
    pub wt_param_id: ::std::os::raw::c_int,
    pub non_recursive_path: *mut Path,
    pub curOuterRels: Relids,
    pub curOuterParams: *mut List,
    pub join_search_private: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlannerInfo_RelOptInfo {
    pub type_: NodeTag,
    pub reloptkind: RelOptKind,
    pub relids: Relids,
    pub rows: f64,
    pub consider_startup: bool_,
    pub consider_param_startup: bool_,
    pub consider_parallel: bool_,
    pub reltarget: *mut PlannerInfo_PathTarget,
    pub pathlist: *mut List,
    pub ppilist: *mut List,
    pub partial_pathlist: *mut List,
    pub cheapest_startup_path: *mut Path,
    pub cheapest_total_path: *mut Path,
    pub cheapest_unique_path: *mut Path,
    pub cheapest_parameterized_paths: *mut List,
    pub direct_lateral_relids: Relids,
    pub lateral_relids: Relids,
    pub relid: Index,
    pub reltablespace: Oid,
    pub rtekind: RTEKind,
    pub min_attr: AttrNumber,
    pub max_attr: AttrNumber,
    pub attr_needed: *mut Relids,
    pub attr_widths: *mut int32,
    pub lateral_vars: *mut List,
    pub lateral_referencers: Relids,
    pub indexlist: *mut List,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub allvisfrac: f64,
    pub subroot: *mut PlannerInfo,
    pub subplan_params: *mut List,
    pub rel_parallel_workers: ::std::os::raw::c_int,
    pub serverid: Oid,
    pub userid: Oid,
    pub useridiscurrent: bool_,
    pub fdwroutine: *mut ResultRelInfo_FdwRoutine,
    pub fdw_private: *mut ::std::os::raw::c_void,
    pub baserestrictinfo: *mut List,
    pub baserestrictcost: QualCost,
    pub joininfo: *mut List,
    pub has_eclass_joins: bool_,
}
#[test]
fn bindgen_test_layout_PlannerInfo_RelOptInfo() {
    assert_eq!(::std::mem::size_of::<PlannerInfo_RelOptInfo>() , 280usize);
    assert_eq!(::std::mem::align_of::<PlannerInfo_RelOptInfo>() , 8usize);
}
impl Clone for PlannerInfo_RelOptInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlannerInfo_PathTarget {
    pub type_: NodeTag,
    pub exprs: *mut List,
    pub sortgrouprefs: *mut Index,
    pub cost: QualCost,
    pub width: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PlannerInfo_PathTarget() {
    assert_eq!(::std::mem::size_of::<PlannerInfo_PathTarget>() , 48usize);
    assert_eq!(::std::mem::align_of::<PlannerInfo_PathTarget>() , 8usize);
}
impl Clone for PlannerInfo_PathTarget {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PlannerInfo() {
    assert_eq!(::std::mem::size_of::<PlannerInfo>() , 480usize);
    assert_eq!(::std::mem::align_of::<PlannerInfo>() , 8usize);
}
impl Clone for PlannerInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexPath {
    pub path: Path,
    pub indexinfo: *mut IndexOptInfo,
    pub indexclauses: *mut List,
    pub indexquals: *mut List,
    pub indexqualcols: *mut List,
    pub indexorderbys: *mut List,
    pub indexorderbycols: *mut List,
    pub indexscandir: ScanDirection,
    pub indextotalcost: Cost,
    pub indexselectivity: Selectivity,
}
#[test]
fn bindgen_test_layout_IndexPath() {
    assert_eq!(::std::mem::size_of::<IndexPath>() , 144usize);
    assert_eq!(::std::mem::align_of::<IndexPath>() , 8usize);
}
impl Clone for IndexPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexInfo {
    pub type_: NodeTag,
    pub ii_NumIndexAttrs: ::std::os::raw::c_int,
    pub ii_KeyAttrNumbers: [AttrNumber; 32usize],
    pub ii_Expressions: *mut List,
    pub ii_ExpressionsState: *mut List,
    pub ii_Predicate: *mut List,
    pub ii_PredicateState: *mut List,
    pub ii_ExclusionOps: *mut Oid,
    pub ii_ExclusionProcs: *mut Oid,
    pub ii_ExclusionStrats: *mut uint16,
    pub ii_UniqueOps: *mut Oid,
    pub ii_UniqueProcs: *mut Oid,
    pub ii_UniqueStrats: *mut uint16,
    pub ii_Unique: bool_,
    pub ii_ReadyForInserts: bool_,
    pub ii_Concurrent: bool_,
    pub ii_BrokenHotChain: bool_,
}
#[test]
fn bindgen_test_layout_IndexInfo() {
    assert_eq!(::std::mem::size_of::<IndexInfo>() , 160usize);
    assert_eq!(::std::mem::align_of::<IndexInfo>() , 8usize);
}
impl Clone for IndexInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IndexAMProperty {
    AMPROP_UNKNOWN = 0,
    AMPROP_ASC = 1,
    AMPROP_DESC = 2,
    AMPROP_NULLS_FIRST = 3,
    AMPROP_NULLS_LAST = 4,
    AMPROP_ORDERABLE = 5,
    AMPROP_DISTANCE_ORDERABLE = 6,
    AMPROP_RETURNABLE = 7,
    AMPROP_SEARCH_ARRAY = 8,
    AMPROP_SEARCH_NULLS = 9,
    AMPROP_CLUSTERABLE = 10,
    AMPROP_INDEX_SCAN = 11,
    AMPROP_BITMAP_SCAN = 12,
    AMPROP_BACKWARD_SCAN = 13,
    AMPROP_CAN_ORDER = 14,
    AMPROP_CAN_UNIQUE = 15,
    AMPROP_CAN_MULTI_COL = 16,
    AMPROP_CAN_EXCLUDE = 17,
}
pub type ambuild_function =
    ::std::option::Option<unsafe extern "C" fn(heapRelation: Relation,
                                               indexRelation: Relation,
                                               indexInfo: *mut IndexInfo)
                              -> *mut IndexBuildResult>;
pub type ambuildempty_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation)>;
pub type aminsert_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation,
                                               values: *mut Datum,
                                               isnull: *mut bool_,
                                               heap_tid: ItemPointer,
                                               heapRelation: Relation,
                                               checkUnique: IndexUniqueCheck)
                              -> ::std::os::raw::c_char>;
pub type ambulkdelete_function =
    ::std::option::Option<unsafe extern "C" fn(info: *mut IndexVacuumInfo,
                                               stats:
                                                   *mut IndexBulkDeleteResult,
                                               callback:
                                                   IndexBulkDeleteCallback,
                                               callback_state:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut IndexBulkDeleteResult>;
pub type amvacuumcleanup_function =
    ::std::option::Option<unsafe extern "C" fn(info: *mut IndexVacuumInfo,
                                               stats:
                                                   *mut IndexBulkDeleteResult)
                              -> *mut IndexBulkDeleteResult>;
pub type amcanreturn_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation,
                                               attno: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_char>;
pub type amcostestimate_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               path: *mut IndexPath,
                                               loop_count: f64,
                                               indexStartupCost: *mut Cost,
                                               indexTotalCost: *mut Cost,
                                               indexSelectivity:
                                                   *mut Selectivity,
                                               indexCorrelation: *mut f64)>;
pub type amoptions_function =
    ::std::option::Option<unsafe extern "C" fn(reloptions: Datum,
                                               validate: bool_)
                              -> *mut varlena>;
pub type amproperty_function =
    ::std::option::Option<unsafe extern "C" fn(index_oid: Oid,
                                               attno: ::std::os::raw::c_int,
                                               prop: IndexAMProperty,
                                               propname:
                                                   *const ::std::os::raw::c_char,
                                               res: *mut bool_,
                                               isnull: *mut bool_)
                              -> ::std::os::raw::c_char>;
pub type amvalidate_function =
    ::std::option::Option<unsafe extern "C" fn(opclassoid: Oid)
                              -> ::std::os::raw::c_char>;
pub type ambeginscan_function =
    ::std::option::Option<unsafe extern "C" fn(indexRelation: Relation,
                                               nkeys: ::std::os::raw::c_int,
                                               norderbys:
                                                   ::std::os::raw::c_int)
                              -> *mut IndexScanDescData>;
pub type amrescan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc,
                                               keys: ScanKey,
                                               nkeys: ::std::os::raw::c_int,
                                               orderbys: ScanKey,
                                               norderbys:
                                                   ::std::os::raw::c_int)>;
pub type amgettuple_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc,
                                               direction: ScanDirection)
                              -> ::std::os::raw::c_char>;
pub type amgetbitmap_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc,
                                               tbm: *mut TIDBitmap)
                              -> ::std::os::raw::c_long>;
pub type amendscan_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type ammarkpos_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
pub type amrestrpos_function =
    ::std::option::Option<unsafe extern "C" fn(scan: IndexScanDesc)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexAmRoutine {
    pub type_: NodeTag,
    pub amstrategies: uint16,
    pub amsupport: uint16,
    pub amcanorder: bool_,
    pub amcanorderbyop: bool_,
    pub amcanbackward: bool_,
    pub amcanunique: bool_,
    pub amcanmulticol: bool_,
    pub amoptionalkey: bool_,
    pub amsearcharray: bool_,
    pub amsearchnulls: bool_,
    pub amstorage: bool_,
    pub amclusterable: bool_,
    pub ampredlocks: bool_,
    pub amkeytype: Oid,
    pub ambuild: ambuild_function,
    pub ambuildempty: ambuildempty_function,
    pub aminsert: aminsert_function,
    pub ambulkdelete: ambulkdelete_function,
    pub amvacuumcleanup: amvacuumcleanup_function,
    pub amcanreturn: amcanreturn_function,
    pub amcostestimate: amcostestimate_function,
    pub amoptions: amoptions_function,
    pub amproperty: amproperty_function,
    pub amvalidate: amvalidate_function,
    pub ambeginscan: ambeginscan_function,
    pub amrescan: amrescan_function,
    pub amgettuple: amgettuple_function,
    pub amgetbitmap: amgetbitmap_function,
    pub amendscan: amendscan_function,
    pub ammarkpos: ammarkpos_function,
    pub amrestrpos: amrestrpos_function,
}
#[test]
fn bindgen_test_layout_IndexAmRoutine() {
    assert_eq!(::std::mem::size_of::<IndexAmRoutine>() , 160usize);
    assert_eq!(::std::mem::align_of::<IndexAmRoutine>() , 8usize);
}
impl Clone for IndexAmRoutine {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn GetIndexAmRoutine(amhandler: Oid) -> *mut IndexAmRoutine;
}
extern "C" {
    pub fn GetIndexAmRoutineByAmId(amoid: Oid, noerror: bool_)
     -> *mut IndexAmRoutine;
}
extern "C" {
    pub fn amvalidate(fcinfo: FunctionCallInfo) -> Datum;
}
pub type BackendId = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "MyBackendId"]
    pub static mut MyBackendId: BackendId;
}
extern "C" {
    #[link_name = "ParallelMasterBackendId"]
    pub static mut ParallelMasterBackendId: BackendId;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dlist_node {
    pub prev: *mut dlist_node,
    pub next: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_node() {
    assert_eq!(::std::mem::size_of::<dlist_node>() , 16usize);
    assert_eq!(::std::mem::align_of::<dlist_node>() , 8usize);
}
impl Clone for dlist_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dlist_head {
    pub head: dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_head() {
    assert_eq!(::std::mem::size_of::<dlist_head>() , 16usize);
    assert_eq!(::std::mem::align_of::<dlist_head>() , 8usize);
}
impl Clone for dlist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dlist_iter {
    pub cur: *mut dlist_node,
    pub end: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_iter() {
    assert_eq!(::std::mem::size_of::<dlist_iter>() , 16usize);
    assert_eq!(::std::mem::align_of::<dlist_iter>() , 8usize);
}
impl Clone for dlist_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dlist_mutable_iter {
    pub cur: *mut dlist_node,
    pub next: *mut dlist_node,
    pub end: *mut dlist_node,
}
#[test]
fn bindgen_test_layout_dlist_mutable_iter() {
    assert_eq!(::std::mem::size_of::<dlist_mutable_iter>() , 24usize);
    assert_eq!(::std::mem::align_of::<dlist_mutable_iter>() , 8usize);
}
impl Clone for dlist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct slist_node {
    pub next: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_node() {
    assert_eq!(::std::mem::size_of::<slist_node>() , 8usize);
    assert_eq!(::std::mem::align_of::<slist_node>() , 8usize);
}
impl Clone for slist_node {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct slist_head {
    pub head: slist_node,
}
#[test]
fn bindgen_test_layout_slist_head() {
    assert_eq!(::std::mem::size_of::<slist_head>() , 8usize);
    assert_eq!(::std::mem::align_of::<slist_head>() , 8usize);
}
impl Clone for slist_head {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct slist_iter {
    pub cur: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_iter() {
    assert_eq!(::std::mem::size_of::<slist_iter>() , 8usize);
    assert_eq!(::std::mem::align_of::<slist_iter>() , 8usize);
}
impl Clone for slist_iter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct slist_mutable_iter {
    pub cur: *mut slist_node,
    pub next: *mut slist_node,
    pub prev: *mut slist_node,
}
#[test]
fn bindgen_test_layout_slist_mutable_iter() {
    assert_eq!(::std::mem::size_of::<slist_mutable_iter>() , 24usize);
    assert_eq!(::std::mem::align_of::<slist_mutable_iter>() , 8usize);
}
impl Clone for slist_mutable_iter {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn slist_delete(head: *mut slist_head, node: *mut slist_node);
}
pub type slock_t = ::std::os::raw::c_uchar;
extern "C" {
    #[link_name = "dummy_spinlock"]
    pub static mut dummy_spinlock: slock_t;
}
extern "C" {
    pub fn s_lock(lock: *mut slock_t, file: *const ::std::os::raw::c_char,
                  line: ::std::os::raw::c_int,
                  func: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_spins_per_delay(shared_spins_per_delay: ::std::os::raw::c_int);
}
extern "C" {
    pub fn update_spins_per_delay(shared_spins_per_delay:
                                      ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_41 {
    pub spins: ::std::os::raw::c_int,
    pub delays: ::std::os::raw::c_int,
    pub cur_delay: ::std::os::raw::c_int,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
    pub func: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_41() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_41>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_41>() , 8usize);
}
impl Clone for _bindgen_ty_41 {
    fn clone(&self) -> Self { *self }
}
pub type SpinDelayStatus = _bindgen_ty_41;
extern "C" {
    pub fn perform_spin_delay(status: *mut SpinDelayStatus);
}
extern "C" {
    pub fn finish_spin_delay(status: *mut SpinDelayStatus);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pg_atomic_flag {
    pub value: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pg_atomic_flag() {
    assert_eq!(::std::mem::size_of::<pg_atomic_flag>() , 1usize);
    assert_eq!(::std::mem::align_of::<pg_atomic_flag>() , 1usize);
}
impl Clone for pg_atomic_flag {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pg_atomic_uint32 {
    pub value: uint32,
}
#[test]
fn bindgen_test_layout_pg_atomic_uint32() {
    assert_eq!(::std::mem::size_of::<pg_atomic_uint32>() , 4usize);
    assert_eq!(::std::mem::align_of::<pg_atomic_uint32>() , 4usize);
}
impl Clone for pg_atomic_uint32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pg_atomic_uint64 {
    pub value: uint64,
}
#[test]
fn bindgen_test_layout_pg_atomic_uint64() {
    assert_eq!(::std::mem::size_of::<pg_atomic_uint64>() , 8usize);
    assert_eq!(::std::mem::align_of::<pg_atomic_uint64>() , 8usize);
}
impl Clone for pg_atomic_uint64 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct PGPROC {
    pub links: SHM_QUEUE,
    pub procgloballist: *mut *mut PGPROC,
    pub sem: PGSemaphoreData,
    pub waitStatus: ::std::os::raw::c_int,
    pub procLatch: Latch,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub pgprocno: ::std::os::raw::c_int,
    pub backendId: BackendId,
    pub databaseId: Oid,
    pub roleId: Oid,
    pub isBackgroundWorker: bool_,
    pub recoveryConflictPending: bool_,
    pub lwWaiting: bool_,
    pub lwWaitMode: uint8,
    pub lwWaitLink: dlist_node,
    pub waitLock: *mut LOCK,
    pub waitProcLock: *mut PROCLOCK,
    pub waitLockMode: LOCKMODE,
    pub heldLocks: LOCKMASK,
    pub waitLSN: XLogRecPtr,
    pub syncRepState: ::std::os::raw::c_int,
    pub syncRepLinks: SHM_QUEUE,
    pub myProcLocks: [SHM_QUEUE; 16usize],
    pub subxids: XidCache,
    pub procArrayGroupMember: bool_,
    pub procArrayGroupNext: pg_atomic_uint32,
    pub procArrayGroupMemberXid: TransactionId,
    pub wait_event_info: uint32,
    pub backendLock: LWLock,
    pub fpLockBits: uint64,
    pub fpRelId: [Oid; 16usize],
    pub fpVXIDLock: bool_,
    pub fpLocalTransactionId: LocalTransactionId,
    pub lockGroupLeader: *mut PGPROC,
    pub lockGroupMembers: dlist_head,
    pub lockGroupLink: dlist_node,
}
#[test]
fn bindgen_test_layout_PGPROC() {
    assert_eq!(::std::mem::size_of::<PGPROC>() , 824usize);
    assert_eq!(::std::mem::align_of::<PGPROC>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LWLockTranche {
    pub name: *const ::std::os::raw::c_char,
    pub array_base: *mut ::std::os::raw::c_void,
    pub array_stride: Size,
}
#[test]
fn bindgen_test_layout_LWLockTranche() {
    assert_eq!(::std::mem::size_of::<LWLockTranche>() , 24usize);
    assert_eq!(::std::mem::align_of::<LWLockTranche>() , 8usize);
}
impl Clone for LWLockTranche {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LWLock {
    pub tranche: uint16,
    pub state: pg_atomic_uint32,
    pub waiters: dlist_head,
}
#[test]
fn bindgen_test_layout_LWLock() {
    assert_eq!(::std::mem::size_of::<LWLock>() , 24usize);
    assert_eq!(::std::mem::align_of::<LWLock>() , 8usize);
}
impl Clone for LWLock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LWLockPadded {
    pub lock: __BindgenUnionField<LWLock>,
    pub pad: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_LWLockPadded() {
    assert_eq!(::std::mem::size_of::<LWLockPadded>() , 128usize);
    assert_eq!(::std::mem::align_of::<LWLockPadded>() , 8usize);
}
impl Clone for LWLockPadded {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LWLockMinimallyPadded {
    pub lock: __BindgenUnionField<LWLock>,
    pub pad: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_LWLockMinimallyPadded() {
    assert_eq!(::std::mem::size_of::<LWLockMinimallyPadded>() , 32usize);
    assert_eq!(::std::mem::align_of::<LWLockMinimallyPadded>() , 8usize);
}
impl Clone for LWLockMinimallyPadded {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "MainLWLockArray"]
    pub static mut MainLWLockArray: *mut LWLockPadded;
}
extern "C" {
    #[link_name = "MainLWLockNames"]
    pub static mut MainLWLockNames: *mut *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NamedLWLockTranche {
    pub lwLockTranche: LWLockTranche,
    pub trancheId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NamedLWLockTranche() {
    assert_eq!(::std::mem::size_of::<NamedLWLockTranche>() , 32usize);
    assert_eq!(::std::mem::align_of::<NamedLWLockTranche>() , 8usize);
}
impl Clone for NamedLWLockTranche {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "NamedLWLockTrancheArray"]
    pub static mut NamedLWLockTrancheArray: *mut NamedLWLockTranche;
}
extern "C" {
    #[link_name = "NamedLWLockTrancheRequests"]
    pub static mut NamedLWLockTrancheRequests: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LWLockMode {
    LW_EXCLUSIVE = 0,
    LW_SHARED = 1,
    LW_WAIT_UNTIL_FREE = 2,
}
extern "C" {
    pub fn LWLockAcquire(lock: *mut LWLock, mode: LWLockMode) -> bool_;
}
extern "C" {
    pub fn LWLockConditionalAcquire(lock: *mut LWLock, mode: LWLockMode)
     -> bool_;
}
extern "C" {
    pub fn LWLockAcquireOrWait(lock: *mut LWLock, mode: LWLockMode) -> bool_;
}
extern "C" {
    pub fn LWLockRelease(lock: *mut LWLock);
}
extern "C" {
    pub fn LWLockReleaseClearVar(lock: *mut LWLock, valptr: *mut uint64,
                                 val: uint64);
}
extern "C" {
    pub fn LWLockReleaseAll();
}
extern "C" {
    pub fn LWLockHeldByMe(lock: *mut LWLock) -> bool_;
}
extern "C" {
    pub fn LWLockWaitForVar(lock: *mut LWLock, valptr: *mut uint64,
                            oldval: uint64, newval: *mut uint64) -> bool_;
}
extern "C" {
    pub fn LWLockUpdateVar(lock: *mut LWLock, valptr: *mut uint64,
                           value: uint64);
}
extern "C" {
    pub fn LWLockShmemSize() -> Size;
}
extern "C" {
    pub fn CreateLWLocks();
}
extern "C" {
    pub fn InitLWLockAccess();
}
extern "C" {
    pub fn GetLWLockIdentifier(classId: uint8, eventId: uint16)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn RequestNamedLWLockTranche(tranche_name:
                                         *const ::std::os::raw::c_char,
                                     num_lwlocks: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetNamedLWLockTranche(tranche_name: *const ::std::os::raw::c_char)
     -> *mut LWLockPadded;
}
extern "C" {
    pub fn LWLockNewTrancheId() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LWLockRegisterTranche(tranche_id: ::std::os::raw::c_int,
                                 tranche: *mut LWLockTranche);
}
extern "C" {
    pub fn LWLockInitialize(lock: *mut LWLock,
                            tranche_id: ::std::os::raw::c_int);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BuiltinTrancheIds {
    LWTRANCHE_MAIN = 0,
    LWTRANCHE_CLOG_BUFFERS = 1,
    LWTRANCHE_COMMITTS_BUFFERS = 2,
    LWTRANCHE_SUBTRANS_BUFFERS = 3,
    LWTRANCHE_MXACTOFFSET_BUFFERS = 4,
    LWTRANCHE_MXACTMEMBER_BUFFERS = 5,
    LWTRANCHE_ASYNC_BUFFERS = 6,
    LWTRANCHE_OLDSERXID_BUFFERS = 7,
    LWTRANCHE_WAL_INSERT = 8,
    LWTRANCHE_BUFFER_CONTENT = 9,
    LWTRANCHE_BUFFER_IO_IN_PROGRESS = 10,
    LWTRANCHE_REPLICATION_ORIGIN = 11,
    LWTRANCHE_REPLICATION_SLOT_IO_IN_PROGRESS = 12,
    LWTRANCHE_PROC = 13,
    LWTRANCHE_BUFFER_MAPPING = 14,
    LWTRANCHE_LOCK_MANAGER = 15,
    LWTRANCHE_PREDICATE_LOCK_MANAGER = 16,
    LWTRANCHE_FIRST_USER_DEFINED = 17,
}
pub type LWLockId = *mut LWLock;
pub type HashValueFunc =
    ::std::option::Option<unsafe extern "C" fn(key:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> ::std::os::raw::c_uint>;
pub type HashCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(key1:
                                                   *const ::std::os::raw::c_void,
                                               key2:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> ::std::os::raw::c_int>;
pub type HashCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(dest:
                                                   *mut ::std::os::raw::c_void,
                                               src:
                                                   *const ::std::os::raw::c_void,
                                               keysize: Size)
                              -> *mut ::std::os::raw::c_void>;
pub type HashAllocFunc =
    ::std::option::Option<unsafe extern "C" fn(request: Size)
                              -> *mut ::std::os::raw::c_void>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HASHELEMENT {
    pub link: *mut HASHELEMENT,
    pub hashvalue: uint32,
}
#[test]
fn bindgen_test_layout_HASHELEMENT() {
    assert_eq!(::std::mem::size_of::<HASHELEMENT>() , 16usize);
    assert_eq!(::std::mem::align_of::<HASHELEMENT>() , 8usize);
}
impl Clone for HASHELEMENT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HASHHDR([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTAB([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HASHCTL {
    pub num_partitions: ::std::os::raw::c_long,
    pub ssize: ::std::os::raw::c_long,
    pub dsize: ::std::os::raw::c_long,
    pub max_dsize: ::std::os::raw::c_long,
    pub ffactor: ::std::os::raw::c_long,
    pub keysize: Size,
    pub entrysize: Size,
    pub hash: HashValueFunc,
    pub match_: HashCompareFunc,
    pub keycopy: HashCopyFunc,
    pub alloc: HashAllocFunc,
    pub hcxt: MemoryContext,
    pub hctl: *mut HASHHDR,
}
#[test]
fn bindgen_test_layout_HASHCTL() {
    assert_eq!(::std::mem::size_of::<HASHCTL>() , 104usize);
    assert_eq!(::std::mem::align_of::<HASHCTL>() , 8usize);
}
impl Clone for HASHCTL {
    fn clone(&self) -> Self { *self }
}
pub const HASH_FIND: _bindgen_ty_42 = _bindgen_ty_42::HASH_FIND;
pub const HASH_ENTER: _bindgen_ty_42 = _bindgen_ty_42::HASH_ENTER;
pub const HASH_REMOVE: _bindgen_ty_42 = _bindgen_ty_42::HASH_REMOVE;
pub const HASH_ENTER_NULL: _bindgen_ty_42 = _bindgen_ty_42::HASH_ENTER_NULL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_42 {
    HASH_FIND = 0,
    HASH_ENTER = 1,
    HASH_REMOVE = 2,
    HASH_ENTER_NULL = 3,
}
pub use self::_bindgen_ty_42 as HASHACTION;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_43 {
    pub hashp: *mut HTAB,
    pub curBucket: uint32,
    pub curEntry: *mut HASHELEMENT,
}
#[test]
fn bindgen_test_layout__bindgen_ty_43() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_43>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_43>() , 8usize);
}
impl Clone for _bindgen_ty_43 {
    fn clone(&self) -> Self { *self }
}
pub type HASH_SEQ_STATUS = _bindgen_ty_43;
extern "C" {
    pub fn hash_create(tabname: *const ::std::os::raw::c_char,
                       nelem: ::std::os::raw::c_long, info: *mut HASHCTL,
                       flags: ::std::os::raw::c_int) -> *mut HTAB;
}
extern "C" {
    pub fn hash_destroy(hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_stats(where_: *const ::std::os::raw::c_char,
                      hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_search(hashp: *mut HTAB,
                       keyPtr: *const ::std::os::raw::c_void,
                       action: HASHACTION, foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_hash_value(hashp: *mut HTAB,
                          keyPtr: *const ::std::os::raw::c_void) -> uint32;
}
extern "C" {
    pub fn hash_search_with_hash_value(hashp: *mut HTAB,
                                       keyPtr: *const ::std::os::raw::c_void,
                                       hashvalue: uint32, action: HASHACTION,
                                       foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hash_update_hash_key(hashp: *mut HTAB,
                                existingEntry: *mut ::std::os::raw::c_void,
                                newKeyPtr: *const ::std::os::raw::c_void)
     -> bool_;
}
extern "C" {
    pub fn hash_get_num_entries(hashp: *mut HTAB) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hash_seq_init(status: *mut HASH_SEQ_STATUS, hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_seq_search(status: *mut HASH_SEQ_STATUS)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hash_seq_term(status: *mut HASH_SEQ_STATUS);
}
extern "C" {
    pub fn hash_freeze(hashp: *mut HTAB);
}
extern "C" {
    pub fn hash_estimate_size(num_entries: ::std::os::raw::c_long,
                              entrysize: Size) -> Size;
}
extern "C" {
    pub fn hash_select_dirsize(num_entries: ::std::os::raw::c_long)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn hash_get_shared_size(info: *mut HASHCTL,
                                flags: ::std::os::raw::c_int) -> Size;
}
extern "C" {
    pub fn AtEOXact_HashTables(isCommit: bool_);
}
extern "C" {
    pub fn AtEOSubXact_HashTables(isCommit: bool_,
                                  nestDepth: ::std::os::raw::c_int);
}
extern "C" {
    pub fn string_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn tag_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn uint32_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn bitmap_hash(key: *const ::std::os::raw::c_void, keysize: Size)
     -> uint32;
}
extern "C" {
    pub fn bitmap_match(key1: *const ::std::os::raw::c_void,
                        key2: *const ::std::os::raw::c_void, keysize: Size)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SHM_QUEUE {
    pub prev: *mut SHM_QUEUE,
    pub next: *mut SHM_QUEUE,
}
#[test]
fn bindgen_test_layout_SHM_QUEUE() {
    assert_eq!(::std::mem::size_of::<SHM_QUEUE>() , 16usize);
    assert_eq!(::std::mem::align_of::<SHM_QUEUE>() , 8usize);
}
impl Clone for SHM_QUEUE {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn InitShmemAccess(seghdr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn InitShmemAllocation();
}
extern "C" {
    pub fn ShmemAlloc(size: Size) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ShmemAddrIsValid(addr: *const ::std::os::raw::c_void) -> bool_;
}
extern "C" {
    pub fn InitShmemIndex();
}
extern "C" {
    pub fn ShmemInitHash(name: *const ::std::os::raw::c_char,
                         init_size: ::std::os::raw::c_long,
                         max_size: ::std::os::raw::c_long,
                         infoP: *mut HASHCTL,
                         hash_flags: ::std::os::raw::c_int) -> *mut HTAB;
}
extern "C" {
    pub fn ShmemInitStruct(name: *const ::std::os::raw::c_char, size: Size,
                           foundPtr: *mut bool_)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn add_size(s1: Size, s2: Size) -> Size;
}
extern "C" {
    pub fn mul_size(s1: Size, s2: Size) -> Size;
}
extern "C" {
    pub fn RequestAddinShmemSpace(size: Size);
}
#[repr(C)]
pub struct _bindgen_ty_44 {
    pub key: [::std::os::raw::c_char; 48usize],
    pub location: *mut ::std::os::raw::c_void,
    pub size: Size,
}
#[test]
fn bindgen_test_layout__bindgen_ty_44() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_44>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_44>() , 8usize);
}
pub type ShmemIndexEnt = _bindgen_ty_44;
extern "C" {
    pub fn SHMQueueInit(queue: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueElemInit(queue: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueDelete(queue: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueInsertBefore(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueInsertAfter(queue: *mut SHM_QUEUE, elem: *mut SHM_QUEUE);
}
extern "C" {
    pub fn SHMQueueNext(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
}
extern "C" {
    pub fn SHMQueuePrev(queue: *const SHM_QUEUE, curElem: *const SHM_QUEUE,
                        linkOffset: Size) -> Pointer;
}
extern "C" {
    pub fn SHMQueueEmpty(queue: *const SHM_QUEUE) -> bool_;
}
extern "C" {
    pub fn SHMQueueIsDetached(queue: *const SHM_QUEUE) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PROC_QUEUE {
    pub links: SHM_QUEUE,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PROC_QUEUE() {
    assert_eq!(::std::mem::size_of::<PROC_QUEUE>() , 24usize);
    assert_eq!(::std::mem::align_of::<PROC_QUEUE>() , 8usize);
}
impl Clone for PROC_QUEUE {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "max_locks_per_xact"]
    pub static mut max_locks_per_xact: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_45 {
    pub backendId: BackendId,
    pub localTransactionId: LocalTransactionId,
}
#[test]
fn bindgen_test_layout__bindgen_ty_45() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_45>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_45>() , 4usize);
}
impl Clone for _bindgen_ty_45 {
    fn clone(&self) -> Self { *self }
}
pub type VirtualTransactionId = _bindgen_ty_45;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockMethodData {
    pub numLockModes: ::std::os::raw::c_int,
    pub conflictTab: *const LOCKMASK,
    pub lockModeNames: *const *const ::std::os::raw::c_char,
    pub trace_flag: *const bool_,
}
#[test]
fn bindgen_test_layout_LockMethodData() {
    assert_eq!(::std::mem::size_of::<LockMethodData>() , 32usize);
    assert_eq!(::std::mem::align_of::<LockMethodData>() , 8usize);
}
impl Clone for LockMethodData {
    fn clone(&self) -> Self { *self }
}
pub type LockMethod = *const LockMethodData;
pub type LOCKMETHODID = uint16;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockTagType {
    LOCKTAG_RELATION = 0,
    LOCKTAG_RELATION_EXTEND = 1,
    LOCKTAG_PAGE = 2,
    LOCKTAG_TUPLE = 3,
    LOCKTAG_TRANSACTION = 4,
    LOCKTAG_VIRTUALTRANSACTION = 5,
    LOCKTAG_SPECULATIVE_TOKEN = 6,
    LOCKTAG_OBJECT = 7,
    LOCKTAG_USERLOCK = 8,
    LOCKTAG_ADVISORY = 9,
}
extern "C" {
    #[link_name = "LockTagTypeNames"]
    pub static mut LockTagTypeNames: *const *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LOCKTAG {
    pub locktag_field1: uint32,
    pub locktag_field2: uint32,
    pub locktag_field3: uint32,
    pub locktag_field4: uint16,
    pub locktag_type: uint8,
    pub locktag_lockmethodid: uint8,
}
#[test]
fn bindgen_test_layout_LOCKTAG() {
    assert_eq!(::std::mem::size_of::<LOCKTAG>() , 16usize);
    assert_eq!(::std::mem::align_of::<LOCKTAG>() , 4usize);
}
impl Clone for LOCKTAG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LOCK {
    pub tag: LOCKTAG,
    pub grantMask: LOCKMASK,
    pub waitMask: LOCKMASK,
    pub procLocks: SHM_QUEUE,
    pub waitProcs: PROC_QUEUE,
    pub requested: [::std::os::raw::c_int; 10usize],
    pub nRequested: ::std::os::raw::c_int,
    pub granted: [::std::os::raw::c_int; 10usize],
    pub nGranted: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LOCK() {
    assert_eq!(::std::mem::size_of::<LOCK>() , 152usize);
    assert_eq!(::std::mem::align_of::<LOCK>() , 8usize);
}
impl Clone for LOCK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PROCLOCKTAG {
    pub myLock: *mut LOCK,
    pub myProc: *mut PGPROC,
}
#[test]
fn bindgen_test_layout_PROCLOCKTAG() {
    assert_eq!(::std::mem::size_of::<PROCLOCKTAG>() , 16usize);
    assert_eq!(::std::mem::align_of::<PROCLOCKTAG>() , 8usize);
}
impl Clone for PROCLOCKTAG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PROCLOCK {
    pub tag: PROCLOCKTAG,
    pub groupLeader: *mut PGPROC,
    pub holdMask: LOCKMASK,
    pub releaseMask: LOCKMASK,
    pub lockLink: SHM_QUEUE,
    pub procLink: SHM_QUEUE,
}
#[test]
fn bindgen_test_layout_PROCLOCK() {
    assert_eq!(::std::mem::size_of::<PROCLOCK>() , 64usize);
    assert_eq!(::std::mem::align_of::<PROCLOCK>() , 8usize);
}
impl Clone for PROCLOCK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LOCALLOCKTAG {
    pub lock: LOCKTAG,
    pub mode: LOCKMODE,
}
#[test]
fn bindgen_test_layout_LOCALLOCKTAG() {
    assert_eq!(::std::mem::size_of::<LOCALLOCKTAG>() , 20usize);
    assert_eq!(::std::mem::align_of::<LOCALLOCKTAG>() , 4usize);
}
impl Clone for LOCALLOCKTAG {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LOCALLOCKOWNER {
    pub owner: *mut LOCALLOCKOWNER_ResourceOwnerData,
    pub nLocks: int64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LOCALLOCKOWNER_ResourceOwnerData([u8; 0]);
#[test]
fn bindgen_test_layout_LOCALLOCKOWNER() {
    assert_eq!(::std::mem::size_of::<LOCALLOCKOWNER>() , 16usize);
    assert_eq!(::std::mem::align_of::<LOCALLOCKOWNER>() , 8usize);
}
impl Clone for LOCALLOCKOWNER {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LOCALLOCK {
    pub tag: LOCALLOCKTAG,
    pub lock: *mut LOCK,
    pub proclock: *mut PROCLOCK,
    pub hashcode: uint32,
    pub nLocks: int64,
    pub numLockOwners: ::std::os::raw::c_int,
    pub maxLockOwners: ::std::os::raw::c_int,
    pub holdsStrongLockCount: bool_,
    pub lockOwners: *mut LOCALLOCKOWNER,
}
#[test]
fn bindgen_test_layout_LOCALLOCK() {
    assert_eq!(::std::mem::size_of::<LOCALLOCK>() , 80usize);
    assert_eq!(::std::mem::align_of::<LOCALLOCK>() , 8usize);
}
impl Clone for LOCALLOCK {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockInstanceData {
    pub locktag: LOCKTAG,
    pub holdMask: LOCKMASK,
    pub waitLockMode: LOCKMODE,
    pub backend: BackendId,
    pub lxid: LocalTransactionId,
    pub pid: ::std::os::raw::c_int,
    pub leaderPid: ::std::os::raw::c_int,
    pub fastpath: bool_,
}
#[test]
fn bindgen_test_layout_LockInstanceData() {
    assert_eq!(::std::mem::size_of::<LockInstanceData>() , 44usize);
    assert_eq!(::std::mem::align_of::<LockInstanceData>() , 4usize);
}
impl Clone for LockInstanceData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockData {
    pub nelements: ::std::os::raw::c_int,
    pub locks: *mut LockInstanceData,
}
#[test]
fn bindgen_test_layout_LockData() {
    assert_eq!(::std::mem::size_of::<LockData>() , 16usize);
    assert_eq!(::std::mem::align_of::<LockData>() , 8usize);
}
impl Clone for LockData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BlockedProcData {
    pub pid: ::std::os::raw::c_int,
    pub first_lock: ::std::os::raw::c_int,
    pub num_locks: ::std::os::raw::c_int,
    pub first_waiter: ::std::os::raw::c_int,
    pub num_waiters: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BlockedProcData() {
    assert_eq!(::std::mem::size_of::<BlockedProcData>() , 20usize);
    assert_eq!(::std::mem::align_of::<BlockedProcData>() , 4usize);
}
impl Clone for BlockedProcData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BlockedProcsData {
    pub procs: *mut BlockedProcData,
    pub locks: *mut LockInstanceData,
    pub waiter_pids: *mut ::std::os::raw::c_int,
    pub nprocs: ::std::os::raw::c_int,
    pub maxprocs: ::std::os::raw::c_int,
    pub nlocks: ::std::os::raw::c_int,
    pub maxlocks: ::std::os::raw::c_int,
    pub npids: ::std::os::raw::c_int,
    pub maxpids: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BlockedProcsData() {
    assert_eq!(::std::mem::size_of::<BlockedProcsData>() , 48usize);
    assert_eq!(::std::mem::align_of::<BlockedProcsData>() , 8usize);
}
impl Clone for BlockedProcsData {
    fn clone(&self) -> Self { *self }
}
pub const LOCKACQUIRE_NOT_AVAIL: _bindgen_ty_46 =
    _bindgen_ty_46::LOCKACQUIRE_NOT_AVAIL;
pub const LOCKACQUIRE_OK: _bindgen_ty_46 = _bindgen_ty_46::LOCKACQUIRE_OK;
pub const LOCKACQUIRE_ALREADY_HELD: _bindgen_ty_46 =
    _bindgen_ty_46::LOCKACQUIRE_ALREADY_HELD;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_46 {
    LOCKACQUIRE_NOT_AVAIL = 0,
    LOCKACQUIRE_OK = 1,
    LOCKACQUIRE_ALREADY_HELD = 2,
}
pub use self::_bindgen_ty_46 as LockAcquireResult;
pub const DS_NOT_YET_CHECKED: _bindgen_ty_47 =
    _bindgen_ty_47::DS_NOT_YET_CHECKED;
pub const DS_NO_DEADLOCK: _bindgen_ty_47 = _bindgen_ty_47::DS_NO_DEADLOCK;
pub const DS_SOFT_DEADLOCK: _bindgen_ty_47 = _bindgen_ty_47::DS_SOFT_DEADLOCK;
pub const DS_HARD_DEADLOCK: _bindgen_ty_47 = _bindgen_ty_47::DS_HARD_DEADLOCK;
pub const DS_BLOCKED_BY_AUTOVACUUM: _bindgen_ty_47 =
    _bindgen_ty_47::DS_BLOCKED_BY_AUTOVACUUM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_47 {
    DS_NOT_YET_CHECKED = 0,
    DS_NO_DEADLOCK = 1,
    DS_SOFT_DEADLOCK = 2,
    DS_HARD_DEADLOCK = 3,
    DS_BLOCKED_BY_AUTOVACUUM = 4,
}
pub use self::_bindgen_ty_47 as DeadLockState;
extern "C" {
    pub fn InitLocks();
}
extern "C" {
    pub fn GetLocksMethodTable(lock: *const LOCK) -> LockMethod;
}
extern "C" {
    pub fn GetLockTagsMethodTable(locktag: *const LOCKTAG) -> LockMethod;
}
extern "C" {
    pub fn LockTagHashCode(locktag: *const LOCKTAG) -> uint32;
}
extern "C" {
    pub fn DoLockModesConflict(mode1: LOCKMODE, mode2: LOCKMODE) -> bool_;
}
extern "C" {
    pub fn LockAcquire(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: bool_, dontWait: bool_)
     -> LockAcquireResult;
}
extern "C" {
    pub fn LockAcquireExtended(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                               sessionLock: bool_, dontWait: bool_,
                               report_memory_error: bool_)
     -> LockAcquireResult;
}
extern "C" {
    pub fn AbortStrongLockAcquire();
}
extern "C" {
    pub fn LockRelease(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                       sessionLock: bool_) -> bool_;
}
extern "C" {
    pub fn LockReleaseAll(lockmethodid: LOCKMETHODID, allLocks: bool_);
}
extern "C" {
    pub fn LockReleaseSession(lockmethodid: LOCKMETHODID);
}
extern "C" {
    pub fn LockReleaseCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                   nlocks: ::std::os::raw::c_int);
}
extern "C" {
    pub fn LockReassignCurrentOwner(locallocks: *mut *mut LOCALLOCK,
                                    nlocks: ::std::os::raw::c_int);
}
extern "C" {
    pub fn LockHasWaiters(locktag: *const LOCKTAG, lockmode: LOCKMODE,
                          sessionLock: bool_) -> bool_;
}
extern "C" {
    pub fn GetLockConflicts(locktag: *const LOCKTAG, lockmode: LOCKMODE)
     -> *mut VirtualTransactionId;
}
extern "C" {
    pub fn AtPrepare_Locks();
}
extern "C" {
    pub fn PostPrepare_Locks(xid: TransactionId);
}
extern "C" {
    pub fn LockCheckConflicts(lockMethodTable: LockMethod, lockmode: LOCKMODE,
                              lock: *mut LOCK, proclock: *mut PROCLOCK)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GrantLock(lock: *mut LOCK, proclock: *mut PROCLOCK,
                     lockmode: LOCKMODE);
}
extern "C" {
    pub fn GrantAwaitedLock();
}
extern "C" {
    pub fn RemoveFromWaitQueue(proc_: *mut PGPROC, hashcode: uint32);
}
extern "C" {
    pub fn LockShmemSize() -> Size;
}
extern "C" {
    pub fn GetLockStatusData() -> *mut LockData;
}
extern "C" {
    pub fn GetBlockerStatusData(blocked_pid: ::std::os::raw::c_int)
     -> *mut BlockedProcsData;
}
extern "C" {
    pub fn GetRunningTransactionLocks(nlocks: *mut ::std::os::raw::c_int)
     -> *mut xl_standby_lock;
}
extern "C" {
    pub fn GetLockmodeName(lockmethodid: LOCKMETHODID, mode: LOCKMODE)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lock_twophase_recover(xid: TransactionId, info: uint16,
                                 recdata: *mut ::std::os::raw::c_void,
                                 len: uint32);
}
extern "C" {
    pub fn lock_twophase_postcommit(xid: TransactionId, info: uint16,
                                    recdata: *mut ::std::os::raw::c_void,
                                    len: uint32);
}
extern "C" {
    pub fn lock_twophase_postabort(xid: TransactionId, info: uint16,
                                   recdata: *mut ::std::os::raw::c_void,
                                   len: uint32);
}
extern "C" {
    pub fn lock_twophase_standby_recover(xid: TransactionId, info: uint16,
                                         recdata: *mut ::std::os::raw::c_void,
                                         len: uint32);
}
extern "C" {
    pub fn DeadLockCheck(proc_: *mut PGPROC) -> DeadLockState;
}
extern "C" {
    pub fn GetBlockingAutoVacuumPgproc() -> *mut PGPROC;
}
extern "C" {
    pub fn DeadLockReport();
}
extern "C" {
    pub fn RememberSimpleDeadLock(proc1: *mut PGPROC, lockmode: LOCKMODE,
                                  lock: *mut LOCK, proc2: *mut PGPROC);
}
extern "C" {
    pub fn InitDeadLockChecking();
}
extern "C" {
    pub fn LockWaiterCount(locktag: *const LOCKTAG) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn VirtualXactLockTableInsert(vxid: VirtualTransactionId);
}
extern "C" {
    pub fn VirtualXactLockTableCleanup();
}
extern "C" {
    pub fn VirtualXactLock(vxid: VirtualTransactionId, wait: bool_) -> bool_;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum relopt_type {
    RELOPT_TYPE_BOOL = 0,
    RELOPT_TYPE_INT = 1,
    RELOPT_TYPE_REAL = 2,
    RELOPT_TYPE_STRING = 3,
}
pub const relopt_kind_RELOPT_KIND_LAST_DEFAULT: relopt_kind =
    relopt_kind::RELOPT_KIND_BRIN;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum relopt_kind {
    RELOPT_KIND_HEAP = 1,
    RELOPT_KIND_TOAST = 2,
    RELOPT_KIND_BTREE = 4,
    RELOPT_KIND_HASH = 8,
    RELOPT_KIND_GIN = 16,
    RELOPT_KIND_GIST = 32,
    RELOPT_KIND_ATTRIBUTE = 64,
    RELOPT_KIND_TABLESPACE = 128,
    RELOPT_KIND_SPGIST = 256,
    RELOPT_KIND_VIEW = 512,
    RELOPT_KIND_BRIN = 1024,
    RELOPT_KIND_MAX = 1073741824,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct relopt_gen {
    pub name: *const ::std::os::raw::c_char,
    pub desc: *const ::std::os::raw::c_char,
    pub kinds: bits32,
    pub lockmode: LOCKMODE,
    pub namelen: ::std::os::raw::c_int,
    pub type_: relopt_type,
}
#[test]
fn bindgen_test_layout_relopt_gen() {
    assert_eq!(::std::mem::size_of::<relopt_gen>() , 32usize);
    assert_eq!(::std::mem::align_of::<relopt_gen>() , 8usize);
}
impl Clone for relopt_gen {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct relopt_value {
    pub gen: *mut relopt_gen,
    pub isset: bool_,
    pub values: relopt_value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct relopt_value__bindgen_ty_1 {
    pub bool_val: __BindgenUnionField<bool_>,
    pub int_val: __BindgenUnionField<::std::os::raw::c_int>,
    pub real_val: __BindgenUnionField<f64>,
    pub string_val: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_relopt_value__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<relopt_value__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<relopt_value__bindgen_ty_1>() , 8usize);
}
impl Clone for relopt_value__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_relopt_value() {
    assert_eq!(::std::mem::size_of::<relopt_value>() , 24usize);
    assert_eq!(::std::mem::align_of::<relopt_value>() , 8usize);
}
impl Clone for relopt_value {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct relopt_bool {
    pub gen: relopt_gen,
    pub default_val: bool_,
}
#[test]
fn bindgen_test_layout_relopt_bool() {
    assert_eq!(::std::mem::size_of::<relopt_bool>() , 40usize);
    assert_eq!(::std::mem::align_of::<relopt_bool>() , 8usize);
}
impl Clone for relopt_bool {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct relopt_int {
    pub gen: relopt_gen,
    pub default_val: ::std::os::raw::c_int,
    pub min: ::std::os::raw::c_int,
    pub max: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_relopt_int() {
    assert_eq!(::std::mem::size_of::<relopt_int>() , 48usize);
    assert_eq!(::std::mem::align_of::<relopt_int>() , 8usize);
}
impl Clone for relopt_int {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct relopt_real {
    pub gen: relopt_gen,
    pub default_val: f64,
    pub min: f64,
    pub max: f64,
}
#[test]
fn bindgen_test_layout_relopt_real() {
    assert_eq!(::std::mem::size_of::<relopt_real>() , 56usize);
    assert_eq!(::std::mem::align_of::<relopt_real>() , 8usize);
}
impl Clone for relopt_real {
    fn clone(&self) -> Self { *self }
}
pub type validate_string_relopt =
    ::std::option::Option<unsafe extern "C" fn(value:
                                                   *mut ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct relopt_string {
    pub gen: relopt_gen,
    pub default_len: ::std::os::raw::c_int,
    pub default_isnull: bool_,
    pub validate_cb: validate_string_relopt,
    pub default_val: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_relopt_string() {
    assert_eq!(::std::mem::size_of::<relopt_string>() , 56usize);
    assert_eq!(::std::mem::align_of::<relopt_string>() , 8usize);
}
impl Clone for relopt_string {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_48 {
    pub optname: *const ::std::os::raw::c_char,
    pub opttype: relopt_type,
    pub offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_48() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_48>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_48>() , 8usize);
}
impl Clone for _bindgen_ty_48 {
    fn clone(&self) -> Self { *self }
}
pub type relopt_parse_elt = _bindgen_ty_48;
extern "C" {
    pub fn add_reloption_kind() -> relopt_kind;
}
extern "C" {
    pub fn add_bool_reloption(kinds: bits32,
                              name: *mut ::std::os::raw::c_char,
                              desc: *mut ::std::os::raw::c_char,
                              default_val: bool_);
}
extern "C" {
    pub fn add_int_reloption(kinds: bits32, name: *mut ::std::os::raw::c_char,
                             desc: *mut ::std::os::raw::c_char,
                             default_val: ::std::os::raw::c_int,
                             min_val: ::std::os::raw::c_int,
                             max_val: ::std::os::raw::c_int);
}
extern "C" {
    pub fn add_real_reloption(kinds: bits32,
                              name: *mut ::std::os::raw::c_char,
                              desc: *mut ::std::os::raw::c_char,
                              default_val: f64, min_val: f64, max_val: f64);
}
extern "C" {
    pub fn add_string_reloption(kinds: bits32,
                                name: *mut ::std::os::raw::c_char,
                                desc: *mut ::std::os::raw::c_char,
                                default_val: *mut ::std::os::raw::c_char,
                                validator: validate_string_relopt);
}
extern "C" {
    pub fn transformRelOptions(oldOptions: Datum, defList: *mut List,
                               namspace: *mut ::std::os::raw::c_char,
                               validnsps: *mut *mut ::std::os::raw::c_char,
                               ignoreOids: bool_, isReset: bool_) -> Datum;
}
extern "C" {
    pub fn untransformRelOptions(options: Datum) -> *mut List;
}
extern "C" {
    pub fn extractRelOptions(tuple: HeapTuple, tupdesc: TupleDesc,
                             amoptions: amoptions_function) -> *mut bytea;
}
extern "C" {
    pub fn parseRelOptions(options: Datum, validate: bool_, kind: relopt_kind,
                           numrelopts: *mut ::std::os::raw::c_int)
     -> *mut relopt_value;
}
extern "C" {
    pub fn allocateReloptStruct(base: Size, options: *mut relopt_value,
                                numoptions: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn fillRelOptions(rdopts: *mut ::std::os::raw::c_void, basesize: Size,
                          options: *mut relopt_value,
                          numoptions: ::std::os::raw::c_int, validate: bool_,
                          elems: *const relopt_parse_elt,
                          nelems: ::std::os::raw::c_int);
}
extern "C" {
    pub fn default_reloptions(reloptions: Datum, validate: bool_,
                              kind: relopt_kind) -> *mut bytea;
}
extern "C" {
    pub fn heap_reloptions(relkind: ::std::os::raw::c_char, reloptions: Datum,
                           validate: bool_) -> *mut bytea;
}
extern "C" {
    pub fn view_reloptions(reloptions: Datum, validate: bool_) -> *mut bytea;
}
extern "C" {
    pub fn index_reloptions(amoptions: amoptions_function, reloptions: Datum,
                            validate: bool_) -> *mut bytea;
}
extern "C" {
    pub fn attribute_reloptions(reloptions: Datum, validate: bool_)
     -> *mut bytea;
}
extern "C" {
    pub fn tablespace_reloptions(reloptions: Datum, validate: bool_)
     -> *mut bytea;
}
extern "C" {
    pub fn AlterTableGetRelOptionsLockLevel(defList: *mut List) -> LOCKMODE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockClauseStrength {
    LCS_NONE = 0,
    LCS_FORKEYSHARE = 1,
    LCS_FORSHARE = 2,
    LCS_FORNOKEYUPDATE = 3,
    LCS_FORUPDATE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockWaitPolicy {
    LockWaitBlock = 0,
    LockWaitSkip = 1,
    LockWaitError = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Alias {
    pub type_: NodeTag,
    pub aliasname: *mut ::std::os::raw::c_char,
    pub colnames: *mut List,
}
#[test]
fn bindgen_test_layout_Alias() {
    assert_eq!(::std::mem::size_of::<Alias>() , 24usize);
    assert_eq!(::std::mem::align_of::<Alias>() , 8usize);
}
impl Clone for Alias {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum InhOption { INH_NO = 0, INH_YES = 1, INH_DEFAULT = 2, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum OnCommitAction {
    ONCOMMIT_NOOP = 0,
    ONCOMMIT_PRESERVE_ROWS = 1,
    ONCOMMIT_DELETE_ROWS = 2,
    ONCOMMIT_DROP = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RangeVar {
    pub type_: NodeTag,
    pub catalogname: *mut ::std::os::raw::c_char,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub relname: *mut ::std::os::raw::c_char,
    pub inhOpt: InhOption,
    pub relpersistence: ::std::os::raw::c_char,
    pub alias: *mut Alias,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeVar() {
    assert_eq!(::std::mem::size_of::<RangeVar>() , 56usize);
    assert_eq!(::std::mem::align_of::<RangeVar>() , 8usize);
}
impl Clone for RangeVar {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IntoClause {
    pub type_: NodeTag,
    pub rel: *mut RangeVar,
    pub colNames: *mut List,
    pub options: *mut List,
    pub onCommit: OnCommitAction,
    pub tableSpaceName: *mut ::std::os::raw::c_char,
    pub viewQuery: *mut Node,
    pub skipData: bool_,
}
#[test]
fn bindgen_test_layout_IntoClause() {
    assert_eq!(::std::mem::size_of::<IntoClause>() , 64usize);
    assert_eq!(::std::mem::align_of::<IntoClause>() , 8usize);
}
impl Clone for IntoClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Expr {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_Expr() {
    assert_eq!(::std::mem::size_of::<Expr>() , 4usize);
    assert_eq!(::std::mem::align_of::<Expr>() , 4usize);
}
impl Clone for Expr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Var {
    pub xpr: Expr,
    pub varno: Index,
    pub varattno: AttrNumber,
    pub vartype: Oid,
    pub vartypmod: int32,
    pub varcollid: Oid,
    pub varlevelsup: Index,
    pub varnoold: Index,
    pub varoattno: AttrNumber,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Var() {
    assert_eq!(::std::mem::size_of::<Var>() , 40usize);
    assert_eq!(::std::mem::align_of::<Var>() , 4usize);
}
impl Clone for Var {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Const {
    pub xpr: Expr,
    pub consttype: Oid,
    pub consttypmod: int32,
    pub constcollid: Oid,
    pub constlen: ::std::os::raw::c_int,
    pub constvalue: Datum,
    pub constisnull: bool_,
    pub constbyval: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Const() {
    assert_eq!(::std::mem::size_of::<Const>() , 40usize);
    assert_eq!(::std::mem::align_of::<Const>() , 8usize);
}
impl Clone for Const {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ParamKind {
    PARAM_EXTERN = 0,
    PARAM_EXEC = 1,
    PARAM_SUBLINK = 2,
    PARAM_MULTIEXPR = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Param {
    pub xpr: Expr,
    pub paramkind: ParamKind,
    pub paramid: ::std::os::raw::c_int,
    pub paramtype: Oid,
    pub paramtypmod: int32,
    pub paramcollid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Param() {
    assert_eq!(::std::mem::size_of::<Param>() , 28usize);
    assert_eq!(::std::mem::align_of::<Param>() , 4usize);
}
impl Clone for Param {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GroupingFunc {
    pub xpr: Expr,
    pub args: *mut List,
    pub refs: *mut List,
    pub cols: *mut List,
    pub agglevelsup: Index,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GroupingFunc() {
    assert_eq!(::std::mem::size_of::<GroupingFunc>() , 40usize);
    assert_eq!(::std::mem::align_of::<GroupingFunc>() , 8usize);
}
impl Clone for GroupingFunc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WindowFunc {
    pub xpr: Expr,
    pub winfnoid: Oid,
    pub wintype: Oid,
    pub wincollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub aggfilter: *mut Expr,
    pub winref: Index,
    pub winstar: bool_,
    pub winagg: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowFunc() {
    assert_eq!(::std::mem::size_of::<WindowFunc>() , 56usize);
    assert_eq!(::std::mem::align_of::<WindowFunc>() , 8usize);
}
impl Clone for WindowFunc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ArrayRef {
    pub xpr: Expr,
    pub refarraytype: Oid,
    pub refelemtype: Oid,
    pub reftypmod: int32,
    pub refcollid: Oid,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut Expr,
    pub refassgnexpr: *mut Expr,
}
#[test]
fn bindgen_test_layout_ArrayRef() {
    assert_eq!(::std::mem::size_of::<ArrayRef>() , 56usize);
    assert_eq!(::std::mem::align_of::<ArrayRef>() , 8usize);
}
impl Clone for ArrayRef {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CoercionContext {
    COERCION_IMPLICIT = 0,
    COERCION_ASSIGNMENT = 1,
    COERCION_EXPLICIT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CoercionForm {
    COERCE_EXPLICIT_CALL = 0,
    COERCE_EXPLICIT_CAST = 1,
    COERCE_IMPLICIT_CAST = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FuncExpr {
    pub xpr: Expr,
    pub funcid: Oid,
    pub funcresulttype: Oid,
    pub funcretset: bool_,
    pub funcvariadic: bool_,
    pub funcformat: CoercionForm,
    pub funccollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FuncExpr() {
    assert_eq!(::std::mem::size_of::<FuncExpr>() , 48usize);
    assert_eq!(::std::mem::align_of::<FuncExpr>() , 8usize);
}
impl Clone for FuncExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NamedArgExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub name: *mut ::std::os::raw::c_char,
    pub argnumber: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NamedArgExpr() {
    assert_eq!(::std::mem::size_of::<NamedArgExpr>() , 32usize);
    assert_eq!(::std::mem::align_of::<NamedArgExpr>() , 8usize);
}
impl Clone for NamedArgExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub opresulttype: Oid,
    pub opretset: bool_,
    pub opcollid: Oid,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OpExpr() {
    assert_eq!(::std::mem::size_of::<OpExpr>() , 48usize);
    assert_eq!(::std::mem::align_of::<OpExpr>() , 8usize);
}
impl Clone for OpExpr {
    fn clone(&self) -> Self { *self }
}
pub type DistinctExpr = OpExpr;
pub type NullIfExpr = OpExpr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScalarArrayOpExpr {
    pub xpr: Expr,
    pub opno: Oid,
    pub opfuncid: Oid,
    pub useOr: bool_,
    pub inputcollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ScalarArrayOpExpr() {
    assert_eq!(::std::mem::size_of::<ScalarArrayOpExpr>() , 40usize);
    assert_eq!(::std::mem::align_of::<ScalarArrayOpExpr>() , 8usize);
}
impl Clone for ScalarArrayOpExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BoolExprType { AND_EXPR = 0, OR_EXPR = 1, NOT_EXPR = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BoolExpr {
    pub xpr: Expr,
    pub boolop: BoolExprType,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BoolExpr() {
    assert_eq!(::std::mem::size_of::<BoolExpr>() , 24usize);
    assert_eq!(::std::mem::align_of::<BoolExpr>() , 8usize);
}
impl Clone for BoolExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SubLinkType {
    EXISTS_SUBLINK = 0,
    ALL_SUBLINK = 1,
    ANY_SUBLINK = 2,
    ROWCOMPARE_SUBLINK = 3,
    EXPR_SUBLINK = 4,
    MULTIEXPR_SUBLINK = 5,
    ARRAY_SUBLINK = 6,
    CTE_SUBLINK = 7,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SubLink {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub subLinkId: ::std::os::raw::c_int,
    pub testexpr: *mut Node,
    pub operName: *mut List,
    pub subselect: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SubLink() {
    assert_eq!(::std::mem::size_of::<SubLink>() , 48usize);
    assert_eq!(::std::mem::align_of::<SubLink>() , 8usize);
}
impl Clone for SubLink {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SubPlan {
    pub xpr: Expr,
    pub subLinkType: SubLinkType,
    pub testexpr: *mut Node,
    pub paramIds: *mut List,
    pub plan_id: ::std::os::raw::c_int,
    pub plan_name: *mut ::std::os::raw::c_char,
    pub firstColType: Oid,
    pub firstColTypmod: int32,
    pub firstColCollation: Oid,
    pub useHashTable: bool_,
    pub unknownEqFalse: bool_,
    pub setParam: *mut List,
    pub parParam: *mut List,
    pub args: *mut List,
    pub startup_cost: Cost,
    pub per_call_cost: Cost,
}
#[test]
fn bindgen_test_layout_SubPlan() {
    assert_eq!(::std::mem::size_of::<SubPlan>() , 96usize);
    assert_eq!(::std::mem::align_of::<SubPlan>() , 8usize);
}
impl Clone for SubPlan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlternativeSubPlan {
    pub xpr: Expr,
    pub subplans: *mut List,
}
#[test]
fn bindgen_test_layout_AlternativeSubPlan() {
    assert_eq!(::std::mem::size_of::<AlternativeSubPlan>() , 16usize);
    assert_eq!(::std::mem::align_of::<AlternativeSubPlan>() , 8usize);
}
impl Clone for AlternativeSubPlan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FieldSelect {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub fieldnum: AttrNumber,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
}
#[test]
fn bindgen_test_layout_FieldSelect() {
    assert_eq!(::std::mem::size_of::<FieldSelect>() , 32usize);
    assert_eq!(::std::mem::align_of::<FieldSelect>() , 8usize);
}
impl Clone for FieldSelect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FieldStore {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub newvals: *mut List,
    pub fieldnums: *mut List,
    pub resulttype: Oid,
}
#[test]
fn bindgen_test_layout_FieldStore() {
    assert_eq!(::std::mem::size_of::<FieldStore>() , 40usize);
    assert_eq!(::std::mem::align_of::<FieldStore>() , 8usize);
}
impl Clone for FieldStore {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RelabelType {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub relabelformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RelabelType() {
    assert_eq!(::std::mem::size_of::<RelabelType>() , 40usize);
    assert_eq!(::std::mem::align_of::<RelabelType>() , 8usize);
}
impl Clone for RelabelType {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoerceViaIO {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resultcollid: Oid,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceViaIO() {
    assert_eq!(::std::mem::size_of::<CoerceViaIO>() , 32usize);
    assert_eq!(::std::mem::align_of::<CoerceViaIO>() , 8usize);
}
impl Clone for CoerceViaIO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ArrayCoerceExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub elemfuncid: Oid,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub isExplicit: bool_,
    pub coerceformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ArrayCoerceExpr() {
    assert_eq!(::std::mem::size_of::<ArrayCoerceExpr>() , 48usize);
    assert_eq!(::std::mem::align_of::<ArrayCoerceExpr>() , 8usize);
}
impl Clone for ArrayCoerceExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ConvertRowtypeExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub convertformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ConvertRowtypeExpr() {
    assert_eq!(::std::mem::size_of::<ConvertRowtypeExpr>() , 32usize);
    assert_eq!(::std::mem::align_of::<ConvertRowtypeExpr>() , 8usize);
}
impl Clone for ConvertRowtypeExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CollateExpr {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub collOid: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CollateExpr() {
    assert_eq!(::std::mem::size_of::<CollateExpr>() , 24usize);
    assert_eq!(::std::mem::align_of::<CollateExpr>() , 8usize);
}
impl Clone for CollateExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CaseExpr {
    pub xpr: Expr,
    pub casetype: Oid,
    pub casecollid: Oid,
    pub arg: *mut Expr,
    pub args: *mut List,
    pub defresult: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CaseExpr() {
    assert_eq!(::std::mem::size_of::<CaseExpr>() , 48usize);
    assert_eq!(::std::mem::align_of::<CaseExpr>() , 8usize);
}
impl Clone for CaseExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CaseWhen {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub result: *mut Expr,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CaseWhen() {
    assert_eq!(::std::mem::size_of::<CaseWhen>() , 32usize);
    assert_eq!(::std::mem::align_of::<CaseWhen>() , 8usize);
}
impl Clone for CaseWhen {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CaseTestExpr {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
}
#[test]
fn bindgen_test_layout_CaseTestExpr() {
    assert_eq!(::std::mem::size_of::<CaseTestExpr>() , 16usize);
    assert_eq!(::std::mem::align_of::<CaseTestExpr>() , 4usize);
}
impl Clone for CaseTestExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ArrayExpr {
    pub xpr: Expr,
    pub array_typeid: Oid,
    pub array_collid: Oid,
    pub element_typeid: Oid,
    pub elements: *mut List,
    pub multidims: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ArrayExpr() {
    assert_eq!(::std::mem::size_of::<ArrayExpr>() , 32usize);
    assert_eq!(::std::mem::align_of::<ArrayExpr>() , 8usize);
}
impl Clone for ArrayExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RowExpr {
    pub xpr: Expr,
    pub args: *mut List,
    pub row_typeid: Oid,
    pub row_format: CoercionForm,
    pub colnames: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RowExpr() {
    assert_eq!(::std::mem::size_of::<RowExpr>() , 40usize);
    assert_eq!(::std::mem::align_of::<RowExpr>() , 8usize);
}
impl Clone for RowExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RowCompareType {
    ROWCOMPARE_LT = 1,
    ROWCOMPARE_LE = 2,
    ROWCOMPARE_EQ = 3,
    ROWCOMPARE_GE = 4,
    ROWCOMPARE_GT = 5,
    ROWCOMPARE_NE = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RowCompareExpr {
    pub xpr: Expr,
    pub rctype: RowCompareType,
    pub opnos: *mut List,
    pub opfamilies: *mut List,
    pub inputcollids: *mut List,
    pub largs: *mut List,
    pub rargs: *mut List,
}
#[test]
fn bindgen_test_layout_RowCompareExpr() {
    assert_eq!(::std::mem::size_of::<RowCompareExpr>() , 48usize);
    assert_eq!(::std::mem::align_of::<RowCompareExpr>() , 8usize);
}
impl Clone for RowCompareExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoalesceExpr {
    pub xpr: Expr,
    pub coalescetype: Oid,
    pub coalescecollid: Oid,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoalesceExpr() {
    assert_eq!(::std::mem::size_of::<CoalesceExpr>() , 32usize);
    assert_eq!(::std::mem::align_of::<CoalesceExpr>() , 8usize);
}
impl Clone for CoalesceExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum MinMaxOp { IS_GREATEST = 0, IS_LEAST = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MinMaxExpr {
    pub xpr: Expr,
    pub minmaxtype: Oid,
    pub minmaxcollid: Oid,
    pub inputcollid: Oid,
    pub op: MinMaxOp,
    pub args: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MinMaxExpr() {
    assert_eq!(::std::mem::size_of::<MinMaxExpr>() , 40usize);
    assert_eq!(::std::mem::align_of::<MinMaxExpr>() , 8usize);
}
impl Clone for MinMaxExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum XmlExprOp {
    IS_XMLCONCAT = 0,
    IS_XMLELEMENT = 1,
    IS_XMLFOREST = 2,
    IS_XMLPARSE = 3,
    IS_XMLPI = 4,
    IS_XMLROOT = 5,
    IS_XMLSERIALIZE = 6,
    IS_DOCUMENT = 7,
}
pub const XMLOPTION_DOCUMENT: _bindgen_ty_49 =
    _bindgen_ty_49::XMLOPTION_DOCUMENT;
pub const XMLOPTION_CONTENT: _bindgen_ty_49 =
    _bindgen_ty_49::XMLOPTION_CONTENT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_49 { XMLOPTION_DOCUMENT = 0, XMLOPTION_CONTENT = 1, }
pub use self::_bindgen_ty_49 as XmlOptionType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XmlExpr {
    pub xpr: Expr,
    pub op: XmlExprOp,
    pub name: *mut ::std::os::raw::c_char,
    pub named_args: *mut List,
    pub arg_names: *mut List,
    pub args: *mut List,
    pub xmloption: XmlOptionType,
    pub type_: Oid,
    pub typmod: int32,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XmlExpr() {
    assert_eq!(::std::mem::size_of::<XmlExpr>() , 56usize);
    assert_eq!(::std::mem::align_of::<XmlExpr>() , 8usize);
}
impl Clone for XmlExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum NullTestType { IS_NULL = 0, IS_NOT_NULL = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NullTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub nulltesttype: NullTestType,
    pub argisrow: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_NullTest() {
    assert_eq!(::std::mem::size_of::<NullTest>() , 32usize);
    assert_eq!(::std::mem::align_of::<NullTest>() , 8usize);
}
impl Clone for NullTest {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BoolTestType {
    IS_TRUE = 0,
    IS_NOT_TRUE = 1,
    IS_FALSE = 2,
    IS_NOT_FALSE = 3,
    IS_UNKNOWN = 4,
    IS_NOT_UNKNOWN = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BooleanTest {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub booltesttype: BoolTestType,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BooleanTest() {
    assert_eq!(::std::mem::size_of::<BooleanTest>() , 24usize);
    assert_eq!(::std::mem::align_of::<BooleanTest>() , 8usize);
}
impl Clone for BooleanTest {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoerceToDomain {
    pub xpr: Expr,
    pub arg: *mut Expr,
    pub resulttype: Oid,
    pub resulttypmod: int32,
    pub resultcollid: Oid,
    pub coercionformat: CoercionForm,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceToDomain() {
    assert_eq!(::std::mem::size_of::<CoerceToDomain>() , 40usize);
    assert_eq!(::std::mem::align_of::<CoerceToDomain>() , 8usize);
}
impl Clone for CoerceToDomain {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoerceToDomainValue {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CoerceToDomainValue() {
    assert_eq!(::std::mem::size_of::<CoerceToDomainValue>() , 20usize);
    assert_eq!(::std::mem::align_of::<CoerceToDomainValue>() , 4usize);
}
impl Clone for CoerceToDomainValue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SetToDefault {
    pub xpr: Expr,
    pub typeId: Oid,
    pub typeMod: int32,
    pub collation: Oid,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SetToDefault() {
    assert_eq!(::std::mem::size_of::<SetToDefault>() , 20usize);
    assert_eq!(::std::mem::align_of::<SetToDefault>() , 4usize);
}
impl Clone for SetToDefault {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CurrentOfExpr {
    pub xpr: Expr,
    pub cvarno: Index,
    pub cursor_name: *mut ::std::os::raw::c_char,
    pub cursor_param: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CurrentOfExpr() {
    assert_eq!(::std::mem::size_of::<CurrentOfExpr>() , 24usize);
    assert_eq!(::std::mem::align_of::<CurrentOfExpr>() , 8usize);
}
impl Clone for CurrentOfExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct InferenceElem {
    pub xpr: Expr,
    pub expr: *mut Node,
    pub infercollid: Oid,
    pub inferopclass: Oid,
}
#[test]
fn bindgen_test_layout_InferenceElem() {
    assert_eq!(::std::mem::size_of::<InferenceElem>() , 24usize);
    assert_eq!(::std::mem::align_of::<InferenceElem>() , 8usize);
}
impl Clone for InferenceElem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TargetEntry {
    pub xpr: Expr,
    pub expr: *mut Expr,
    pub resno: AttrNumber,
    pub resname: *mut ::std::os::raw::c_char,
    pub ressortgroupref: Index,
    pub resorigtbl: Oid,
    pub resorigcol: AttrNumber,
    pub resjunk: bool_,
}
#[test]
fn bindgen_test_layout_TargetEntry() {
    assert_eq!(::std::mem::size_of::<TargetEntry>() , 48usize);
    assert_eq!(::std::mem::align_of::<TargetEntry>() , 8usize);
}
impl Clone for TargetEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RangeTblRef {
    pub type_: NodeTag,
    pub rtindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTblRef() {
    assert_eq!(::std::mem::size_of::<RangeTblRef>() , 8usize);
    assert_eq!(::std::mem::align_of::<RangeTblRef>() , 4usize);
}
impl Clone for RangeTblRef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JoinExpr {
    pub type_: NodeTag,
    pub jointype: JoinType,
    pub isNatural: bool_,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub usingClause: *mut List,
    pub quals: *mut Node,
    pub alias: *mut Alias,
    pub rtindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_JoinExpr() {
    assert_eq!(::std::mem::size_of::<JoinExpr>() , 64usize);
    assert_eq!(::std::mem::align_of::<JoinExpr>() , 8usize);
}
impl Clone for JoinExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FromExpr {
    pub type_: NodeTag,
    pub fromlist: *mut List,
    pub quals: *mut Node,
}
#[test]
fn bindgen_test_layout_FromExpr() {
    assert_eq!(::std::mem::size_of::<FromExpr>() , 24usize);
    assert_eq!(::std::mem::align_of::<FromExpr>() , 8usize);
}
impl Clone for FromExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OnConflictExpr {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub arbiterElems: *mut List,
    pub arbiterWhere: *mut Node,
    pub constraint: Oid,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelIndex: ::std::os::raw::c_int,
    pub exclRelTlist: *mut List,
}
#[test]
fn bindgen_test_layout_OnConflictExpr() {
    assert_eq!(::std::mem::size_of::<OnConflictExpr>() , 64usize);
    assert_eq!(::std::mem::align_of::<OnConflictExpr>() , 8usize);
}
impl Clone for OnConflictExpr {
    fn clone(&self) -> Self { *self }
}
pub type Item = Pointer;
pub type Page = Pointer;
pub type LocationIndex = uint16;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_50 {
    pub xlogid: uint32,
    pub xrecoff: uint32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_50() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_50>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_50>() , 4usize);
}
impl Clone for _bindgen_ty_50 {
    fn clone(&self) -> Self { *self }
}
pub type PageXLogRecPtr = _bindgen_ty_50;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PageHeaderData {
    pub pd_lsn: PageXLogRecPtr,
    pub pd_checksum: uint16,
    pub pd_flags: uint16,
    pub pd_lower: LocationIndex,
    pub pd_upper: LocationIndex,
    pub pd_special: LocationIndex,
    pub pd_pagesize_version: uint16,
    pub pd_prune_xid: TransactionId,
    pub pd_linp: *mut ItemIdData,
}
#[test]
fn bindgen_test_layout_PageHeaderData() {
    assert_eq!(::std::mem::size_of::<PageHeaderData>() , 24usize);
    assert_eq!(::std::mem::align_of::<PageHeaderData>() , 4usize);
}
impl Clone for PageHeaderData {
    fn clone(&self) -> Self { *self }
}
pub type PageHeader = *mut PageHeaderData;
extern "C" {
    pub fn PageInit(page: Page, pageSize: Size, specialSize: Size);
}
extern "C" {
    pub fn PageIsVerified(page: Page, blkno: BlockNumber) -> bool_;
}
extern "C" {
    pub fn PageAddItem(page: Page, item: Item, size: Size,
                       offsetNumber: OffsetNumber, overwrite: bool_,
                       is_heap: bool_) -> OffsetNumber;
}
extern "C" {
    pub fn PageAddItemExtended(page: Page, item: Item, size: Size,
                               offsetNumber: OffsetNumber,
                               flags: ::std::os::raw::c_int) -> OffsetNumber;
}
extern "C" {
    pub fn PageGetTempPage(page: Page) -> Page;
}
extern "C" {
    pub fn PageGetTempPageCopy(page: Page) -> Page;
}
extern "C" {
    pub fn PageGetTempPageCopySpecial(page: Page) -> Page;
}
extern "C" {
    pub fn PageRestoreTempPage(tempPage: Page, oldPage: Page);
}
extern "C" {
    pub fn PageRepairFragmentation(page: Page);
}
extern "C" {
    pub fn PageGetFreeSpace(page: Page) -> Size;
}
extern "C" {
    pub fn PageGetExactFreeSpace(page: Page) -> Size;
}
extern "C" {
    pub fn PageGetHeapFreeSpace(page: Page) -> Size;
}
extern "C" {
    pub fn PageIndexTupleDelete(page: Page, offset: OffsetNumber);
}
extern "C" {
    pub fn PageIndexMultiDelete(page: Page, itemnos: *mut OffsetNumber,
                                nitems: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PageIndexDeleteNoCompact(page: Page, itemnos: *mut OffsetNumber,
                                    nitems: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PageSetChecksumCopy(page: Page, blkno: BlockNumber)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PageSetChecksumInplace(page: Page, blkno: BlockNumber);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BulkInsertStateData([u8; 0]);
pub type BulkInsertState = *mut BulkInsertStateData;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum LockTupleMode {
    LockTupleKeyShare = 0,
    LockTupleShare = 1,
    LockTupleNoKeyExclusive = 2,
    LockTupleExclusive = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HeapUpdateFailureData {
    pub ctid: ItemPointerData,
    pub xmax: TransactionId,
    pub cmax: CommandId,
}
#[test]
fn bindgen_test_layout_HeapUpdateFailureData() {
    assert_eq!(::std::mem::size_of::<HeapUpdateFailureData>() , 16usize);
    assert_eq!(::std::mem::align_of::<HeapUpdateFailureData>() , 4usize);
}
impl Clone for HeapUpdateFailureData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn try_relation_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn relation_openrv(relation: *const RangeVar, lockmode: LOCKMODE)
     -> Relation;
}
extern "C" {
    pub fn relation_openrv_extended(relation: *const RangeVar,
                                    lockmode: LOCKMODE, missing_ok: bool_)
     -> Relation;
}
extern "C" {
    pub fn relation_close(relation: Relation, lockmode: LOCKMODE);
}
extern "C" {
    pub fn heap_open(relationId: Oid, lockmode: LOCKMODE) -> Relation;
}
extern "C" {
    pub fn heap_openrv(relation: *const RangeVar, lockmode: LOCKMODE)
     -> Relation;
}
extern "C" {
    pub fn heap_openrv_extended(relation: *const RangeVar, lockmode: LOCKMODE,
                                missing_ok: bool_) -> Relation;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapScanDescData([u8; 0]);
pub type HeapScanDesc = *mut HeapScanDescData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParallelHeapScanDescData([u8; 0]);
pub type ParallelHeapScanDesc = *mut ParallelHeapScanDescData;
extern "C" {
    pub fn heap_beginscan(relation: Relation, snapshot: Snapshot,
                          nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_catalog(relation: Relation,
                                  nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_strat(relation: Relation, snapshot: Snapshot,
                                nkeys: ::std::os::raw::c_int, key: ScanKey,
                                allow_strat: bool_, allow_sync: bool_)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_bm(relation: Relation, snapshot: Snapshot,
                             nkeys: ::std::os::raw::c_int, key: ScanKey)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_beginscan_sampling(relation: Relation, snapshot: Snapshot,
                                   nkeys: ::std::os::raw::c_int, key: ScanKey,
                                   allow_strat: bool_, allow_sync: bool_,
                                   allow_pagemode: bool_) -> HeapScanDesc;
}
extern "C" {
    pub fn heap_setscanlimits(scan: HeapScanDesc, startBlk: BlockNumber,
                              endBlk: BlockNumber);
}
extern "C" {
    pub fn heapgetpage(scan: HeapScanDesc, page: BlockNumber);
}
extern "C" {
    pub fn heap_rescan(scan: HeapScanDesc, key: ScanKey);
}
extern "C" {
    pub fn heap_rescan_set_params(scan: HeapScanDesc, key: ScanKey,
                                  allow_strat: bool_, allow_sync: bool_,
                                  allow_pagemode: bool_);
}
extern "C" {
    pub fn heap_endscan(scan: HeapScanDesc);
}
extern "C" {
    pub fn heap_getnext(scan: HeapScanDesc, direction: ScanDirection)
     -> HeapTuple;
}
extern "C" {
    pub fn heap_parallelscan_estimate(snapshot: Snapshot) -> Size;
}
extern "C" {
    pub fn heap_parallelscan_initialize(target: ParallelHeapScanDesc,
                                        relation: Relation,
                                        snapshot: Snapshot);
}
extern "C" {
    pub fn heap_beginscan_parallel(arg1: Relation, arg2: ParallelHeapScanDesc)
     -> HeapScanDesc;
}
extern "C" {
    pub fn heap_fetch(relation: Relation, snapshot: Snapshot,
                      tuple: HeapTuple, userbuf: *mut Buffer, keep_buf: bool_,
                      stats_relation: Relation) -> bool_;
}
extern "C" {
    pub fn heap_hot_search_buffer(tid: ItemPointer, relation: Relation,
                                  buffer: Buffer, snapshot: Snapshot,
                                  heapTuple: HeapTuple, all_dead: *mut bool_,
                                  first_call: bool_) -> bool_;
}
extern "C" {
    pub fn heap_hot_search(tid: ItemPointer, relation: Relation,
                           snapshot: Snapshot, all_dead: *mut bool_) -> bool_;
}
extern "C" {
    pub fn heap_get_latest_tid(relation: Relation, snapshot: Snapshot,
                               tid: ItemPointer);
}
extern "C" {
    pub fn setLastTid(tid: ItemPointer);
}
extern "C" {
    pub fn GetBulkInsertState() -> BulkInsertState;
}
extern "C" {
    pub fn FreeBulkInsertState(arg1: BulkInsertState);
}
extern "C" {
    pub fn heap_insert(relation: Relation, tup: HeapTuple, cid: CommandId,
                       options: ::std::os::raw::c_int,
                       bistate: BulkInsertState) -> Oid;
}
extern "C" {
    pub fn heap_multi_insert(relation: Relation, tuples: *mut HeapTuple,
                             ntuples: ::std::os::raw::c_int, cid: CommandId,
                             options: ::std::os::raw::c_int,
                             bistate: BulkInsertState);
}
extern "C" {
    pub fn heap_delete(relation: Relation, tid: ItemPointer, cid: CommandId,
                       crosscheck: Snapshot, wait: bool_,
                       hufd: *mut HeapUpdateFailureData) -> HTSU_Result;
}
extern "C" {
    pub fn heap_finish_speculative(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    pub fn heap_abort_speculative(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    pub fn heap_update(relation: Relation, otid: ItemPointer,
                       newtup: HeapTuple, cid: CommandId,
                       crosscheck: Snapshot, wait: bool_,
                       hufd: *mut HeapUpdateFailureData,
                       lockmode: *mut LockTupleMode) -> HTSU_Result;
}
extern "C" {
    pub fn heap_lock_tuple(relation: Relation, tuple: HeapTuple,
                           cid: CommandId, mode: LockTupleMode,
                           wait_policy: LockWaitPolicy, follow_update: bool_,
                           buffer: *mut Buffer,
                           hufd: *mut HeapUpdateFailureData) -> HTSU_Result;
}
extern "C" {
    pub fn heap_inplace_update(relation: Relation, tuple: HeapTuple);
}
extern "C" {
    pub fn heap_freeze_tuple(tuple: HeapTupleHeader,
                             cutoff_xid: TransactionId,
                             cutoff_multi: TransactionId) -> bool_;
}
extern "C" {
    pub fn heap_tuple_needs_freeze(tuple: HeapTupleHeader,
                                   cutoff_xid: TransactionId,
                                   cutoff_multi: MultiXactId, buf: Buffer)
     -> bool_;
}
extern "C" {
    pub fn heap_tuple_needs_eventual_freeze(tuple: HeapTupleHeader) -> bool_;
}
extern "C" {
    pub fn simple_heap_insert(relation: Relation, tup: HeapTuple) -> Oid;
}
extern "C" {
    pub fn simple_heap_delete(relation: Relation, tid: ItemPointer);
}
extern "C" {
    pub fn simple_heap_update(relation: Relation, otid: ItemPointer,
                              tup: HeapTuple);
}
extern "C" {
    pub fn heap_sync(relation: Relation);
}
extern "C" {
    pub fn heap_page_prune_opt(relation: Relation, buffer: Buffer);
}
extern "C" {
    pub fn heap_page_prune(relation: Relation, buffer: Buffer,
                           OldestXmin: TransactionId, report_stats: bool_,
                           latestRemovedXid: *mut TransactionId)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heap_page_prune_execute(buffer: Buffer,
                                   redirected: *mut OffsetNumber,
                                   nredirected: ::std::os::raw::c_int,
                                   nowdead: *mut OffsetNumber,
                                   ndead: ::std::os::raw::c_int,
                                   nowunused: *mut OffsetNumber,
                                   nunused: ::std::os::raw::c_int);
}
extern "C" {
    pub fn heap_get_root_tuples(page: Page, root_offsets: *mut OffsetNumber);
}
extern "C" {
    pub fn ss_report_location(rel: Relation, location: BlockNumber);
}
extern "C" {
    pub fn ss_get_location(rel: Relation, relnblocks: BlockNumber)
     -> BlockNumber;
}
extern "C" {
    pub fn SyncScanShmemInit();
}
extern "C" {
    pub fn SyncScanShmemSize() -> Size;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize);
    assert_eq!(::std::mem::align_of::<timezone>() , 4usize);
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval)
     -> ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize);
    assert_eq!(::std::mem::align_of::<itimerval>() , 8usize);
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(__which: __itimer_which_t, __new: *const itimerval,
                     __old: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(__file: *const ::std::os::raw::c_char, __tvp: *mut timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(__file: *const ::std::os::raw::c_char, __tvp: *mut timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *mut timeval)
     -> ::std::os::raw::c_int;
}
pub type instr_time = timeval;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BufferUsage {
    pub shared_blks_hit: ::std::os::raw::c_long,
    pub shared_blks_read: ::std::os::raw::c_long,
    pub shared_blks_dirtied: ::std::os::raw::c_long,
    pub shared_blks_written: ::std::os::raw::c_long,
    pub local_blks_hit: ::std::os::raw::c_long,
    pub local_blks_read: ::std::os::raw::c_long,
    pub local_blks_dirtied: ::std::os::raw::c_long,
    pub local_blks_written: ::std::os::raw::c_long,
    pub temp_blks_read: ::std::os::raw::c_long,
    pub temp_blks_written: ::std::os::raw::c_long,
    pub blk_read_time: instr_time,
    pub blk_write_time: instr_time,
}
#[test]
fn bindgen_test_layout_BufferUsage() {
    assert_eq!(::std::mem::size_of::<BufferUsage>() , 112usize);
    assert_eq!(::std::mem::align_of::<BufferUsage>() , 8usize);
}
impl Clone for BufferUsage {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum InstrumentOption {
    INSTRUMENT_TIMER = 1,
    INSTRUMENT_BUFFERS = 2,
    INSTRUMENT_ROWS = 4,
    INSTRUMENT_ALL = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Instrumentation {
    pub need_timer: bool_,
    pub need_bufusage: bool_,
    pub running: bool_,
    pub starttime: instr_time,
    pub counter: instr_time,
    pub firsttuple: f64,
    pub tuplecount: f64,
    pub bufusage_start: BufferUsage,
    pub startup: f64,
    pub total: f64,
    pub ntuples: f64,
    pub nloops: f64,
    pub nfiltered1: f64,
    pub nfiltered2: f64,
    pub bufusage: BufferUsage,
}
#[test]
fn bindgen_test_layout_Instrumentation() {
    assert_eq!(::std::mem::size_of::<Instrumentation>() , 328usize);
    assert_eq!(::std::mem::align_of::<Instrumentation>() , 8usize);
}
impl Clone for Instrumentation {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WorkerInstrumentation {
    pub num_workers: ::std::os::raw::c_int,
    pub instrument: *mut Instrumentation,
}
#[test]
fn bindgen_test_layout_WorkerInstrumentation() {
    assert_eq!(::std::mem::size_of::<WorkerInstrumentation>() , 8usize);
    assert_eq!(::std::mem::align_of::<WorkerInstrumentation>() , 8usize);
}
impl Clone for WorkerInstrumentation {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "pgBufferUsage"]
    pub static mut pgBufferUsage: BufferUsage;
}
extern "C" {
    pub fn InstrAlloc(n: ::std::os::raw::c_int,
                      instrument_options: ::std::os::raw::c_int)
     -> *mut Instrumentation;
}
extern "C" {
    pub fn InstrInit(instr: *mut Instrumentation,
                     instrument_options: ::std::os::raw::c_int);
}
extern "C" {
    pub fn InstrStartNode(instr: *mut Instrumentation);
}
extern "C" {
    pub fn InstrStopNode(instr: *mut Instrumentation, nTuples: f64);
}
extern "C" {
    pub fn InstrEndLoop(instr: *mut Instrumentation);
}
extern "C" {
    pub fn InstrAggNode(dst: *mut Instrumentation, add: *mut Instrumentation);
}
extern "C" {
    pub fn InstrStartParallelQuery();
}
extern "C" {
    pub fn InstrEndParallelQuery(result: *mut BufferUsage);
}
extern "C" {
    pub fn InstrAccumParallelQuery(result: *mut BufferUsage);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ParseState([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ParamExternData {
    pub value: Datum,
    pub isnull: bool_,
    pub pflags: uint16,
    pub ptype: Oid,
}
#[test]
fn bindgen_test_layout_ParamExternData() {
    assert_eq!(::std::mem::size_of::<ParamExternData>() , 16usize);
    assert_eq!(::std::mem::align_of::<ParamExternData>() , 8usize);
}
impl Clone for ParamExternData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ParamListInfoData {
    pub paramFetch: ParamFetchHook,
    pub paramFetchArg: *mut ::std::os::raw::c_void,
    pub parserSetup: ParserSetupHook,
    pub parserSetupArg: *mut ::std::os::raw::c_void,
    pub numParams: ::std::os::raw::c_int,
    pub paramMask: *mut Bitmapset,
    pub params: *mut ParamExternData,
}
#[test]
fn bindgen_test_layout_ParamListInfoData() {
    assert_eq!(::std::mem::size_of::<ParamListInfoData>() , 48usize);
    assert_eq!(::std::mem::align_of::<ParamListInfoData>() , 8usize);
}
impl Clone for ParamListInfoData {
    fn clone(&self) -> Self { *self }
}
pub type ParamListInfo = *mut ParamListInfoData;
pub type ParamFetchHook =
    ::std::option::Option<unsafe extern "C" fn(params: ParamListInfo,
                                               paramid:
                                                   ::std::os::raw::c_int)>;
pub type ParserSetupHook =
    ::std::option::Option<unsafe extern "C" fn(pstate: *mut ParseState,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ParamExecData {
    pub execPlan: *mut ::std::os::raw::c_void,
    pub value: Datum,
    pub isnull: bool_,
}
#[test]
fn bindgen_test_layout_ParamExecData() {
    assert_eq!(::std::mem::size_of::<ParamExecData>() , 24usize);
    assert_eq!(::std::mem::align_of::<ParamExecData>() , 8usize);
}
impl Clone for ParamExecData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn copyParamList(from: ParamListInfo) -> ParamListInfo;
}
extern "C" {
    pub fn EstimateParamListSpace(paramLI: ParamListInfo) -> Size;
}
extern "C" {
    pub fn SerializeParamList(paramLI: ParamListInfo,
                              start_address:
                                  *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn RestoreParamList(start_address: *mut *mut ::std::os::raw::c_char)
     -> ParamListInfo;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlannedStmt {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub queryId: uint32,
    pub hasReturning: bool_,
    pub hasModifyingCTE: bool_,
    pub canSetTag: bool_,
    pub transientPlan: bool_,
    pub dependsOnRole: bool_,
    pub parallelModeNeeded: bool_,
    pub planTree: *mut PlannedStmt_Plan,
    pub rtable: *mut List,
    pub resultRelations: *mut List,
    pub utilityStmt: *mut Node,
    pub subplans: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub nParamExec: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlannedStmt_Plan {
    pub type_: NodeTag,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub plan_rows: f64,
    pub plan_width: ::std::os::raw::c_int,
    pub parallel_aware: bool_,
    pub plan_node_id: ::std::os::raw::c_int,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut PlannedStmt_Plan,
    pub righttree: *mut PlannedStmt_Plan,
    pub initPlan: *mut List,
    pub extParam: *mut Bitmapset,
    pub allParam: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_PlannedStmt_Plan() {
    assert_eq!(::std::mem::size_of::<PlannedStmt_Plan>() , 104usize);
    assert_eq!(::std::mem::align_of::<PlannedStmt_Plan>() , 8usize);
}
impl Clone for PlannedStmt_Plan {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PlannedStmt() {
    assert_eq!(::std::mem::size_of::<PlannedStmt>() , 104usize);
    assert_eq!(::std::mem::align_of::<PlannedStmt>() , 8usize);
}
impl Clone for PlannedStmt {
    fn clone(&self) -> Self { *self }
}
pub type Plan = PlannedStmt_Plan;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Result {
    pub plan: Plan,
    pub resconstantqual: *mut Node,
}
#[test]
fn bindgen_test_layout_Result() {
    assert_eq!(::std::mem::size_of::<Result>() , 112usize);
    assert_eq!(::std::mem::align_of::<Result>() , 8usize);
}
impl Clone for Result {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModifyTable {
    pub plan: Plan,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub nominalRelation: Index,
    pub resultRelations: *mut List,
    pub resultRelIndex: ::std::os::raw::c_int,
    pub plans: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub fdwPrivLists: *mut List,
    pub fdwDirectModifyPlans: *mut Bitmapset,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
    pub onConflictAction: OnConflictAction,
    pub arbiterIndexes: *mut List,
    pub onConflictSet: *mut List,
    pub onConflictWhere: *mut Node,
    pub exclRelRTI: Index,
    pub exclRelTlist: *mut List,
}
#[test]
fn bindgen_test_layout_ModifyTable() {
    assert_eq!(::std::mem::size_of::<ModifyTable>() , 232usize);
    assert_eq!(::std::mem::align_of::<ModifyTable>() , 8usize);
}
impl Clone for ModifyTable {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Append {
    pub plan: Plan,
    pub appendplans: *mut List,
}
#[test]
fn bindgen_test_layout_Append() {
    assert_eq!(::std::mem::size_of::<Append>() , 112usize);
    assert_eq!(::std::mem::align_of::<Append>() , 8usize);
}
impl Clone for Append {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MergeAppend {
    pub plan: Plan,
    pub mergeplans: *mut List,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool_,
}
#[test]
fn bindgen_test_layout_MergeAppend() {
    assert_eq!(::std::mem::size_of::<MergeAppend>() , 152usize);
    assert_eq!(::std::mem::align_of::<MergeAppend>() , 8usize);
}
impl Clone for MergeAppend {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RecursiveUnion {
    pub plan: Plan,
    pub wtParam: ::std::os::raw::c_int,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_RecursiveUnion() {
    assert_eq!(::std::mem::size_of::<RecursiveUnion>() , 136usize);
    assert_eq!(::std::mem::align_of::<RecursiveUnion>() , 8usize);
}
impl Clone for RecursiveUnion {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapAnd {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapAnd() {
    assert_eq!(::std::mem::size_of::<BitmapAnd>() , 112usize);
    assert_eq!(::std::mem::align_of::<BitmapAnd>() , 8usize);
}
impl Clone for BitmapAnd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapOr {
    pub plan: Plan,
    pub bitmapplans: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapOr() {
    assert_eq!(::std::mem::size_of::<BitmapOr>() , 112usize);
    assert_eq!(::std::mem::align_of::<BitmapOr>() , 8usize);
}
impl Clone for BitmapOr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Scan {
    pub plan: Plan,
    pub scanrelid: Index,
}
#[test]
fn bindgen_test_layout_Scan() {
    assert_eq!(::std::mem::size_of::<Scan>() , 112usize);
    assert_eq!(::std::mem::align_of::<Scan>() , 8usize);
}
impl Clone for Scan {
    fn clone(&self) -> Self { *self }
}
pub type SeqScan = Scan;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SampleScan {
    pub scan: Scan,
    pub tablesample: *mut SampleScan_TableSampleClause,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SampleScan_TableSampleClause {
    pub type_: NodeTag,
    pub tsmhandler: Oid,
    pub args: *mut List,
    pub repeatable: *mut Expr,
}
#[test]
fn bindgen_test_layout_SampleScan_TableSampleClause() {
    assert_eq!(::std::mem::size_of::<SampleScan_TableSampleClause>() ,
               24usize);
    assert_eq!(::std::mem::align_of::<SampleScan_TableSampleClause>() ,
               8usize);
}
impl Clone for SampleScan_TableSampleClause {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_SampleScan() {
    assert_eq!(::std::mem::size_of::<SampleScan>() , 120usize);
    assert_eq!(::std::mem::align_of::<SampleScan>() , 8usize);
}
impl Clone for SampleScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
    pub indexorderby: *mut List,
    pub indexorderbyorig: *mut List,
    pub indexorderbyops: *mut List,
    pub indexorderdir: ScanDirection,
}
#[test]
fn bindgen_test_layout_IndexScan() {
    assert_eq!(::std::mem::size_of::<IndexScan>() , 168usize);
    assert_eq!(::std::mem::align_of::<IndexScan>() , 8usize);
}
impl Clone for IndexScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexOnlyScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexorderby: *mut List,
    pub indextlist: *mut List,
    pub indexorderdir: ScanDirection,
}
#[test]
fn bindgen_test_layout_IndexOnlyScan() {
    assert_eq!(::std::mem::size_of::<IndexOnlyScan>() , 152usize);
    assert_eq!(::std::mem::align_of::<IndexOnlyScan>() , 8usize);
}
impl Clone for IndexOnlyScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapIndexScan {
    pub scan: Scan,
    pub indexid: Oid,
    pub indexqual: *mut List,
    pub indexqualorig: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapIndexScan() {
    assert_eq!(::std::mem::size_of::<BitmapIndexScan>() , 136usize);
    assert_eq!(::std::mem::align_of::<BitmapIndexScan>() , 8usize);
}
impl Clone for BitmapIndexScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapHeapScan {
    pub scan: Scan,
    pub bitmapqualorig: *mut List,
}
#[test]
fn bindgen_test_layout_BitmapHeapScan() {
    assert_eq!(::std::mem::size_of::<BitmapHeapScan>() , 120usize);
    assert_eq!(::std::mem::align_of::<BitmapHeapScan>() , 8usize);
}
impl Clone for BitmapHeapScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TidScan {
    pub scan: Scan,
    pub tidquals: *mut List,
}
#[test]
fn bindgen_test_layout_TidScan() {
    assert_eq!(::std::mem::size_of::<TidScan>() , 120usize);
    assert_eq!(::std::mem::align_of::<TidScan>() , 8usize);
}
impl Clone for TidScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SubqueryScan {
    pub scan: Scan,
    pub subplan: *mut Plan,
}
#[test]
fn bindgen_test_layout_SubqueryScan() {
    assert_eq!(::std::mem::size_of::<SubqueryScan>() , 120usize);
    assert_eq!(::std::mem::align_of::<SubqueryScan>() , 8usize);
}
impl Clone for SubqueryScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FunctionScan {
    pub scan: Scan,
    pub functions: *mut List,
    pub funcordinality: bool_,
}
#[test]
fn bindgen_test_layout_FunctionScan() {
    assert_eq!(::std::mem::size_of::<FunctionScan>() , 128usize);
    assert_eq!(::std::mem::align_of::<FunctionScan>() , 8usize);
}
impl Clone for FunctionScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ValuesScan {
    pub scan: Scan,
    pub values_lists: *mut List,
}
#[test]
fn bindgen_test_layout_ValuesScan() {
    assert_eq!(::std::mem::size_of::<ValuesScan>() , 120usize);
    assert_eq!(::std::mem::align_of::<ValuesScan>() , 8usize);
}
impl Clone for ValuesScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CteScan {
    pub scan: Scan,
    pub ctePlanId: ::std::os::raw::c_int,
    pub cteParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CteScan() {
    assert_eq!(::std::mem::size_of::<CteScan>() , 120usize);
    assert_eq!(::std::mem::align_of::<CteScan>() , 8usize);
}
impl Clone for CteScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WorkTableScan {
    pub scan: Scan,
    pub wtParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WorkTableScan() {
    assert_eq!(::std::mem::size_of::<WorkTableScan>() , 120usize);
    assert_eq!(::std::mem::align_of::<WorkTableScan>() , 8usize);
}
impl Clone for WorkTableScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignScan {
    pub scan: Scan,
    pub operation: CmdType,
    pub fs_server: Oid,
    pub fdw_exprs: *mut List,
    pub fdw_private: *mut List,
    pub fdw_scan_tlist: *mut List,
    pub fdw_recheck_quals: *mut List,
    pub fs_relids: *mut Bitmapset,
    pub fsSystemCol: bool_,
}
#[test]
fn bindgen_test_layout_ForeignScan() {
    assert_eq!(::std::mem::size_of::<ForeignScan>() , 168usize);
    assert_eq!(::std::mem::align_of::<ForeignScan>() , 8usize);
}
impl Clone for ForeignScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomScanMethods([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CustomScan {
    pub scan: Scan,
    pub flags: uint32,
    pub custom_plans: *mut List,
    pub custom_exprs: *mut List,
    pub custom_private: *mut List,
    pub custom_scan_tlist: *mut List,
    pub custom_relids: *mut Bitmapset,
    pub methods: *const CustomScanMethods,
}
#[test]
fn bindgen_test_layout_CustomScan() {
    assert_eq!(::std::mem::size_of::<CustomScan>() , 168usize);
    assert_eq!(::std::mem::align_of::<CustomScan>() , 8usize);
}
impl Clone for CustomScan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Join {
    pub plan: Plan,
    pub jointype: JoinType,
    pub joinqual: *mut List,
}
#[test]
fn bindgen_test_layout_Join() {
    assert_eq!(::std::mem::size_of::<Join>() , 120usize);
    assert_eq!(::std::mem::align_of::<Join>() , 8usize);
}
impl Clone for Join {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NestLoop {
    pub join: Join,
    pub nestParams: *mut List,
}
#[test]
fn bindgen_test_layout_NestLoop() {
    assert_eq!(::std::mem::size_of::<NestLoop>() , 128usize);
    assert_eq!(::std::mem::align_of::<NestLoop>() , 8usize);
}
impl Clone for NestLoop {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NestLoopParam {
    pub type_: NodeTag,
    pub paramno: ::std::os::raw::c_int,
    pub paramval: *mut Var,
}
#[test]
fn bindgen_test_layout_NestLoopParam() {
    assert_eq!(::std::mem::size_of::<NestLoopParam>() , 16usize);
    assert_eq!(::std::mem::align_of::<NestLoopParam>() , 8usize);
}
impl Clone for NestLoopParam {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MergeJoin {
    pub join: Join,
    pub mergeclauses: *mut List,
    pub mergeFamilies: *mut Oid,
    pub mergeCollations: *mut Oid,
    pub mergeStrategies: *mut ::std::os::raw::c_int,
    pub mergeNullsFirst: *mut bool_,
}
#[test]
fn bindgen_test_layout_MergeJoin() {
    assert_eq!(::std::mem::size_of::<MergeJoin>() , 160usize);
    assert_eq!(::std::mem::align_of::<MergeJoin>() , 8usize);
}
impl Clone for MergeJoin {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HashJoin {
    pub join: Join,
    pub hashclauses: *mut List,
}
#[test]
fn bindgen_test_layout_HashJoin() {
    assert_eq!(::std::mem::size_of::<HashJoin>() , 128usize);
    assert_eq!(::std::mem::align_of::<HashJoin>() , 8usize);
}
impl Clone for HashJoin {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Material {
    pub plan: Plan,
}
#[test]
fn bindgen_test_layout_Material() {
    assert_eq!(::std::mem::size_of::<Material>() , 104usize);
    assert_eq!(::std::mem::align_of::<Material>() , 8usize);
}
impl Clone for Material {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Sort {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub sortColIdx: *mut AttrNumber,
    pub sortOperators: *mut Oid,
    pub collations: *mut Oid,
    pub nullsFirst: *mut bool_,
}
#[test]
fn bindgen_test_layout_Sort() {
    assert_eq!(::std::mem::size_of::<Sort>() , 144usize);
    assert_eq!(::std::mem::align_of::<Sort>() , 8usize);
}
impl Clone for Sort {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Group {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
}
#[test]
fn bindgen_test_layout_Group() {
    assert_eq!(::std::mem::size_of::<Group>() , 128usize);
    assert_eq!(::std::mem::align_of::<Group>() , 8usize);
}
impl Clone for Group {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Agg {
    pub plan: Plan,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numCols: ::std::os::raw::c_int,
    pub grpColIdx: *mut AttrNumber,
    pub grpOperators: *mut Oid,
    pub numGroups: ::std::os::raw::c_long,
    pub aggParams: *mut Bitmapset,
    pub groupingSets: *mut List,
    pub chain: *mut List,
}
#[test]
fn bindgen_test_layout_Agg() {
    assert_eq!(::std::mem::size_of::<Agg>() , 168usize);
    assert_eq!(::std::mem::align_of::<Agg>() , 8usize);
}
impl Clone for Agg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WindowAgg {
    pub plan: Plan,
    pub winref: Index,
    pub partNumCols: ::std::os::raw::c_int,
    pub partColIdx: *mut AttrNumber,
    pub partOperators: *mut Oid,
    pub ordNumCols: ::std::os::raw::c_int,
    pub ordColIdx: *mut AttrNumber,
    pub ordOperators: *mut Oid,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
}
#[test]
fn bindgen_test_layout_WindowAgg() {
    assert_eq!(::std::mem::size_of::<WindowAgg>() , 176usize);
    assert_eq!(::std::mem::align_of::<WindowAgg>() , 8usize);
}
impl Clone for WindowAgg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Unique {
    pub plan: Plan,
    pub numCols: ::std::os::raw::c_int,
    pub uniqColIdx: *mut AttrNumber,
    pub uniqOperators: *mut Oid,
}
#[test]
fn bindgen_test_layout_Unique() {
    assert_eq!(::std::mem::size_of::<Unique>() , 128usize);
    assert_eq!(::std::mem::align_of::<Unique>() , 8usize);
}
impl Clone for Unique {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Gather {
    pub plan: Plan,
    pub num_workers: ::std::os::raw::c_int,
    pub single_copy: bool_,
    pub invisible: bool_,
}
#[test]
fn bindgen_test_layout_Gather() {
    assert_eq!(::std::mem::size_of::<Gather>() , 112usize);
    assert_eq!(::std::mem::align_of::<Gather>() , 8usize);
}
impl Clone for Gather {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Hash {
    pub plan: Plan,
    pub skewTable: Oid,
    pub skewColumn: AttrNumber,
    pub skewInherit: bool_,
    pub skewColType: Oid,
    pub skewColTypmod: int32,
}
#[test]
fn bindgen_test_layout_Hash() {
    assert_eq!(::std::mem::size_of::<Hash>() , 120usize);
    assert_eq!(::std::mem::align_of::<Hash>() , 8usize);
}
impl Clone for Hash {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SetOp {
    pub plan: Plan,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub numCols: ::std::os::raw::c_int,
    pub dupColIdx: *mut AttrNumber,
    pub dupOperators: *mut Oid,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_SetOp() {
    assert_eq!(::std::mem::size_of::<SetOp>() , 152usize);
    assert_eq!(::std::mem::align_of::<SetOp>() , 8usize);
}
impl Clone for SetOp {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockRows {
    pub plan: Plan,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRows() {
    assert_eq!(::std::mem::size_of::<LockRows>() , 120usize);
    assert_eq!(::std::mem::align_of::<LockRows>() , 8usize);
}
impl Clone for LockRows {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Limit {
    pub plan: Plan,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
}
#[test]
fn bindgen_test_layout_Limit() {
    assert_eq!(::std::mem::size_of::<Limit>() , 120usize);
    assert_eq!(::std::mem::align_of::<Limit>() , 8usize);
}
impl Clone for Limit {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RowMarkType {
    ROW_MARK_EXCLUSIVE = 0,
    ROW_MARK_NOKEYEXCLUSIVE = 1,
    ROW_MARK_SHARE = 2,
    ROW_MARK_KEYSHARE = 3,
    ROW_MARK_REFERENCE = 4,
    ROW_MARK_COPY = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlanRowMark {
    pub type_: NodeTag,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub allMarkTypes: ::std::os::raw::c_int,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub isParent: bool_,
}
#[test]
fn bindgen_test_layout_PlanRowMark() {
    assert_eq!(::std::mem::size_of::<PlanRowMark>() , 36usize);
    assert_eq!(::std::mem::align_of::<PlanRowMark>() , 4usize);
}
impl Clone for PlanRowMark {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlanInvalItem {
    pub type_: NodeTag,
    pub cacheId: ::std::os::raw::c_int,
    pub hashValue: uint32,
}
#[test]
fn bindgen_test_layout_PlanInvalItem() {
    assert_eq!(::std::mem::size_of::<PlanInvalItem>() , 12usize);
    assert_eq!(::std::mem::align_of::<PlanInvalItem>() , 4usize);
}
impl Clone for PlanInvalItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Trigger {
    pub tgoid: Oid,
    pub tgname: *mut ::std::os::raw::c_char,
    pub tgfoid: Oid,
    pub tgtype: int16,
    pub tgenabled: ::std::os::raw::c_char,
    pub tgisinternal: bool_,
    pub tgconstrrelid: Oid,
    pub tgconstrindid: Oid,
    pub tgconstraint: Oid,
    pub tgdeferrable: bool_,
    pub tginitdeferred: bool_,
    pub tgnargs: int16,
    pub tgnattr: int16,
    pub tgattr: *mut int16,
    pub tgargs: *mut *mut ::std::os::raw::c_char,
    pub tgqual: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Trigger() {
    assert_eq!(::std::mem::size_of::<Trigger>() , 72usize);
    assert_eq!(::std::mem::align_of::<Trigger>() , 8usize);
}
impl Clone for Trigger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TriggerDesc {
    pub triggers: *mut Trigger,
    pub numtriggers: ::std::os::raw::c_int,
    pub trig_insert_before_row: bool_,
    pub trig_insert_after_row: bool_,
    pub trig_insert_instead_row: bool_,
    pub trig_insert_before_statement: bool_,
    pub trig_insert_after_statement: bool_,
    pub trig_update_before_row: bool_,
    pub trig_update_after_row: bool_,
    pub trig_update_instead_row: bool_,
    pub trig_update_before_statement: bool_,
    pub trig_update_after_statement: bool_,
    pub trig_delete_before_row: bool_,
    pub trig_delete_after_row: bool_,
    pub trig_delete_instead_row: bool_,
    pub trig_delete_before_statement: bool_,
    pub trig_delete_after_statement: bool_,
    pub trig_truncate_before_statement: bool_,
    pub trig_truncate_after_statement: bool_,
}
#[test]
fn bindgen_test_layout_TriggerDesc() {
    assert_eq!(::std::mem::size_of::<TriggerDesc>() , 32usize);
    assert_eq!(::std::mem::align_of::<TriggerDesc>() , 8usize);
}
impl Clone for TriggerDesc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SortSupportData {
    pub ssup_cxt: MemoryContext,
    pub ssup_collation: Oid,
    pub ssup_reverse: bool_,
    pub ssup_nulls_first: bool_,
    pub ssup_attno: AttrNumber,
    pub ssup_extra: *mut ::std::os::raw::c_void,
    pub comparator: ::std::option::Option<unsafe extern "C" fn(x: Datum,
                                                               y: Datum,
                                                               ssup:
                                                                   SortSupport)
                                              -> ::std::os::raw::c_int>,
    pub abbreviate: bool_,
    pub abbrev_converter: ::std::option::Option<unsafe extern "C" fn(original:
                                                                         Datum,
                                                                     ssup:
                                                                         SortSupport)
                                                    ->
                                                        ::std::os::raw::c_ulong>,
    pub abbrev_abort: ::std::option::Option<unsafe extern "C" fn(memtupcount:
                                                                     ::std::os::raw::c_int,
                                                                 ssup:
                                                                     SortSupport)
                                                -> ::std::os::raw::c_char>,
    pub abbrev_full_comparator: ::std::option::Option<unsafe extern "C" fn(x:
                                                                               Datum,
                                                                           y:
                                                                               Datum,
                                                                           ssup:
                                                                               SortSupport)
                                                          ->
                                                              ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_SortSupportData() {
    assert_eq!(::std::mem::size_of::<SortSupportData>() , 64usize);
    assert_eq!(::std::mem::align_of::<SortSupportData>() , 8usize);
}
impl Clone for SortSupportData {
    fn clone(&self) -> Self { *self }
}
pub type SortSupport = *mut SortSupportData;
extern "C" {
    pub fn PrepareSortSupportComparisonShim(cmpFunc: Oid, ssup: SortSupport);
}
extern "C" {
    pub fn PrepareSortSupportFromOrderingOp(orderingOp: Oid,
                                            ssup: SortSupport);
}
extern "C" {
    pub fn PrepareSortSupportFromIndexRel(indexRel: Relation, strategy: int16,
                                          ssup: SortSupport);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TupleTableSlot {
    pub type_: NodeTag,
    pub tts_isempty: bool_,
    pub tts_shouldFree: bool_,
    pub tts_shouldFreeMin: bool_,
    pub tts_slow: bool_,
    pub tts_tuple: HeapTuple,
    pub tts_tupleDescriptor: TupleDesc,
    pub tts_mcxt: MemoryContext,
    pub tts_buffer: Buffer,
    pub tts_nvalid: ::std::os::raw::c_int,
    pub tts_values: *mut Datum,
    pub tts_isnull: *mut bool_,
    pub tts_mintuple: MinimalTuple,
    pub tts_minhdr: HeapTupleData,
    pub tts_off: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_TupleTableSlot() {
    assert_eq!(::std::mem::size_of::<TupleTableSlot>() , 96usize);
    assert_eq!(::std::mem::align_of::<TupleTableSlot>() , 8usize);
}
impl Clone for TupleTableSlot {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn MakeTupleTableSlot() -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecAllocTableSlot(tupleTable: *mut *mut List)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecResetTupleTable(tupleTable: *mut List, shouldFree: bool_);
}
extern "C" {
    pub fn MakeSingleTupleTableSlot(tupdesc: TupleDesc)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecDropSingleTupleTableSlot(slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn ExecSetSlotDescriptor(slot: *mut TupleTableSlot,
                                 tupdesc: TupleDesc);
}
extern "C" {
    pub fn ExecStoreTuple(tuple: HeapTuple, slot: *mut TupleTableSlot,
                          buffer: Buffer, shouldFree: bool_)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecStoreMinimalTuple(mtup: MinimalTuple,
                                 slot: *mut TupleTableSlot, shouldFree: bool_)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecClearTuple(slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecStoreVirtualTuple(slot: *mut TupleTableSlot)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecStoreAllNullTuple(slot: *mut TupleTableSlot)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecCopySlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    pub fn ExecCopySlotMinimalTuple(slot: *mut TupleTableSlot)
     -> MinimalTuple;
}
extern "C" {
    pub fn ExecFetchSlotTuple(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    pub fn ExecFetchSlotMinimalTuple(slot: *mut TupleTableSlot)
     -> MinimalTuple;
}
extern "C" {
    pub fn ExecFetchSlotTupleDatum(slot: *mut TupleTableSlot) -> Datum;
}
extern "C" {
    pub fn ExecMaterializeSlot(slot: *mut TupleTableSlot) -> HeapTuple;
}
extern "C" {
    pub fn ExecCopySlot(dstslot: *mut TupleTableSlot,
                        srcslot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn slot_getattr(slot: *mut TupleTableSlot,
                        attnum: ::std::os::raw::c_int, isnull: *mut bool_)
     -> Datum;
}
extern "C" {
    pub fn slot_getallattrs(slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn slot_getsomeattrs(slot: *mut TupleTableSlot,
                             attnum: ::std::os::raw::c_int);
}
extern "C" {
    pub fn slot_attisnull(slot: *mut TupleTableSlot,
                          attnum: ::std::os::raw::c_int) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplestorestate([u8; 0]);
extern "C" {
    pub fn tuplestore_begin_heap(randomAccess: bool_, interXact: bool_,
                                 maxKBytes: ::std::os::raw::c_int)
     -> *mut Tuplestorestate;
}
extern "C" {
    pub fn tuplestore_set_eflags(state: *mut Tuplestorestate,
                                 eflags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tuplestore_puttupleslot(state: *mut Tuplestorestate,
                                   slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn tuplestore_puttuple(state: *mut Tuplestorestate, tuple: HeapTuple);
}
extern "C" {
    pub fn tuplestore_putvalues(state: *mut Tuplestorestate, tdesc: TupleDesc,
                                values: *mut Datum, isnull: *mut bool_);
}
extern "C" {
    pub fn tuplestore_alloc_read_pointer(state: *mut Tuplestorestate,
                                         eflags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tuplestore_select_read_pointer(state: *mut Tuplestorestate,
                                          ptr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tuplestore_copy_read_pointer(state: *mut Tuplestorestate,
                                        srcptr: ::std::os::raw::c_int,
                                        destptr: ::std::os::raw::c_int);
}
extern "C" {
    pub fn tuplestore_trim(state: *mut Tuplestorestate);
}
extern "C" {
    pub fn tuplestore_in_memory(state: *mut Tuplestorestate) -> bool_;
}
extern "C" {
    pub fn tuplestore_gettupleslot(state: *mut Tuplestorestate,
                                   forward: bool_, copy: bool_,
                                   slot: *mut TupleTableSlot) -> bool_;
}
extern "C" {
    pub fn tuplestore_advance(state: *mut Tuplestorestate, forward: bool_)
     -> bool_;
}
extern "C" {
    pub fn tuplestore_skiptuples(state: *mut Tuplestorestate, ntuples: int64,
                                 forward: bool_) -> bool_;
}
extern "C" {
    pub fn tuplestore_ateof(state: *mut Tuplestorestate) -> bool_;
}
extern "C" {
    pub fn tuplestore_rescan(state: *mut Tuplestorestate);
}
extern "C" {
    pub fn tuplestore_clear(state: *mut Tuplestorestate);
}
extern "C" {
    pub fn tuplestore_end(state: *mut Tuplestorestate);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexTupleData {
    pub t_tid: ItemPointerData,
    pub t_info: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_IndexTupleData() {
    assert_eq!(::std::mem::size_of::<IndexTupleData>() , 8usize);
    assert_eq!(::std::mem::align_of::<IndexTupleData>() , 2usize);
}
impl Clone for IndexTupleData {
    fn clone(&self) -> Self { *self }
}
pub type IndexTuple = *mut IndexTupleData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexAttributeBitMapData {
    pub bits: [bits8; 4usize],
}
#[test]
fn bindgen_test_layout_IndexAttributeBitMapData() {
    assert_eq!(::std::mem::size_of::<IndexAttributeBitMapData>() , 4usize);
    assert_eq!(::std::mem::align_of::<IndexAttributeBitMapData>() , 1usize);
}
impl Clone for IndexAttributeBitMapData {
    fn clone(&self) -> Self { *self }
}
pub type IndexAttributeBitMap = *mut IndexAttributeBitMapData;
extern "C" {
    pub fn index_form_tuple(tupleDescriptor: TupleDesc, values: *mut Datum,
                            isnull: *mut bool_) -> IndexTuple;
}
extern "C" {
    pub fn nocache_index_getattr(tup: IndexTuple,
                                 attnum: ::std::os::raw::c_int,
                                 tupleDesc: TupleDesc) -> Datum;
}
extern "C" {
    pub fn index_deform_tuple(tup: IndexTuple, tupleDescriptor: TupleDesc,
                              values: *mut Datum, isnull: *mut bool_);
}
extern "C" {
    pub fn CopyIndexTuple(source: IndexTuple) -> IndexTuple;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuplesortstate([u8; 0]);
extern "C" {
    pub fn tuplesort_begin_heap(tupDesc: TupleDesc,
                                nkeys: ::std::os::raw::c_int,
                                attNums: *mut AttrNumber,
                                sortOperators: *mut Oid,
                                sortCollations: *mut Oid,
                                nullsFirstFlags: *mut bool_,
                                workMem: ::std::os::raw::c_int,
                                randomAccess: bool_) -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_cluster(tupDesc: TupleDesc, indexRel: Relation,
                                   workMem: ::std::os::raw::c_int,
                                   randomAccess: bool_)
     -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_index_btree(heapRel: Relation, indexRel: Relation,
                                       enforceUnique: bool_,
                                       workMem: ::std::os::raw::c_int,
                                       randomAccess: bool_)
     -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_index_hash(heapRel: Relation, indexRel: Relation,
                                      hash_mask: uint32,
                                      workMem: ::std::os::raw::c_int,
                                      randomAccess: bool_)
     -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_begin_datum(datumType: Oid, sortOperator: Oid,
                                 sortCollation: Oid, nullsFirstFlag: bool_,
                                 workMem: ::std::os::raw::c_int,
                                 randomAccess: bool_) -> *mut Tuplesortstate;
}
extern "C" {
    pub fn tuplesort_set_bound(state: *mut Tuplesortstate, bound: int64);
}
extern "C" {
    pub fn tuplesort_puttupleslot(state: *mut Tuplesortstate,
                                  slot: *mut TupleTableSlot);
}
extern "C" {
    pub fn tuplesort_putheaptuple(state: *mut Tuplesortstate, tup: HeapTuple);
}
extern "C" {
    pub fn tuplesort_putindextuplevalues(state: *mut Tuplesortstate,
                                         rel: Relation, self_: ItemPointer,
                                         values: *mut Datum,
                                         isnull: *mut bool_);
}
extern "C" {
    pub fn tuplesort_putdatum(state: *mut Tuplesortstate, val: Datum,
                              isNull: bool_);
}
extern "C" {
    pub fn tuplesort_performsort(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_gettupleslot(state: *mut Tuplesortstate, forward: bool_,
                                  slot: *mut TupleTableSlot,
                                  abbrev: *mut Datum) -> bool_;
}
extern "C" {
    pub fn tuplesort_getheaptuple(state: *mut Tuplesortstate, forward: bool_,
                                  should_free: *mut bool_) -> HeapTuple;
}
extern "C" {
    pub fn tuplesort_getindextuple(state: *mut Tuplesortstate, forward: bool_,
                                   should_free: *mut bool_) -> IndexTuple;
}
extern "C" {
    pub fn tuplesort_getdatum(state: *mut Tuplesortstate, forward: bool_,
                              val: *mut Datum, isNull: *mut bool_,
                              abbrev: *mut Datum) -> bool_;
}
extern "C" {
    pub fn tuplesort_skiptuples(state: *mut Tuplesortstate, ntuples: int64,
                                forward: bool_) -> bool_;
}
extern "C" {
    pub fn tuplesort_end(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_get_stats(state: *mut Tuplesortstate,
                               sortMethod: *mut *const ::std::os::raw::c_char,
                               spaceType: *mut *const ::std::os::raw::c_char,
                               spaceUsed: *mut ::std::os::raw::c_long);
}
extern "C" {
    pub fn tuplesort_merge_order(allowedMem: int64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tuplesort_rescan(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_markpos(state: *mut Tuplesortstate);
}
extern "C" {
    pub fn tuplesort_restorepos(state: *mut Tuplesortstate);
}
pub type ExprContextCallbackFunction =
    ::std::option::Option<unsafe extern "C" fn(arg: Datum)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExprContext_CB {
    pub next: *mut ExprContext_CB,
    pub function: ExprContextCallbackFunction,
    pub arg: Datum,
}
#[test]
fn bindgen_test_layout_ExprContext_CB() {
    assert_eq!(::std::mem::size_of::<ExprContext_CB>() , 24usize);
    assert_eq!(::std::mem::align_of::<ExprContext_CB>() , 8usize);
}
impl Clone for ExprContext_CB {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExprContext {
    pub type_: NodeTag,
    pub ecxt_scantuple: *mut TupleTableSlot,
    pub ecxt_innertuple: *mut TupleTableSlot,
    pub ecxt_outertuple: *mut TupleTableSlot,
    pub ecxt_per_query_memory: MemoryContext,
    pub ecxt_per_tuple_memory: MemoryContext,
    pub ecxt_param_exec_vals: *mut ParamExecData,
    pub ecxt_param_list_info: ParamListInfo,
    pub ecxt_aggvalues: *mut Datum,
    pub ecxt_aggnulls: *mut bool_,
    pub caseValue_datum: Datum,
    pub caseValue_isNull: bool_,
    pub domainValue_datum: Datum,
    pub domainValue_isNull: bool_,
    pub ecxt_estate: *mut ExprContext_EState,
    pub ecxt_callbacks: *mut ExprContext_CB,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExprContext_EState {
    pub type_: NodeTag,
    pub es_direction: ScanDirection,
    pub es_snapshot: Snapshot,
    pub es_crosscheck_snapshot: Snapshot,
    pub es_range_table: *mut List,
    pub es_plannedstmt: *mut PlannedStmt,
    pub es_junkFilter: *mut JunkFilter,
    pub es_output_cid: CommandId,
    pub es_result_relations: *mut ResultRelInfo,
    pub es_num_result_relations: ::std::os::raw::c_int,
    pub es_result_relation_info: *mut ResultRelInfo,
    pub es_trig_target_relations: *mut List,
    pub es_trig_tuple_slot: *mut TupleTableSlot,
    pub es_trig_oldtup_slot: *mut TupleTableSlot,
    pub es_trig_newtup_slot: *mut TupleTableSlot,
    pub es_param_list_info: ParamListInfo,
    pub es_param_exec_vals: *mut ParamExecData,
    pub es_query_cxt: MemoryContext,
    pub es_tupleTable: *mut List,
    pub es_rowMarks: *mut List,
    pub es_processed: uint64,
    pub es_lastoid: Oid,
    pub es_top_eflags: ::std::os::raw::c_int,
    pub es_instrument: ::std::os::raw::c_int,
    pub es_finished: bool_,
    pub es_exprcontexts: *mut List,
    pub es_subplanstates: *mut List,
    pub es_auxmodifytables: *mut List,
    pub es_per_tuple_exprcontext: *mut ExprContext,
    pub es_epqTuple: *mut HeapTuple,
    pub es_epqTupleSet: *mut bool_,
    pub es_epqScanDone: *mut bool_,
}
#[test]
fn bindgen_test_layout_ExprContext_EState() {
    assert_eq!(::std::mem::size_of::<ExprContext_EState>() , 232usize);
    assert_eq!(::std::mem::align_of::<ExprContext_EState>() , 8usize);
}
impl Clone for ExprContext_EState {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ExprContext() {
    assert_eq!(::std::mem::size_of::<ExprContext>() , 128usize);
    assert_eq!(::std::mem::align_of::<ExprContext>() , 8usize);
}
impl Clone for ExprContext {
    fn clone(&self) -> Self { *self }
}
pub const ExprSingleResult: _bindgen_ty_51 = _bindgen_ty_51::ExprSingleResult;
pub const ExprMultipleResult: _bindgen_ty_51 =
    _bindgen_ty_51::ExprMultipleResult;
pub const ExprEndResult: _bindgen_ty_51 = _bindgen_ty_51::ExprEndResult;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_51 {
    ExprSingleResult = 0,
    ExprMultipleResult = 1,
    ExprEndResult = 2,
}
pub use self::_bindgen_ty_51 as ExprDoneCond;
pub const SFRM_ValuePerCall: _bindgen_ty_52 =
    _bindgen_ty_52::SFRM_ValuePerCall;
pub const SFRM_Materialize: _bindgen_ty_52 = _bindgen_ty_52::SFRM_Materialize;
pub const SFRM_Materialize_Random: _bindgen_ty_52 =
    _bindgen_ty_52::SFRM_Materialize_Random;
pub const SFRM_Materialize_Preferred: _bindgen_ty_52 =
    _bindgen_ty_52::SFRM_Materialize_Preferred;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_52 {
    SFRM_ValuePerCall = 1,
    SFRM_Materialize = 2,
    SFRM_Materialize_Random = 4,
    SFRM_Materialize_Preferred = 8,
}
pub use self::_bindgen_ty_52 as SetFunctionReturnMode;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ReturnSetInfo {
    pub type_: NodeTag,
    pub econtext: *mut ExprContext,
    pub expectedDesc: TupleDesc,
    pub allowedModes: ::std::os::raw::c_int,
    pub returnMode: SetFunctionReturnMode,
    pub isDone: ExprDoneCond,
    pub setResult: *mut Tuplestorestate,
    pub setDesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_ReturnSetInfo() {
    assert_eq!(::std::mem::size_of::<ReturnSetInfo>() , 56usize);
    assert_eq!(::std::mem::align_of::<ReturnSetInfo>() , 8usize);
}
impl Clone for ReturnSetInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ProjectionInfo {
    pub type_: NodeTag,
    pub pi_targetlist: *mut List,
    pub pi_exprContext: *mut ExprContext,
    pub pi_slot: *mut TupleTableSlot,
    pub pi_itemIsDone: *mut ExprDoneCond,
    pub pi_directMap: bool_,
    pub pi_numSimpleVars: ::std::os::raw::c_int,
    pub pi_varSlotOffsets: *mut ::std::os::raw::c_int,
    pub pi_varNumbers: *mut ::std::os::raw::c_int,
    pub pi_varOutputCols: *mut ::std::os::raw::c_int,
    pub pi_lastInnerVar: ::std::os::raw::c_int,
    pub pi_lastOuterVar: ::std::os::raw::c_int,
    pub pi_lastScanVar: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ProjectionInfo() {
    assert_eq!(::std::mem::size_of::<ProjectionInfo>() , 88usize);
    assert_eq!(::std::mem::align_of::<ProjectionInfo>() , 8usize);
}
impl Clone for ProjectionInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JunkFilter {
    pub type_: NodeTag,
    pub jf_targetList: *mut List,
    pub jf_cleanTupType: TupleDesc,
    pub jf_cleanMap: *mut AttrNumber,
    pub jf_resultSlot: *mut TupleTableSlot,
    pub jf_junkAttNo: AttrNumber,
}
#[test]
fn bindgen_test_layout_JunkFilter() {
    assert_eq!(::std::mem::size_of::<JunkFilter>() , 48usize);
    assert_eq!(::std::mem::align_of::<JunkFilter>() , 8usize);
}
impl Clone for JunkFilter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ResultRelInfo {
    pub type_: NodeTag,
    pub ri_RangeTableIndex: Index,
    pub ri_RelationDesc: Relation,
    pub ri_NumIndices: ::std::os::raw::c_int,
    pub ri_IndexRelationDescs: RelationPtr,
    pub ri_IndexRelationInfo: *mut *mut IndexInfo,
    pub ri_TrigDesc: *mut TriggerDesc,
    pub ri_TrigFunctions: *mut FmgrInfo,
    pub ri_TrigWhenExprs: *mut *mut List,
    pub ri_TrigInstrument: *mut Instrumentation,
    pub ri_FdwRoutine: *mut ResultRelInfo_FdwRoutine,
    pub ri_FdwState: *mut ::std::os::raw::c_void,
    pub ri_usesFdwDirectModify: bool_,
    pub ri_WithCheckOptions: *mut List,
    pub ri_WithCheckOptionExprs: *mut List,
    pub ri_ConstraintExprs: *mut *mut List,
    pub ri_junkFilter: *mut JunkFilter,
    pub ri_projectReturning: *mut ProjectionInfo,
    pub ri_onConflictSetProj: *mut ProjectionInfo,
    pub ri_onConflictSetWhere: *mut List,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ResultRelInfo_FdwRoutine {
    pub type_: NodeTag,
    pub GetForeignRelSize: GetForeignRelSize_function,
    pub GetForeignPaths: GetForeignPaths_function,
    pub GetForeignPlan: GetForeignPlan_function,
    pub BeginForeignScan: BeginForeignScan_function,
    pub IterateForeignScan: IterateForeignScan_function,
    pub ReScanForeignScan: ReScanForeignScan_function,
    pub EndForeignScan: EndForeignScan_function,
    pub GetForeignJoinPaths: GetForeignJoinPaths_function,
    pub GetForeignUpperPaths: GetForeignUpperPaths_function,
    pub AddForeignUpdateTargets: AddForeignUpdateTargets_function,
    pub PlanForeignModify: PlanForeignModify_function,
    pub BeginForeignModify: BeginForeignModify_function,
    pub ExecForeignInsert: ExecForeignInsert_function,
    pub ExecForeignUpdate: ExecForeignUpdate_function,
    pub ExecForeignDelete: ExecForeignDelete_function,
    pub EndForeignModify: EndForeignModify_function,
    pub IsForeignRelUpdatable: IsForeignRelUpdatable_function,
    pub PlanDirectModify: PlanDirectModify_function,
    pub BeginDirectModify: BeginDirectModify_function,
    pub IterateDirectModify: IterateDirectModify_function,
    pub EndDirectModify: EndDirectModify_function,
    pub GetForeignRowMarkType: GetForeignRowMarkType_function,
    pub RefetchForeignRow: RefetchForeignRow_function,
    pub RecheckForeignScan: RecheckForeignScan_function,
    pub ExplainForeignScan: ExplainForeignScan_function,
    pub ExplainForeignModify: ExplainForeignModify_function,
    pub ExplainDirectModify: ExplainDirectModify_function,
    pub AnalyzeForeignTable: AnalyzeForeignTable_function,
    pub ImportForeignSchema: ImportForeignSchema_function,
    pub IsForeignScanParallelSafe: IsForeignScanParallelSafe_function,
    pub EstimateDSMForeignScan: EstimateDSMForeignScan_function,
    pub InitializeDSMForeignScan: InitializeDSMForeignScan_function,
    pub InitializeWorkerForeignScan: InitializeWorkerForeignScan_function,
}
#[test]
fn bindgen_test_layout_ResultRelInfo_FdwRoutine() {
    assert_eq!(::std::mem::size_of::<ResultRelInfo_FdwRoutine>() , 272usize);
    assert_eq!(::std::mem::align_of::<ResultRelInfo_FdwRoutine>() , 8usize);
}
impl Clone for ResultRelInfo_FdwRoutine {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ResultRelInfo() {
    assert_eq!(::std::mem::size_of::<ResultRelInfo>() , 152usize);
    assert_eq!(::std::mem::align_of::<ResultRelInfo>() , 8usize);
}
impl Clone for ResultRelInfo {
    fn clone(&self) -> Self { *self }
}
pub type EState = ExprContext_EState;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExecRowMark {
    pub relation: Relation,
    pub relid: Oid,
    pub rti: Index,
    pub prti: Index,
    pub rowmarkId: Index,
    pub markType: RowMarkType,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub ermActive: bool_,
    pub curCtid: ItemPointerData,
    pub ermExtra: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ExecRowMark() {
    assert_eq!(::std::mem::size_of::<ExecRowMark>() , 56usize);
    assert_eq!(::std::mem::align_of::<ExecRowMark>() , 8usize);
}
impl Clone for ExecRowMark {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExecAuxRowMark {
    pub rowmark: *mut ExecRowMark,
    pub ctidAttNo: AttrNumber,
    pub toidAttNo: AttrNumber,
    pub wholeAttNo: AttrNumber,
}
#[test]
fn bindgen_test_layout_ExecAuxRowMark() {
    assert_eq!(::std::mem::size_of::<ExecAuxRowMark>() , 16usize);
    assert_eq!(::std::mem::align_of::<ExecAuxRowMark>() , 8usize);
}
impl Clone for ExecAuxRowMark {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TupleHashEntryData {
    pub firstTuple: MinimalTuple,
}
#[test]
fn bindgen_test_layout_TupleHashEntryData() {
    assert_eq!(::std::mem::size_of::<TupleHashEntryData>() , 8usize);
    assert_eq!(::std::mem::align_of::<TupleHashEntryData>() , 8usize);
}
impl Clone for TupleHashEntryData {
    fn clone(&self) -> Self { *self }
}
pub type TupleHashEntry = *mut TupleHashEntryData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TupleHashTableData {
    pub hashtab: *mut HTAB,
    pub numCols: ::std::os::raw::c_int,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub tablecxt: MemoryContext,
    pub tempcxt: MemoryContext,
    pub entrysize: Size,
    pub tableslot: *mut TupleTableSlot,
    pub inputslot: *mut TupleTableSlot,
    pub in_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
}
#[test]
fn bindgen_test_layout_TupleHashTableData() {
    assert_eq!(::std::mem::size_of::<TupleHashTableData>() , 96usize);
    assert_eq!(::std::mem::align_of::<TupleHashTableData>() , 8usize);
}
impl Clone for TupleHashTableData {
    fn clone(&self) -> Self { *self }
}
pub type TupleHashTable = *mut TupleHashTableData;
pub type TupleHashIterator = HASH_SEQ_STATUS;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExprState {
    pub type_: NodeTag,
    pub expr: *mut Expr,
    pub evalfunc: ExprStateEvalFunc,
}
#[test]
fn bindgen_test_layout_ExprState() {
    assert_eq!(::std::mem::size_of::<ExprState>() , 24usize);
    assert_eq!(::std::mem::align_of::<ExprState>() , 8usize);
}
impl Clone for ExprState {
    fn clone(&self) -> Self { *self }
}
pub type ExprStateEvalFunc =
    ::std::option::Option<unsafe extern "C" fn(expression: *mut ExprState,
                                               econtext: *mut ExprContext,
                                               isNull: *mut bool_,
                                               isDone: *mut ExprDoneCond)
                              -> ::std::os::raw::c_ulong>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GenericExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
}
#[test]
fn bindgen_test_layout_GenericExprState() {
    assert_eq!(::std::mem::size_of::<GenericExprState>() , 32usize);
    assert_eq!(::std::mem::align_of::<GenericExprState>() , 8usize);
}
impl Clone for GenericExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WholeRowVarExprState {
    pub xprstate: ExprState,
    pub parent: *mut WholeRowVarExprState_PlanState,
    pub wrv_tupdesc: TupleDesc,
    pub wrv_junkFilter: *mut JunkFilter,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WholeRowVarExprState_PlanState {
    pub type_: NodeTag,
    pub plan: *mut Plan,
    pub state: *mut EState,
    pub instrument: *mut Instrumentation,
    pub worker_instrument: *mut WorkerInstrumentation,
    pub targetlist: *mut List,
    pub qual: *mut List,
    pub lefttree: *mut WholeRowVarExprState_PlanState,
    pub righttree: *mut WholeRowVarExprState_PlanState,
    pub initPlan: *mut List,
    pub subPlan: *mut List,
    pub chgParam: *mut Bitmapset,
    pub ps_ResultTupleSlot: *mut TupleTableSlot,
    pub ps_ExprContext: *mut ExprContext,
    pub ps_ProjInfo: *mut ProjectionInfo,
    pub ps_TupFromTlist: bool_,
}
#[test]
fn bindgen_test_layout_WholeRowVarExprState_PlanState() {
    assert_eq!(::std::mem::size_of::<WholeRowVarExprState_PlanState>() ,
               128usize);
    assert_eq!(::std::mem::align_of::<WholeRowVarExprState_PlanState>() ,
               8usize);
}
impl Clone for WholeRowVarExprState_PlanState {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_WholeRowVarExprState() {
    assert_eq!(::std::mem::size_of::<WholeRowVarExprState>() , 48usize);
    assert_eq!(::std::mem::align_of::<WholeRowVarExprState>() , 8usize);
}
impl Clone for WholeRowVarExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AggrefExprState {
    pub xprstate: ExprState,
    pub aggno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AggrefExprState() {
    assert_eq!(::std::mem::size_of::<AggrefExprState>() , 32usize);
    assert_eq!(::std::mem::align_of::<AggrefExprState>() , 8usize);
}
impl Clone for AggrefExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GroupingFuncExprState {
    pub xprstate: ExprState,
    pub aggstate: *mut GroupingFuncExprState_AggState,
    pub clauses: *mut List,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GroupingFuncExprState_AggState {
    pub ss: ScanState,
    pub aggs: *mut List,
    pub numaggs: ::std::os::raw::c_int,
    pub numtrans: ::std::os::raw::c_int,
    pub aggsplit: AggSplit,
    pub phase: AggStatePerPhase,
    pub numphases: ::std::os::raw::c_int,
    pub current_phase: ::std::os::raw::c_int,
    pub hashfunctions: *mut FmgrInfo,
    pub peragg: AggStatePerAgg,
    pub pertrans: AggStatePerTrans,
    pub aggcontexts: *mut *mut ExprContext,
    pub tmpcontext: *mut ExprContext,
    pub curpertrans: AggStatePerTrans,
    pub input_done: bool_,
    pub agg_done: bool_,
    pub projected_set: ::std::os::raw::c_int,
    pub current_set: ::std::os::raw::c_int,
    pub grouped_cols: *mut Bitmapset,
    pub all_grouped_cols: *mut List,
    pub maxsets: ::std::os::raw::c_int,
    pub phases: AggStatePerPhase,
    pub sort_in: *mut Tuplesortstate,
    pub sort_out: *mut Tuplesortstate,
    pub sort_slot: *mut TupleTableSlot,
    pub pergroup: AggStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub hashslot: *mut TupleTableSlot,
    pub hash_needed: *mut List,
    pub table_filled: bool_,
    pub hashiter: TupleHashIterator,
}
#[test]
fn bindgen_test_layout_GroupingFuncExprState_AggState() {
    assert_eq!(::std::mem::size_of::<GroupingFuncExprState_AggState>() ,
               384usize);
    assert_eq!(::std::mem::align_of::<GroupingFuncExprState_AggState>() ,
               8usize);
}
impl Clone for GroupingFuncExprState_AggState {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_GroupingFuncExprState() {
    assert_eq!(::std::mem::size_of::<GroupingFuncExprState>() , 40usize);
    assert_eq!(::std::mem::align_of::<GroupingFuncExprState>() , 8usize);
}
impl Clone for GroupingFuncExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WindowFuncExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub aggfilter: *mut ExprState,
    pub wfuncno: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WindowFuncExprState() {
    assert_eq!(::std::mem::size_of::<WindowFuncExprState>() , 48usize);
    assert_eq!(::std::mem::align_of::<WindowFuncExprState>() , 8usize);
}
impl Clone for WindowFuncExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ArrayRefExprState {
    pub xprstate: ExprState,
    pub refupperindexpr: *mut List,
    pub reflowerindexpr: *mut List,
    pub refexpr: *mut ExprState,
    pub refassgnexpr: *mut ExprState,
    pub refattrlength: int16,
    pub refelemlength: int16,
    pub refelembyval: bool_,
    pub refelemalign: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ArrayRefExprState() {
    assert_eq!(::std::mem::size_of::<ArrayRefExprState>() , 64usize);
    assert_eq!(::std::mem::align_of::<ArrayRefExprState>() , 8usize);
}
impl Clone for ArrayRefExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct FuncExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub func: FmgrInfo,
    pub funcResultStore: *mut Tuplestorestate,
    pub funcResultSlot: *mut TupleTableSlot,
    pub funcResultDesc: TupleDesc,
    pub funcReturnsTuple: bool_,
    pub setArgsValid: bool_,
    pub setHasSetArg: bool_,
    pub shutdown_reg: bool_,
    pub fcinfo_data: FunctionCallInfoData,
}
#[test]
fn bindgen_test_layout_FuncExprState() {
    assert_eq!(::std::mem::size_of::<FuncExprState>() , 1048usize);
    assert_eq!(::std::mem::align_of::<FuncExprState>() , 8usize);
}
#[repr(C)]
pub struct ScalarArrayOpExprState {
    pub fxprstate: FuncExprState,
    pub element_type: Oid,
    pub typlen: int16,
    pub typbyval: bool_,
    pub typalign: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ScalarArrayOpExprState() {
    assert_eq!(::std::mem::size_of::<ScalarArrayOpExprState>() , 1056usize);
    assert_eq!(::std::mem::align_of::<ScalarArrayOpExprState>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BoolExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
}
#[test]
fn bindgen_test_layout_BoolExprState() {
    assert_eq!(::std::mem::size_of::<BoolExprState>() , 32usize);
    assert_eq!(::std::mem::align_of::<BoolExprState>() , 8usize);
}
impl Clone for BoolExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SubPlanState {
    pub xprstate: ExprState,
    pub planstate: *mut WholeRowVarExprState_PlanState,
    pub parent: *mut WholeRowVarExprState_PlanState,
    pub testexpr: *mut ExprState,
    pub args: *mut List,
    pub curTuple: HeapTuple,
    pub curArray: Datum,
    pub projLeft: *mut ProjectionInfo,
    pub projRight: *mut ProjectionInfo,
    pub hashtable: TupleHashTable,
    pub hashnulls: TupleHashTable,
    pub havehashrows: bool_,
    pub havenullrows: bool_,
    pub hashtablecxt: MemoryContext,
    pub hashtempcxt: MemoryContext,
    pub innerecontext: *mut ExprContext,
    pub keyColIdx: *mut AttrNumber,
    pub tab_hash_funcs: *mut FmgrInfo,
    pub tab_eq_funcs: *mut FmgrInfo,
    pub lhs_hash_funcs: *mut FmgrInfo,
    pub cur_eq_funcs: *mut FmgrInfo,
}
#[test]
fn bindgen_test_layout_SubPlanState() {
    assert_eq!(::std::mem::size_of::<SubPlanState>() , 176usize);
    assert_eq!(::std::mem::align_of::<SubPlanState>() , 8usize);
}
impl Clone for SubPlanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlternativeSubPlanState {
    pub xprstate: ExprState,
    pub subplans: *mut List,
    pub active: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AlternativeSubPlanState() {
    assert_eq!(::std::mem::size_of::<AlternativeSubPlanState>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlternativeSubPlanState>() , 8usize);
}
impl Clone for AlternativeSubPlanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FieldSelectState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub argdesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_FieldSelectState() {
    assert_eq!(::std::mem::size_of::<FieldSelectState>() , 40usize);
    assert_eq!(::std::mem::align_of::<FieldSelectState>() , 8usize);
}
impl Clone for FieldSelectState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FieldStoreState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub newvals: *mut List,
    pub argdesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_FieldStoreState() {
    assert_eq!(::std::mem::size_of::<FieldStoreState>() , 48usize);
    assert_eq!(::std::mem::align_of::<FieldStoreState>() , 8usize);
}
impl Clone for FieldStoreState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoerceViaIOState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub outfunc: FmgrInfo,
    pub infunc: FmgrInfo,
    pub intypioparam: Oid,
}
#[test]
fn bindgen_test_layout_CoerceViaIOState() {
    assert_eq!(::std::mem::size_of::<CoerceViaIOState>() , 136usize);
    assert_eq!(::std::mem::align_of::<CoerceViaIOState>() , 8usize);
}
impl Clone for CoerceViaIOState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ArrayCoerceExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub resultelemtype: Oid,
    pub elemfunc: FmgrInfo,
    pub amstate: *mut ArrayCoerceExprState_ArrayMapState,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrayCoerceExprState_ArrayMapState([u8; 0]);
#[test]
fn bindgen_test_layout_ArrayCoerceExprState() {
    assert_eq!(::std::mem::size_of::<ArrayCoerceExprState>() , 96usize);
    assert_eq!(::std::mem::align_of::<ArrayCoerceExprState>() , 8usize);
}
impl Clone for ArrayCoerceExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ConvertRowtypeExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub indesc: TupleDesc,
    pub outdesc: TupleDesc,
    pub map: *mut ConvertRowtypeExprState_TupleConversionMap,
    pub initialized: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ConvertRowtypeExprState_TupleConversionMap([u8; 0]);
#[test]
fn bindgen_test_layout_ConvertRowtypeExprState() {
    assert_eq!(::std::mem::size_of::<ConvertRowtypeExprState>() , 64usize);
    assert_eq!(::std::mem::align_of::<ConvertRowtypeExprState>() , 8usize);
}
impl Clone for ConvertRowtypeExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CaseExprState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub args: *mut List,
    pub defresult: *mut ExprState,
    pub argtyplen: int16,
}
#[test]
fn bindgen_test_layout_CaseExprState() {
    assert_eq!(::std::mem::size_of::<CaseExprState>() , 56usize);
    assert_eq!(::std::mem::align_of::<CaseExprState>() , 8usize);
}
impl Clone for CaseExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CaseWhenState {
    pub xprstate: ExprState,
    pub expr: *mut ExprState,
    pub result: *mut ExprState,
}
#[test]
fn bindgen_test_layout_CaseWhenState() {
    assert_eq!(::std::mem::size_of::<CaseWhenState>() , 40usize);
    assert_eq!(::std::mem::align_of::<CaseWhenState>() , 8usize);
}
impl Clone for CaseWhenState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ArrayExprState {
    pub xprstate: ExprState,
    pub elements: *mut List,
    pub elemlength: int16,
    pub elembyval: bool_,
    pub elemalign: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ArrayExprState() {
    assert_eq!(::std::mem::size_of::<ArrayExprState>() , 40usize);
    assert_eq!(::std::mem::align_of::<ArrayExprState>() , 8usize);
}
impl Clone for ArrayExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RowExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub tupdesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_RowExprState() {
    assert_eq!(::std::mem::size_of::<RowExprState>() , 40usize);
    assert_eq!(::std::mem::align_of::<RowExprState>() , 8usize);
}
impl Clone for RowExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RowCompareExprState {
    pub xprstate: ExprState,
    pub largs: *mut List,
    pub rargs: *mut List,
    pub funcs: *mut FmgrInfo,
    pub collations: *mut Oid,
}
#[test]
fn bindgen_test_layout_RowCompareExprState() {
    assert_eq!(::std::mem::size_of::<RowCompareExprState>() , 56usize);
    assert_eq!(::std::mem::align_of::<RowCompareExprState>() , 8usize);
}
impl Clone for RowCompareExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoalesceExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
}
#[test]
fn bindgen_test_layout_CoalesceExprState() {
    assert_eq!(::std::mem::size_of::<CoalesceExprState>() , 32usize);
    assert_eq!(::std::mem::align_of::<CoalesceExprState>() , 8usize);
}
impl Clone for CoalesceExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MinMaxExprState {
    pub xprstate: ExprState,
    pub args: *mut List,
    pub cfunc: FmgrInfo,
}
#[test]
fn bindgen_test_layout_MinMaxExprState() {
    assert_eq!(::std::mem::size_of::<MinMaxExprState>() , 80usize);
    assert_eq!(::std::mem::align_of::<MinMaxExprState>() , 8usize);
}
impl Clone for MinMaxExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XmlExprState {
    pub xprstate: ExprState,
    pub named_args: *mut List,
    pub args: *mut List,
}
#[test]
fn bindgen_test_layout_XmlExprState() {
    assert_eq!(::std::mem::size_of::<XmlExprState>() , 40usize);
    assert_eq!(::std::mem::align_of::<XmlExprState>() , 8usize);
}
impl Clone for XmlExprState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NullTestState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub argdesc: TupleDesc,
}
#[test]
fn bindgen_test_layout_NullTestState() {
    assert_eq!(::std::mem::size_of::<NullTestState>() , 40usize);
    assert_eq!(::std::mem::align_of::<NullTestState>() , 8usize);
}
impl Clone for NullTestState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoerceToDomainState {
    pub xprstate: ExprState,
    pub arg: *mut ExprState,
    pub constraint_ref: *mut CoerceToDomainState_DomainConstraintRef,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CoerceToDomainState_DomainConstraintRef {
    pub constraints: *mut List,
    pub refctx: MemoryContext,
    pub tcache: *mut TypeCacheEntry,
    pub dcc: *mut DomainConstraintCache,
    pub callback: MemoryContextCallback,
}
#[test]
fn bindgen_test_layout_CoerceToDomainState_DomainConstraintRef() {
    assert_eq!(::std::mem::size_of::<CoerceToDomainState_DomainConstraintRef>()
               , 56usize);
    assert_eq!(::std::mem::align_of::<CoerceToDomainState_DomainConstraintRef>()
               , 8usize);
}
impl Clone for CoerceToDomainState_DomainConstraintRef {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_CoerceToDomainState() {
    assert_eq!(::std::mem::size_of::<CoerceToDomainState>() , 40usize);
    assert_eq!(::std::mem::align_of::<CoerceToDomainState>() , 8usize);
}
impl Clone for CoerceToDomainState {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DomainConstraintType {
    DOM_CONSTRAINT_NOTNULL = 0,
    DOM_CONSTRAINT_CHECK = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DomainConstraintState {
    pub type_: NodeTag,
    pub constrainttype: DomainConstraintType,
    pub name: *mut ::std::os::raw::c_char,
    pub check_expr: *mut ExprState,
}
#[test]
fn bindgen_test_layout_DomainConstraintState() {
    assert_eq!(::std::mem::size_of::<DomainConstraintState>() , 24usize);
    assert_eq!(::std::mem::align_of::<DomainConstraintState>() , 8usize);
}
impl Clone for DomainConstraintState {
    fn clone(&self) -> Self { *self }
}
pub type PlanState = WholeRowVarExprState_PlanState;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EPQState {
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub origslot: *mut TupleTableSlot,
    pub plan: *mut Plan,
    pub arowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_EPQState() {
    assert_eq!(::std::mem::size_of::<EPQState>() , 48usize);
    assert_eq!(::std::mem::align_of::<EPQState>() , 8usize);
}
impl Clone for EPQState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ResultState {
    pub ps: PlanState,
    pub resconstantqual: *mut ExprState,
    pub rs_done: bool_,
    pub rs_checkqual: bool_,
}
#[test]
fn bindgen_test_layout_ResultState() {
    assert_eq!(::std::mem::size_of::<ResultState>() , 144usize);
    assert_eq!(::std::mem::align_of::<ResultState>() , 8usize);
}
impl Clone for ResultState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModifyTableState {
    pub ps: PlanState,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub mt_done: bool_,
    pub mt_plans: *mut *mut PlanState,
    pub mt_nplans: ::std::os::raw::c_int,
    pub mt_whichplan: ::std::os::raw::c_int,
    pub resultRelInfo: *mut ResultRelInfo,
    pub mt_arowmarks: *mut *mut List,
    pub mt_epqstate: EPQState,
    pub fireBSTriggers: bool_,
    pub mt_onconflict: OnConflictAction,
    pub mt_arbiterindexes: *mut List,
    pub mt_existing: *mut TupleTableSlot,
    pub mt_excludedtlist: *mut List,
    pub mt_conflproj: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_ModifyTableState() {
    assert_eq!(::std::mem::size_of::<ModifyTableState>() , 256usize);
    assert_eq!(::std::mem::align_of::<ModifyTableState>() , 8usize);
}
impl Clone for ModifyTableState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AppendState {
    pub ps: PlanState,
    pub appendplans: *mut *mut PlanState,
    pub as_nplans: ::std::os::raw::c_int,
    pub as_whichplan: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AppendState() {
    assert_eq!(::std::mem::size_of::<AppendState>() , 144usize);
    assert_eq!(::std::mem::align_of::<AppendState>() , 8usize);
}
impl Clone for AppendState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MergeAppendState {
    pub ps: PlanState,
    pub mergeplans: *mut *mut PlanState,
    pub ms_nplans: ::std::os::raw::c_int,
    pub ms_nkeys: ::std::os::raw::c_int,
    pub ms_sortkeys: SortSupport,
    pub ms_slots: *mut *mut TupleTableSlot,
    pub ms_heap: *mut MergeAppendState_binaryheap,
    pub ms_initialized: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeAppendState_binaryheap([u8; 0]);
#[test]
fn bindgen_test_layout_MergeAppendState() {
    assert_eq!(::std::mem::size_of::<MergeAppendState>() , 176usize);
    assert_eq!(::std::mem::align_of::<MergeAppendState>() , 8usize);
}
impl Clone for MergeAppendState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RecursiveUnionState {
    pub ps: PlanState,
    pub recursing: bool_,
    pub intermediate_empty: bool_,
    pub working_table: *mut Tuplestorestate,
    pub intermediate_table: *mut Tuplestorestate,
    pub eqfunctions: *mut FmgrInfo,
    pub hashfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
}
#[test]
fn bindgen_test_layout_RecursiveUnionState() {
    assert_eq!(::std::mem::size_of::<RecursiveUnionState>() , 192usize);
    assert_eq!(::std::mem::align_of::<RecursiveUnionState>() , 8usize);
}
impl Clone for RecursiveUnionState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapAndState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BitmapAndState() {
    assert_eq!(::std::mem::size_of::<BitmapAndState>() , 144usize);
    assert_eq!(::std::mem::align_of::<BitmapAndState>() , 8usize);
}
impl Clone for BitmapAndState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapOrState {
    pub ps: PlanState,
    pub bitmapplans: *mut *mut PlanState,
    pub nplans: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BitmapOrState() {
    assert_eq!(::std::mem::size_of::<BitmapOrState>() , 144usize);
    assert_eq!(::std::mem::align_of::<BitmapOrState>() , 8usize);
}
impl Clone for BitmapOrState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ScanState {
    pub ps: PlanState,
    pub ss_currentRelation: Relation,
    pub ss_currentScanDesc: HeapScanDesc,
    pub ss_ScanTupleSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_ScanState() {
    assert_eq!(::std::mem::size_of::<ScanState>() , 152usize);
    assert_eq!(::std::mem::align_of::<ScanState>() , 8usize);
}
impl Clone for ScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SeqScanState {
    pub ss: ScanState,
    pub pscan_len: Size,
}
#[test]
fn bindgen_test_layout_SeqScanState() {
    assert_eq!(::std::mem::size_of::<SeqScanState>() , 160usize);
    assert_eq!(::std::mem::align_of::<SeqScanState>() , 8usize);
}
impl Clone for SeqScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SampleScanState {
    pub ss: ScanState,
    pub args: *mut List,
    pub repeatable: *mut ExprState,
    pub tsmroutine: *mut SampleScanState_TsmRoutine,
    pub tsm_state: *mut ::std::os::raw::c_void,
    pub use_bulkread: bool_,
    pub use_pagemode: bool_,
    pub begun: bool_,
    pub seed: uint32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SampleScanState_TsmRoutine([u8; 0]);
#[test]
fn bindgen_test_layout_SampleScanState() {
    assert_eq!(::std::mem::size_of::<SampleScanState>() , 192usize);
    assert_eq!(::std::mem::align_of::<SampleScanState>() , 8usize);
}
impl Clone for SampleScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_53 {
    pub scan_key: ScanKey,
    pub key_expr: *mut ExprState,
    pub key_toastable: bool_,
}
#[test]
fn bindgen_test_layout__bindgen_ty_53() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_53>() , 24usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_53>() , 8usize);
}
impl Clone for _bindgen_ty_53 {
    fn clone(&self) -> Self { *self }
}
pub type IndexRuntimeKeyInfo = _bindgen_ty_53;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_54 {
    pub scan_key: ScanKey,
    pub array_expr: *mut ExprState,
    pub next_elem: ::std::os::raw::c_int,
    pub num_elems: ::std::os::raw::c_int,
    pub elem_values: *mut Datum,
    pub elem_nulls: *mut bool_,
}
#[test]
fn bindgen_test_layout__bindgen_ty_54() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_54>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_54>() , 8usize);
}
impl Clone for _bindgen_ty_54 {
    fn clone(&self) -> Self { *self }
}
pub type IndexArrayKeyInfo = _bindgen_ty_54;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexScanState {
    pub ss: ScanState,
    pub indexqualorig: *mut List,
    pub indexorderbyorig: *mut List,
    pub iss_ScanKeys: ScanKey,
    pub iss_NumScanKeys: ::std::os::raw::c_int,
    pub iss_OrderByKeys: ScanKey,
    pub iss_NumOrderByKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub iss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub iss_RuntimeKeysReady: bool_,
    pub iss_RuntimeContext: *mut ExprContext,
    pub iss_RelationDesc: Relation,
    pub iss_ScanDesc: IndexScanDesc,
    pub iss_ReorderQueue: *mut pairingheap,
    pub iss_ReachedEnd: bool_,
    pub iss_OrderByValues: *mut Datum,
    pub iss_OrderByNulls: *mut bool_,
    pub iss_SortSupport: SortSupport,
    pub iss_OrderByTypByVals: *mut bool_,
    pub iss_OrderByTypLens: *mut int16,
}
#[test]
fn bindgen_test_layout_IndexScanState() {
    assert_eq!(::std::mem::size_of::<IndexScanState>() , 296usize);
    assert_eq!(::std::mem::align_of::<IndexScanState>() , 8usize);
}
impl Clone for IndexScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexOnlyScanState {
    pub ss: ScanState,
    pub indexqual: *mut List,
    pub ioss_ScanKeys: ScanKey,
    pub ioss_NumScanKeys: ::std::os::raw::c_int,
    pub ioss_OrderByKeys: ScanKey,
    pub ioss_NumOrderByKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub ioss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub ioss_RuntimeKeysReady: bool_,
    pub ioss_RuntimeContext: *mut ExprContext,
    pub ioss_RelationDesc: Relation,
    pub ioss_ScanDesc: IndexScanDesc,
    pub ioss_VMBuffer: Buffer,
    pub ioss_HeapFetches: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_IndexOnlyScanState() {
    assert_eq!(::std::mem::size_of::<IndexOnlyScanState>() , 248usize);
    assert_eq!(::std::mem::align_of::<IndexOnlyScanState>() , 8usize);
}
impl Clone for IndexOnlyScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapIndexScanState {
    pub ss: ScanState,
    pub biss_result: *mut TIDBitmap,
    pub biss_ScanKeys: ScanKey,
    pub biss_NumScanKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeys: *mut IndexRuntimeKeyInfo,
    pub biss_NumRuntimeKeys: ::std::os::raw::c_int,
    pub biss_ArrayKeys: *mut IndexArrayKeyInfo,
    pub biss_NumArrayKeys: ::std::os::raw::c_int,
    pub biss_RuntimeKeysReady: bool_,
    pub biss_RuntimeContext: *mut ExprContext,
    pub biss_RelationDesc: Relation,
    pub biss_ScanDesc: IndexScanDesc,
}
#[test]
fn bindgen_test_layout_BitmapIndexScanState() {
    assert_eq!(::std::mem::size_of::<BitmapIndexScanState>() , 232usize);
    assert_eq!(::std::mem::align_of::<BitmapIndexScanState>() , 8usize);
}
impl Clone for BitmapIndexScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapHeapScanState {
    pub ss: ScanState,
    pub bitmapqualorig: *mut List,
    pub tbm: *mut TIDBitmap,
    pub tbmiterator: *mut TBMIterator,
    pub tbmres: *mut TBMIterateResult,
    pub exact_pages: ::std::os::raw::c_long,
    pub lossy_pages: ::std::os::raw::c_long,
    pub prefetch_iterator: *mut TBMIterator,
    pub prefetch_pages: ::std::os::raw::c_int,
    pub prefetch_target: ::std::os::raw::c_int,
    pub prefetch_maximum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BitmapHeapScanState() {
    assert_eq!(::std::mem::size_of::<BitmapHeapScanState>() , 224usize);
    assert_eq!(::std::mem::align_of::<BitmapHeapScanState>() , 8usize);
}
impl Clone for BitmapHeapScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TidScanState {
    pub ss: ScanState,
    pub tss_tidquals: *mut List,
    pub tss_isCurrentOf: bool_,
    pub tss_NumTids: ::std::os::raw::c_int,
    pub tss_TidPtr: ::std::os::raw::c_int,
    pub tss_TidList: *mut ItemPointerData,
    pub tss_htup: HeapTupleData,
}
#[test]
fn bindgen_test_layout_TidScanState() {
    assert_eq!(::std::mem::size_of::<TidScanState>() , 208usize);
    assert_eq!(::std::mem::align_of::<TidScanState>() , 8usize);
}
impl Clone for TidScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SubqueryScanState {
    pub ss: ScanState,
    pub subplan: *mut PlanState,
}
#[test]
fn bindgen_test_layout_SubqueryScanState() {
    assert_eq!(::std::mem::size_of::<SubqueryScanState>() , 160usize);
    assert_eq!(::std::mem::align_of::<SubqueryScanState>() , 8usize);
}
impl Clone for SubqueryScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FunctionScanPerFuncState([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FunctionScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub ordinality: bool_,
    pub simple: bool_,
    pub ordinal: int64,
    pub nfuncs: ::std::os::raw::c_int,
    pub funcstates: *mut FunctionScanPerFuncState,
    pub argcontext: MemoryContext,
}
#[test]
fn bindgen_test_layout_FunctionScanState() {
    assert_eq!(::std::mem::size_of::<FunctionScanState>() , 192usize);
    assert_eq!(::std::mem::align_of::<FunctionScanState>() , 8usize);
}
impl Clone for FunctionScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ValuesScanState {
    pub ss: ScanState,
    pub rowcontext: *mut ExprContext,
    pub exprlists: *mut *mut List,
    pub array_len: ::std::os::raw::c_int,
    pub curr_idx: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ValuesScanState() {
    assert_eq!(::std::mem::size_of::<ValuesScanState>() , 176usize);
    assert_eq!(::std::mem::align_of::<ValuesScanState>() , 8usize);
}
impl Clone for ValuesScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CteScanState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub readptr: ::std::os::raw::c_int,
    pub cteplanstate: *mut PlanState,
    pub leader: *mut CteScanState,
    pub cte_table: *mut Tuplestorestate,
    pub eof_cte: bool_,
}
#[test]
fn bindgen_test_layout_CteScanState() {
    assert_eq!(::std::mem::size_of::<CteScanState>() , 192usize);
    assert_eq!(::std::mem::align_of::<CteScanState>() , 8usize);
}
impl Clone for CteScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WorkTableScanState {
    pub ss: ScanState,
    pub rustate: *mut RecursiveUnionState,
}
#[test]
fn bindgen_test_layout_WorkTableScanState() {
    assert_eq!(::std::mem::size_of::<WorkTableScanState>() , 160usize);
    assert_eq!(::std::mem::align_of::<WorkTableScanState>() , 8usize);
}
impl Clone for WorkTableScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignScanState {
    pub ss: ScanState,
    pub fdw_recheck_quals: *mut List,
    pub pscan_len: Size,
    pub fdwroutine: *mut ResultRelInfo_FdwRoutine,
    pub fdw_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ForeignScanState() {
    assert_eq!(::std::mem::size_of::<ForeignScanState>() , 184usize);
    assert_eq!(::std::mem::align_of::<ForeignScanState>() , 8usize);
}
impl Clone for ForeignScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomExecMethods([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CustomScanState {
    pub ss: ScanState,
    pub flags: uint32,
    pub custom_ps: *mut List,
    pub pscan_len: Size,
    pub methods: *const CustomExecMethods,
}
#[test]
fn bindgen_test_layout_CustomScanState() {
    assert_eq!(::std::mem::size_of::<CustomScanState>() , 184usize);
    assert_eq!(::std::mem::align_of::<CustomScanState>() , 8usize);
}
impl Clone for CustomScanState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JoinState {
    pub ps: PlanState,
    pub jointype: JoinType,
    pub joinqual: *mut List,
}
#[test]
fn bindgen_test_layout_JoinState() {
    assert_eq!(::std::mem::size_of::<JoinState>() , 144usize);
    assert_eq!(::std::mem::align_of::<JoinState>() , 8usize);
}
impl Clone for JoinState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NestLoopState {
    pub js: JoinState,
    pub nl_NeedNewOuter: bool_,
    pub nl_MatchedOuter: bool_,
    pub nl_NullInnerTupleSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_NestLoopState() {
    assert_eq!(::std::mem::size_of::<NestLoopState>() , 160usize);
    assert_eq!(::std::mem::align_of::<NestLoopState>() , 8usize);
}
impl Clone for NestLoopState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MergeJoinClauseData([u8; 0]);
pub type MergeJoinClause = *mut MergeJoinClauseData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MergeJoinState {
    pub js: JoinState,
    pub mj_NumClauses: ::std::os::raw::c_int,
    pub mj_Clauses: MergeJoinClause,
    pub mj_JoinState: ::std::os::raw::c_int,
    pub mj_ExtraMarks: bool_,
    pub mj_ConstFalseJoin: bool_,
    pub mj_FillOuter: bool_,
    pub mj_FillInner: bool_,
    pub mj_MatchedOuter: bool_,
    pub mj_MatchedInner: bool_,
    pub mj_OuterTupleSlot: *mut TupleTableSlot,
    pub mj_InnerTupleSlot: *mut TupleTableSlot,
    pub mj_MarkedTupleSlot: *mut TupleTableSlot,
    pub mj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub mj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub mj_OuterEContext: *mut ExprContext,
    pub mj_InnerEContext: *mut ExprContext,
}
#[test]
fn bindgen_test_layout_MergeJoinState() {
    assert_eq!(::std::mem::size_of::<MergeJoinState>() , 232usize);
    assert_eq!(::std::mem::align_of::<MergeJoinState>() , 8usize);
}
impl Clone for MergeJoinState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTupleData([u8; 0]);
pub type HashJoinTuple = *mut HashJoinTupleData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HashJoinTableData([u8; 0]);
pub type HashJoinTable = *mut HashJoinTableData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HashJoinState {
    pub js: JoinState,
    pub hashclauses: *mut List,
    pub hj_OuterHashKeys: *mut List,
    pub hj_InnerHashKeys: *mut List,
    pub hj_HashOperators: *mut List,
    pub hj_HashTable: HashJoinTable,
    pub hj_CurHashValue: uint32,
    pub hj_CurBucketNo: ::std::os::raw::c_int,
    pub hj_CurSkewBucketNo: ::std::os::raw::c_int,
    pub hj_CurTuple: HashJoinTuple,
    pub hj_OuterTupleSlot: *mut TupleTableSlot,
    pub hj_HashTupleSlot: *mut TupleTableSlot,
    pub hj_NullOuterTupleSlot: *mut TupleTableSlot,
    pub hj_NullInnerTupleSlot: *mut TupleTableSlot,
    pub hj_FirstOuterTupleSlot: *mut TupleTableSlot,
    pub hj_JoinState: ::std::os::raw::c_int,
    pub hj_MatchedOuter: bool_,
    pub hj_OuterNotEmpty: bool_,
}
#[test]
fn bindgen_test_layout_HashJoinState() {
    assert_eq!(::std::mem::size_of::<HashJoinState>() , 256usize);
    assert_eq!(::std::mem::align_of::<HashJoinState>() , 8usize);
}
impl Clone for HashJoinState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MaterialState {
    pub ss: ScanState,
    pub eflags: ::std::os::raw::c_int,
    pub eof_underlying: bool_,
    pub tuplestorestate: *mut Tuplestorestate,
}
#[test]
fn bindgen_test_layout_MaterialState() {
    assert_eq!(::std::mem::size_of::<MaterialState>() , 168usize);
    assert_eq!(::std::mem::align_of::<MaterialState>() , 8usize);
}
impl Clone for MaterialState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SortState {
    pub ss: ScanState,
    pub randomAccess: bool_,
    pub bounded: bool_,
    pub bound: int64,
    pub sort_Done: bool_,
    pub bounded_Done: bool_,
    pub bound_Done: int64,
    pub tuplesortstate: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_SortState() {
    assert_eq!(::std::mem::size_of::<SortState>() , 192usize);
    assert_eq!(::std::mem::align_of::<SortState>() , 8usize);
}
impl Clone for SortState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GroupState {
    pub ss: ScanState,
    pub eqfunctions: *mut FmgrInfo,
    pub grp_done: bool_,
}
#[test]
fn bindgen_test_layout_GroupState() {
    assert_eq!(::std::mem::size_of::<GroupState>() , 168usize);
    assert_eq!(::std::mem::align_of::<GroupState>() , 8usize);
}
impl Clone for GroupState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerAggData([u8; 0]);
pub type AggStatePerAgg = *mut AggStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerTransData([u8; 0]);
pub type AggStatePerTrans = *mut AggStatePerTransData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerGroupData([u8; 0]);
pub type AggStatePerGroup = *mut AggStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AggStatePerPhaseData([u8; 0]);
pub type AggStatePerPhase = *mut AggStatePerPhaseData;
pub type AggState = GroupingFuncExprState_AggState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerFuncData([u8; 0]);
pub type WindowStatePerFunc = *mut WindowStatePerFuncData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowStatePerAggData([u8; 0]);
pub type WindowStatePerAgg = *mut WindowStatePerAggData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WindowAggState {
    pub ss: ScanState,
    pub funcs: *mut List,
    pub numfuncs: ::std::os::raw::c_int,
    pub numaggs: ::std::os::raw::c_int,
    pub perfunc: WindowStatePerFunc,
    pub peragg: WindowStatePerAgg,
    pub partEqfunctions: *mut FmgrInfo,
    pub ordEqfunctions: *mut FmgrInfo,
    pub buffer: *mut Tuplestorestate,
    pub current_ptr: ::std::os::raw::c_int,
    pub spooled_rows: int64,
    pub currentpos: int64,
    pub frameheadpos: int64,
    pub frametailpos: int64,
    pub agg_winobj: *mut WindowAggState_WindowObjectData,
    pub aggregatedbase: int64,
    pub aggregatedupto: int64,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut ExprState,
    pub endOffset: *mut ExprState,
    pub startOffsetValue: Datum,
    pub endOffsetValue: Datum,
    pub partcontext: MemoryContext,
    pub aggcontext: MemoryContext,
    pub curaggcontext: MemoryContext,
    pub tmpcontext: *mut ExprContext,
    pub all_first: bool_,
    pub all_done: bool_,
    pub partition_spooled: bool_,
    pub more_partitions: bool_,
    pub framehead_valid: bool_,
    pub frametail_valid: bool_,
    pub first_part_slot: *mut TupleTableSlot,
    pub agg_row_slot: *mut TupleTableSlot,
    pub temp_slot_1: *mut TupleTableSlot,
    pub temp_slot_2: *mut TupleTableSlot,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WindowAggState_WindowObjectData([u8; 0]);
#[test]
fn bindgen_test_layout_WindowAggState() {
    assert_eq!(::std::mem::size_of::<WindowAggState>() , 384usize);
    assert_eq!(::std::mem::align_of::<WindowAggState>() , 8usize);
}
impl Clone for WindowAggState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UniqueState {
    pub ps: PlanState,
    pub eqfunctions: *mut FmgrInfo,
    pub tempContext: MemoryContext,
}
#[test]
fn bindgen_test_layout_UniqueState() {
    assert_eq!(::std::mem::size_of::<UniqueState>() , 144usize);
    assert_eq!(::std::mem::align_of::<UniqueState>() , 8usize);
}
impl Clone for UniqueState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GatherState {
    pub ps: PlanState,
    pub initialized: bool_,
    pub pei: *mut GatherState_ParallelExecutorInfo,
    pub nreaders: ::std::os::raw::c_int,
    pub nextreader: ::std::os::raw::c_int,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub reader: *mut *mut GatherState_TupleQueueReader,
    pub funnel_slot: *mut TupleTableSlot,
    pub need_to_scan_locally: bool_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherState_ParallelExecutorInfo([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GatherState_TupleQueueReader([u8; 0]);
#[test]
fn bindgen_test_layout_GatherState() {
    assert_eq!(::std::mem::size_of::<GatherState>() , 184usize);
    assert_eq!(::std::mem::align_of::<GatherState>() , 8usize);
}
impl Clone for GatherState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HashState {
    pub ps: PlanState,
    pub hashtable: HashJoinTable,
    pub hashkeys: *mut List,
}
#[test]
fn bindgen_test_layout_HashState() {
    assert_eq!(::std::mem::size_of::<HashState>() , 144usize);
    assert_eq!(::std::mem::align_of::<HashState>() , 8usize);
}
impl Clone for HashState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SetOpStatePerGroupData([u8; 0]);
pub type SetOpStatePerGroup = *mut SetOpStatePerGroupData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SetOpState {
    pub ps: PlanState,
    pub eqfunctions: *mut FmgrInfo,
    pub hashfunctions: *mut FmgrInfo,
    pub setop_done: bool_,
    pub numOutput: ::std::os::raw::c_long,
    pub tempContext: MemoryContext,
    pub pergroup: SetOpStatePerGroup,
    pub grp_firstTuple: HeapTuple,
    pub hashtable: TupleHashTable,
    pub tableContext: MemoryContext,
    pub table_filled: bool_,
    pub hashiter: TupleHashIterator,
}
#[test]
fn bindgen_test_layout_SetOpState() {
    assert_eq!(::std::mem::size_of::<SetOpState>() , 232usize);
    assert_eq!(::std::mem::align_of::<SetOpState>() , 8usize);
}
impl Clone for SetOpState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockRowsState {
    pub ps: PlanState,
    pub lr_arowMarks: *mut List,
    pub lr_epqstate: EPQState,
    pub lr_curtuples: *mut HeapTuple,
    pub lr_ntables: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRowsState() {
    assert_eq!(::std::mem::size_of::<LockRowsState>() , 200usize);
    assert_eq!(::std::mem::align_of::<LockRowsState>() , 8usize);
}
impl Clone for LockRowsState {
    fn clone(&self) -> Self { *self }
}
pub const LIMIT_INITIAL: _bindgen_ty_55 = _bindgen_ty_55::LIMIT_INITIAL;
pub const LIMIT_RESCAN: _bindgen_ty_55 = _bindgen_ty_55::LIMIT_RESCAN;
pub const LIMIT_EMPTY: _bindgen_ty_55 = _bindgen_ty_55::LIMIT_EMPTY;
pub const LIMIT_INWINDOW: _bindgen_ty_55 = _bindgen_ty_55::LIMIT_INWINDOW;
pub const LIMIT_SUBPLANEOF: _bindgen_ty_55 = _bindgen_ty_55::LIMIT_SUBPLANEOF;
pub const LIMIT_WINDOWEND: _bindgen_ty_55 = _bindgen_ty_55::LIMIT_WINDOWEND;
pub const LIMIT_WINDOWSTART: _bindgen_ty_55 =
    _bindgen_ty_55::LIMIT_WINDOWSTART;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_55 {
    LIMIT_INITIAL = 0,
    LIMIT_RESCAN = 1,
    LIMIT_EMPTY = 2,
    LIMIT_INWINDOW = 3,
    LIMIT_SUBPLANEOF = 4,
    LIMIT_WINDOWEND = 5,
    LIMIT_WINDOWSTART = 6,
}
pub use self::_bindgen_ty_55 as LimitStateCond;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LimitState {
    pub ps: PlanState,
    pub limitOffset: *mut ExprState,
    pub limitCount: *mut ExprState,
    pub offset: int64,
    pub count: int64,
    pub noCount: bool_,
    pub lstate: LimitStateCond,
    pub position: int64,
    pub subSlot: *mut TupleTableSlot,
}
#[test]
fn bindgen_test_layout_LimitState() {
    assert_eq!(::std::mem::size_of::<LimitState>() , 184usize);
    assert_eq!(::std::mem::align_of::<LimitState>() , 8usize);
}
impl Clone for LimitState {
    fn clone(&self) -> Self { *self }
}
pub const DestNone: _bindgen_ty_56 = _bindgen_ty_56::DestNone;
pub const DestDebug: _bindgen_ty_56 = _bindgen_ty_56::DestDebug;
pub const DestRemote: _bindgen_ty_56 = _bindgen_ty_56::DestRemote;
pub const DestRemoteExecute: _bindgen_ty_56 =
    _bindgen_ty_56::DestRemoteExecute;
pub const DestSPI: _bindgen_ty_56 = _bindgen_ty_56::DestSPI;
pub const DestTuplestore: _bindgen_ty_56 = _bindgen_ty_56::DestTuplestore;
pub const DestIntoRel: _bindgen_ty_56 = _bindgen_ty_56::DestIntoRel;
pub const DestCopyOut: _bindgen_ty_56 = _bindgen_ty_56::DestCopyOut;
pub const DestSQLFunction: _bindgen_ty_56 = _bindgen_ty_56::DestSQLFunction;
pub const DestTransientRel: _bindgen_ty_56 = _bindgen_ty_56::DestTransientRel;
pub const DestTupleQueue: _bindgen_ty_56 = _bindgen_ty_56::DestTupleQueue;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_56 {
    DestNone = 0,
    DestDebug = 1,
    DestRemote = 2,
    DestRemoteExecute = 3,
    DestSPI = 4,
    DestTuplestore = 5,
    DestIntoRel = 6,
    DestCopyOut = 7,
    DestSQLFunction = 8,
    DestTransientRel = 9,
    DestTupleQueue = 10,
}
pub use self::_bindgen_ty_56 as CommandDest;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _DestReceiver {
    pub receiveSlot: ::std::option::Option<unsafe extern "C" fn(slot:
                                                                    *mut TupleTableSlot,
                                                                self_:
                                                                    *mut DestReceiver)
                                               -> ::std::os::raw::c_char>,
    pub rStartup: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                 *mut DestReceiver,
                                                             operation:
                                                                 ::std::os::raw::c_int,
                                                             typeinfo:
                                                                 TupleDesc)>,
    pub rShutdown: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                  *mut DestReceiver)>,
    pub rDestroy: ::std::option::Option<unsafe extern "C" fn(self_:
                                                                 *mut DestReceiver)>,
    pub mydest: CommandDest,
}
#[test]
fn bindgen_test_layout__DestReceiver() {
    assert_eq!(::std::mem::size_of::<_DestReceiver>() , 40usize);
    assert_eq!(::std::mem::align_of::<_DestReceiver>() , 8usize);
}
impl Clone for _DestReceiver {
    fn clone(&self) -> Self { *self }
}
pub type DestReceiver = _DestReceiver;
extern "C" {
    #[link_name = "None_Receiver"]
    pub static mut None_Receiver: *mut DestReceiver;
}
extern "C" {
    pub fn BeginCommand(commandTag: *const ::std::os::raw::c_char,
                        dest: CommandDest);
}
extern "C" {
    pub fn CreateDestReceiver(dest: CommandDest) -> *mut DestReceiver;
}
extern "C" {
    pub fn EndCommand(commandTag: *const ::std::os::raw::c_char,
                      dest: CommandDest);
}
extern "C" {
    pub fn NullCommand(dest: CommandDest);
}
extern "C" {
    pub fn ReadyForQuery(dest: CommandDest);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct QueryDesc {
    pub operation: CmdType,
    pub plannedstmt: *mut PlannedStmt,
    pub utilitystmt: *mut Node,
    pub sourceText: *const ::std::os::raw::c_char,
    pub snapshot: Snapshot,
    pub crosscheck_snapshot: Snapshot,
    pub dest: *mut DestReceiver,
    pub params: ParamListInfo,
    pub instrument_options: ::std::os::raw::c_int,
    pub tupDesc: TupleDesc,
    pub estate: *mut EState,
    pub planstate: *mut PlanState,
    pub totaltime: *mut Instrumentation,
}
#[test]
fn bindgen_test_layout_QueryDesc() {
    assert_eq!(::std::mem::size_of::<QueryDesc>() , 104usize);
    assert_eq!(::std::mem::align_of::<QueryDesc>() , 8usize);
}
impl Clone for QueryDesc {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn CreateQueryDesc(plannedstmt: *mut PlannedStmt,
                           sourceText: *const ::std::os::raw::c_char,
                           snapshot: Snapshot, crosscheck_snapshot: Snapshot,
                           dest: *mut DestReceiver, params: ParamListInfo,
                           instrument_options: ::std::os::raw::c_int)
     -> *mut QueryDesc;
}
extern "C" {
    pub fn CreateUtilityQueryDesc(utilitystmt: *mut Node,
                                  sourceText: *const ::std::os::raw::c_char,
                                  snapshot: Snapshot, dest: *mut DestReceiver,
                                  params: ParamListInfo) -> *mut QueryDesc;
}
extern "C" {
    pub fn FreeQueryDesc(qdesc: *mut QueryDesc);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Value {
    pub type_: NodeTag,
    pub val: Value_ValUnion,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Value_ValUnion {
    pub ival: __BindgenUnionField<::std::os::raw::c_long>,
    pub str: __BindgenUnionField<*mut ::std::os::raw::c_char>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_Value_ValUnion() {
    assert_eq!(::std::mem::size_of::<Value_ValUnion>() , 8usize);
    assert_eq!(::std::mem::align_of::<Value_ValUnion>() , 8usize);
}
impl Clone for Value_ValUnion {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Value() {
    assert_eq!(::std::mem::size_of::<Value>() , 16usize);
    assert_eq!(::std::mem::align_of::<Value>() , 8usize);
}
impl Clone for Value {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn makeInteger(i: ::std::os::raw::c_long) -> *mut Value;
}
extern "C" {
    pub fn makeFloat(numericStr: *mut ::std::os::raw::c_char) -> *mut Value;
}
extern "C" {
    pub fn makeString(str: *mut ::std::os::raw::c_char) -> *mut Value;
}
extern "C" {
    pub fn makeBitString(str: *mut ::std::os::raw::c_char) -> *mut Value;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum QuerySource {
    QSRC_ORIGINAL = 0,
    QSRC_PARSER = 1,
    QSRC_INSTEAD_RULE = 2,
    QSRC_QUAL_INSTEAD_RULE = 3,
    QSRC_NON_INSTEAD_RULE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SortByDir {
    SORTBY_DEFAULT = 0,
    SORTBY_ASC = 1,
    SORTBY_DESC = 2,
    SORTBY_USING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SortByNulls {
    SORTBY_NULLS_DEFAULT = 0,
    SORTBY_NULLS_FIRST = 1,
    SORTBY_NULLS_LAST = 2,
}
pub type AclMode = uint32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Query {
    pub type_: NodeTag,
    pub commandType: CmdType,
    pub querySource: QuerySource,
    pub queryId: uint32,
    pub canSetTag: bool_,
    pub utilityStmt: *mut Node,
    pub resultRelation: ::std::os::raw::c_int,
    pub hasAggs: bool_,
    pub hasWindowFuncs: bool_,
    pub hasSubLinks: bool_,
    pub hasDistinctOn: bool_,
    pub hasRecursive: bool_,
    pub hasModifyingCTE: bool_,
    pub hasForUpdate: bool_,
    pub hasRowSecurity: bool_,
    pub cteList: *mut List,
    pub rtable: *mut List,
    pub jointree: *mut FromExpr,
    pub targetList: *mut List,
    pub onConflict: *mut OnConflictExpr,
    pub returningList: *mut List,
    pub groupClause: *mut List,
    pub groupingSets: *mut List,
    pub havingQual: *mut Node,
    pub windowClause: *mut List,
    pub distinctClause: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub rowMarks: *mut List,
    pub setOperations: *mut Node,
    pub constraintDeps: *mut List,
    pub withCheckOptions: *mut List,
}
#[test]
fn bindgen_test_layout_Query() {
    assert_eq!(::std::mem::size_of::<Query>() , 192usize);
    assert_eq!(::std::mem::align_of::<Query>() , 8usize);
}
impl Clone for Query {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TypeName {
    pub type_: NodeTag,
    pub names: *mut List,
    pub typeOid: Oid,
    pub setof: bool_,
    pub pct_type: bool_,
    pub typmods: *mut List,
    pub typemod: int32,
    pub arrayBounds: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TypeName() {
    assert_eq!(::std::mem::size_of::<TypeName>() , 56usize);
    assert_eq!(::std::mem::align_of::<TypeName>() , 8usize);
}
impl Clone for TypeName {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ColumnRef {
    pub type_: NodeTag,
    pub fields: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ColumnRef() {
    assert_eq!(::std::mem::size_of::<ColumnRef>() , 24usize);
    assert_eq!(::std::mem::align_of::<ColumnRef>() , 8usize);
}
impl Clone for ColumnRef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ParamRef {
    pub type_: NodeTag,
    pub number: ::std::os::raw::c_int,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ParamRef() {
    assert_eq!(::std::mem::size_of::<ParamRef>() , 12usize);
    assert_eq!(::std::mem::align_of::<ParamRef>() , 4usize);
}
impl Clone for ParamRef {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum A_Expr_Kind {
    AEXPR_OP = 0,
    AEXPR_OP_ANY = 1,
    AEXPR_OP_ALL = 2,
    AEXPR_DISTINCT = 3,
    AEXPR_NOT_DISTINCT = 4,
    AEXPR_NULLIF = 5,
    AEXPR_OF = 6,
    AEXPR_IN = 7,
    AEXPR_LIKE = 8,
    AEXPR_ILIKE = 9,
    AEXPR_SIMILAR = 10,
    AEXPR_BETWEEN = 11,
    AEXPR_NOT_BETWEEN = 12,
    AEXPR_BETWEEN_SYM = 13,
    AEXPR_NOT_BETWEEN_SYM = 14,
    AEXPR_PAREN = 15,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct A_Expr {
    pub type_: NodeTag,
    pub kind: A_Expr_Kind,
    pub name: *mut List,
    pub lexpr: *mut Node,
    pub rexpr: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_Expr() {
    assert_eq!(::std::mem::size_of::<A_Expr>() , 40usize);
    assert_eq!(::std::mem::align_of::<A_Expr>() , 8usize);
}
impl Clone for A_Expr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct A_Const {
    pub type_: NodeTag,
    pub val: Value,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_Const() {
    assert_eq!(::std::mem::size_of::<A_Const>() , 32usize);
    assert_eq!(::std::mem::align_of::<A_Const>() , 8usize);
}
impl Clone for A_Const {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TypeCast {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TypeCast() {
    assert_eq!(::std::mem::size_of::<TypeCast>() , 32usize);
    assert_eq!(::std::mem::align_of::<TypeCast>() , 8usize);
}
impl Clone for TypeCast {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CollateClause {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub collname: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CollateClause() {
    assert_eq!(::std::mem::size_of::<CollateClause>() , 32usize);
    assert_eq!(::std::mem::align_of::<CollateClause>() , 8usize);
}
impl Clone for CollateClause {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RoleSpecType {
    ROLESPEC_CSTRING = 0,
    ROLESPEC_CURRENT_USER = 1,
    ROLESPEC_SESSION_USER = 2,
    ROLESPEC_PUBLIC = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RoleSpec {
    pub type_: NodeTag,
    pub roletype: RoleSpecType,
    pub rolename: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RoleSpec() {
    assert_eq!(::std::mem::size_of::<RoleSpec>() , 24usize);
    assert_eq!(::std::mem::align_of::<RoleSpec>() , 8usize);
}
impl Clone for RoleSpec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FuncCall {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub args: *mut List,
    pub agg_order: *mut List,
    pub agg_filter: *mut Node,
    pub agg_within_group: bool_,
    pub agg_star: bool_,
    pub agg_distinct: bool_,
    pub func_variadic: bool_,
    pub over: *mut FuncCall_WindowDef,
    pub location: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FuncCall_WindowDef {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_FuncCall_WindowDef() {
    assert_eq!(::std::mem::size_of::<FuncCall_WindowDef>() , 72usize);
    assert_eq!(::std::mem::align_of::<FuncCall_WindowDef>() , 8usize);
}
impl Clone for FuncCall_WindowDef {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_FuncCall() {
    assert_eq!(::std::mem::size_of::<FuncCall>() , 64usize);
    assert_eq!(::std::mem::align_of::<FuncCall>() , 8usize);
}
impl Clone for FuncCall {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct A_Star {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_A_Star() {
    assert_eq!(::std::mem::size_of::<A_Star>() , 4usize);
    assert_eq!(::std::mem::align_of::<A_Star>() , 4usize);
}
impl Clone for A_Star {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct A_Indices {
    pub type_: NodeTag,
    pub is_slice: bool_,
    pub lidx: *mut Node,
    pub uidx: *mut Node,
}
#[test]
fn bindgen_test_layout_A_Indices() {
    assert_eq!(::std::mem::size_of::<A_Indices>() , 24usize);
    assert_eq!(::std::mem::align_of::<A_Indices>() , 8usize);
}
impl Clone for A_Indices {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct A_Indirection {
    pub type_: NodeTag,
    pub arg: *mut Node,
    pub indirection: *mut List,
}
#[test]
fn bindgen_test_layout_A_Indirection() {
    assert_eq!(::std::mem::size_of::<A_Indirection>() , 24usize);
    assert_eq!(::std::mem::align_of::<A_Indirection>() , 8usize);
}
impl Clone for A_Indirection {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct A_ArrayExpr {
    pub type_: NodeTag,
    pub elements: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_A_ArrayExpr() {
    assert_eq!(::std::mem::size_of::<A_ArrayExpr>() , 24usize);
    assert_eq!(::std::mem::align_of::<A_ArrayExpr>() , 8usize);
}
impl Clone for A_ArrayExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ResTarget {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub indirection: *mut List,
    pub val: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ResTarget() {
    assert_eq!(::std::mem::size_of::<ResTarget>() , 40usize);
    assert_eq!(::std::mem::align_of::<ResTarget>() , 8usize);
}
impl Clone for ResTarget {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MultiAssignRef {
    pub type_: NodeTag,
    pub source: *mut Node,
    pub colno: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_MultiAssignRef() {
    assert_eq!(::std::mem::size_of::<MultiAssignRef>() , 24usize);
    assert_eq!(::std::mem::align_of::<MultiAssignRef>() , 8usize);
}
impl Clone for MultiAssignRef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SortBy {
    pub type_: NodeTag,
    pub node: *mut Node,
    pub sortby_dir: SortByDir,
    pub sortby_nulls: SortByNulls,
    pub useOp: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SortBy() {
    assert_eq!(::std::mem::size_of::<SortBy>() , 40usize);
    assert_eq!(::std::mem::align_of::<SortBy>() , 8usize);
}
impl Clone for SortBy {
    fn clone(&self) -> Self { *self }
}
pub type WindowDef = FuncCall_WindowDef;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RangeSubselect {
    pub type_: NodeTag,
    pub lateral: bool_,
    pub subquery: *mut Node,
    pub alias: *mut Alias,
}
#[test]
fn bindgen_test_layout_RangeSubselect() {
    assert_eq!(::std::mem::size_of::<RangeSubselect>() , 24usize);
    assert_eq!(::std::mem::align_of::<RangeSubselect>() , 8usize);
}
impl Clone for RangeSubselect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RangeFunction {
    pub type_: NodeTag,
    pub lateral: bool_,
    pub ordinality: bool_,
    pub is_rowsfrom: bool_,
    pub functions: *mut List,
    pub alias: *mut Alias,
    pub coldeflist: *mut List,
}
#[test]
fn bindgen_test_layout_RangeFunction() {
    assert_eq!(::std::mem::size_of::<RangeFunction>() , 32usize);
    assert_eq!(::std::mem::align_of::<RangeFunction>() , 8usize);
}
impl Clone for RangeFunction {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RangeTableSample {
    pub type_: NodeTag,
    pub relation: *mut Node,
    pub method: *mut List,
    pub args: *mut List,
    pub repeatable: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_RangeTableSample() {
    assert_eq!(::std::mem::size_of::<RangeTableSample>() , 48usize);
    assert_eq!(::std::mem::align_of::<RangeTableSample>() , 8usize);
}
impl Clone for RangeTableSample {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ColumnDef {
    pub type_: NodeTag,
    pub colname: *mut ::std::os::raw::c_char,
    pub typeName: *mut TypeName,
    pub inhcount: ::std::os::raw::c_int,
    pub is_local: bool_,
    pub is_not_null: bool_,
    pub is_from_type: bool_,
    pub storage: ::std::os::raw::c_char,
    pub raw_default: *mut Node,
    pub cooked_default: *mut Node,
    pub collClause: *mut CollateClause,
    pub collOid: Oid,
    pub constraints: *mut List,
    pub fdwoptions: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ColumnDef() {
    assert_eq!(::std::mem::size_of::<ColumnDef>() , 88usize);
    assert_eq!(::std::mem::align_of::<ColumnDef>() , 8usize);
}
impl Clone for ColumnDef {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TableLikeClause {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub options: bits32,
}
#[test]
fn bindgen_test_layout_TableLikeClause() {
    assert_eq!(::std::mem::size_of::<TableLikeClause>() , 24usize);
    assert_eq!(::std::mem::align_of::<TableLikeClause>() , 8usize);
}
impl Clone for TableLikeClause {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TableLikeOption {
    CREATE_TABLE_LIKE_DEFAULTS = 1,
    CREATE_TABLE_LIKE_CONSTRAINTS = 2,
    CREATE_TABLE_LIKE_INDEXES = 4,
    CREATE_TABLE_LIKE_STORAGE = 8,
    CREATE_TABLE_LIKE_COMMENTS = 16,
    CREATE_TABLE_LIKE_ALL = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexElem {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub expr: *mut Node,
    pub indexcolname: *mut ::std::os::raw::c_char,
    pub collation: *mut List,
    pub opclass: *mut List,
    pub ordering: SortByDir,
    pub nulls_ordering: SortByNulls,
}
#[test]
fn bindgen_test_layout_IndexElem() {
    assert_eq!(::std::mem::size_of::<IndexElem>() , 56usize);
    assert_eq!(::std::mem::align_of::<IndexElem>() , 8usize);
}
impl Clone for IndexElem {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DefElemAction {
    DEFELEM_UNSPEC = 0,
    DEFELEM_SET = 1,
    DEFELEM_ADD = 2,
    DEFELEM_DROP = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DefElem {
    pub type_: NodeTag,
    pub defnamespace: *mut ::std::os::raw::c_char,
    pub defname: *mut ::std::os::raw::c_char,
    pub arg: *mut Node,
    pub defaction: DefElemAction,
}
#[test]
fn bindgen_test_layout_DefElem() {
    assert_eq!(::std::mem::size_of::<DefElem>() , 40usize);
    assert_eq!(::std::mem::align_of::<DefElem>() , 8usize);
}
impl Clone for DefElem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockingClause {
    pub type_: NodeTag,
    pub lockedRels: *mut List,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
}
#[test]
fn bindgen_test_layout_LockingClause() {
    assert_eq!(::std::mem::size_of::<LockingClause>() , 24usize);
    assert_eq!(::std::mem::align_of::<LockingClause>() , 8usize);
}
impl Clone for LockingClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XmlSerialize {
    pub type_: NodeTag,
    pub xmloption: XmlOptionType,
    pub expr: *mut Node,
    pub typeName: *mut TypeName,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_XmlSerialize() {
    assert_eq!(::std::mem::size_of::<XmlSerialize>() , 32usize);
    assert_eq!(::std::mem::align_of::<XmlSerialize>() , 8usize);
}
impl Clone for XmlSerialize {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RTEKind {
    RTE_RELATION = 0,
    RTE_SUBQUERY = 1,
    RTE_JOIN = 2,
    RTE_FUNCTION = 3,
    RTE_VALUES = 4,
    RTE_CTE = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RangeTblEntry {
    pub type_: NodeTag,
    pub rtekind: RTEKind,
    pub relid: Oid,
    pub relkind: ::std::os::raw::c_char,
    pub tablesample: *mut SampleScan_TableSampleClause,
    pub subquery: *mut Query,
    pub security_barrier: bool_,
    pub jointype: JoinType,
    pub joinaliasvars: *mut List,
    pub functions: *mut List,
    pub funcordinality: bool_,
    pub values_lists: *mut List,
    pub values_collations: *mut List,
    pub ctename: *mut ::std::os::raw::c_char,
    pub ctelevelsup: Index,
    pub self_reference: bool_,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
    pub alias: *mut Alias,
    pub eref: *mut Alias,
    pub lateral: bool_,
    pub inh: bool_,
    pub inFromCl: bool_,
    pub requiredPerms: AclMode,
    pub checkAsUser: Oid,
    pub selectedCols: *mut Bitmapset,
    pub insertedCols: *mut Bitmapset,
    pub updatedCols: *mut Bitmapset,
    pub securityQuals: *mut List,
}
#[test]
fn bindgen_test_layout_RangeTblEntry() {
    assert_eq!(::std::mem::size_of::<RangeTblEntry>() , 184usize);
    assert_eq!(::std::mem::align_of::<RangeTblEntry>() , 8usize);
}
impl Clone for RangeTblEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RangeTblFunction {
    pub type_: NodeTag,
    pub funcexpr: *mut Node,
    pub funccolcount: ::std::os::raw::c_int,
    pub funccolnames: *mut List,
    pub funccoltypes: *mut List,
    pub funccoltypmods: *mut List,
    pub funccolcollations: *mut List,
    pub funcparams: *mut Bitmapset,
}
#[test]
fn bindgen_test_layout_RangeTblFunction() {
    assert_eq!(::std::mem::size_of::<RangeTblFunction>() , 64usize);
    assert_eq!(::std::mem::align_of::<RangeTblFunction>() , 8usize);
}
impl Clone for RangeTblFunction {
    fn clone(&self) -> Self { *self }
}
pub type TableSampleClause = SampleScan_TableSampleClause;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WCOKind {
    WCO_VIEW_CHECK = 0,
    WCO_RLS_INSERT_CHECK = 1,
    WCO_RLS_UPDATE_CHECK = 2,
    WCO_RLS_CONFLICT_CHECK = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WithCheckOption {
    pub type_: NodeTag,
    pub kind: WCOKind,
    pub relname: *mut ::std::os::raw::c_char,
    pub polname: *mut ::std::os::raw::c_char,
    pub qual: *mut Node,
    pub cascaded: bool_,
}
#[test]
fn bindgen_test_layout_WithCheckOption() {
    assert_eq!(::std::mem::size_of::<WithCheckOption>() , 40usize);
    assert_eq!(::std::mem::align_of::<WithCheckOption>() , 8usize);
}
impl Clone for WithCheckOption {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SortGroupClause {
    pub type_: NodeTag,
    pub tleSortGroupRef: Index,
    pub eqop: Oid,
    pub sortop: Oid,
    pub nulls_first: bool_,
    pub hashable: bool_,
}
#[test]
fn bindgen_test_layout_SortGroupClause() {
    assert_eq!(::std::mem::size_of::<SortGroupClause>() , 20usize);
    assert_eq!(::std::mem::align_of::<SortGroupClause>() , 4usize);
}
impl Clone for SortGroupClause {
    fn clone(&self) -> Self { *self }
}
pub const GROUPING_SET_EMPTY: _bindgen_ty_57 =
    _bindgen_ty_57::GROUPING_SET_EMPTY;
pub const GROUPING_SET_SIMPLE: _bindgen_ty_57 =
    _bindgen_ty_57::GROUPING_SET_SIMPLE;
pub const GROUPING_SET_ROLLUP: _bindgen_ty_57 =
    _bindgen_ty_57::GROUPING_SET_ROLLUP;
pub const GROUPING_SET_CUBE: _bindgen_ty_57 =
    _bindgen_ty_57::GROUPING_SET_CUBE;
pub const GROUPING_SET_SETS: _bindgen_ty_57 =
    _bindgen_ty_57::GROUPING_SET_SETS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_57 {
    GROUPING_SET_EMPTY = 0,
    GROUPING_SET_SIMPLE = 1,
    GROUPING_SET_ROLLUP = 2,
    GROUPING_SET_CUBE = 3,
    GROUPING_SET_SETS = 4,
}
pub use self::_bindgen_ty_57 as GroupingSetKind;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GroupingSet {
    pub type_: NodeTag,
    pub kind: GroupingSetKind,
    pub content: *mut List,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_GroupingSet() {
    assert_eq!(::std::mem::size_of::<GroupingSet>() , 24usize);
    assert_eq!(::std::mem::align_of::<GroupingSet>() , 8usize);
}
impl Clone for GroupingSet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WindowClause {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub refname: *mut ::std::os::raw::c_char,
    pub partitionClause: *mut List,
    pub orderClause: *mut List,
    pub frameOptions: ::std::os::raw::c_int,
    pub startOffset: *mut Node,
    pub endOffset: *mut Node,
    pub winref: Index,
    pub copiedOrder: bool_,
}
#[test]
fn bindgen_test_layout_WindowClause() {
    assert_eq!(::std::mem::size_of::<WindowClause>() , 72usize);
    assert_eq!(::std::mem::align_of::<WindowClause>() , 8usize);
}
impl Clone for WindowClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RowMarkClause {
    pub type_: NodeTag,
    pub rti: Index,
    pub strength: LockClauseStrength,
    pub waitPolicy: LockWaitPolicy,
    pub pushedDown: bool_,
}
#[test]
fn bindgen_test_layout_RowMarkClause() {
    assert_eq!(::std::mem::size_of::<RowMarkClause>() , 20usize);
    assert_eq!(::std::mem::align_of::<RowMarkClause>() , 4usize);
}
impl Clone for RowMarkClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WithClause {
    pub type_: NodeTag,
    pub ctes: *mut List,
    pub recursive: bool_,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_WithClause() {
    assert_eq!(::std::mem::size_of::<WithClause>() , 24usize);
    assert_eq!(::std::mem::align_of::<WithClause>() , 8usize);
}
impl Clone for WithClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct InferClause {
    pub type_: NodeTag,
    pub indexElems: *mut List,
    pub whereClause: *mut Node,
    pub conname: *mut ::std::os::raw::c_char,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_InferClause() {
    assert_eq!(::std::mem::size_of::<InferClause>() , 40usize);
    assert_eq!(::std::mem::align_of::<InferClause>() , 8usize);
}
impl Clone for InferClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OnConflictClause {
    pub type_: NodeTag,
    pub action: OnConflictAction,
    pub infer: *mut InferClause,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub location: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_OnConflictClause() {
    assert_eq!(::std::mem::size_of::<OnConflictClause>() , 40usize);
    assert_eq!(::std::mem::align_of::<OnConflictClause>() , 8usize);
}
impl Clone for OnConflictClause {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CommonTableExpr {
    pub type_: NodeTag,
    pub ctename: *mut ::std::os::raw::c_char,
    pub aliascolnames: *mut List,
    pub ctequery: *mut Node,
    pub location: ::std::os::raw::c_int,
    pub cterecursive: bool_,
    pub cterefcount: ::std::os::raw::c_int,
    pub ctecolnames: *mut List,
    pub ctecoltypes: *mut List,
    pub ctecoltypmods: *mut List,
    pub ctecolcollations: *mut List,
}
#[test]
fn bindgen_test_layout_CommonTableExpr() {
    assert_eq!(::std::mem::size_of::<CommonTableExpr>() , 80usize);
    assert_eq!(::std::mem::align_of::<CommonTableExpr>() , 8usize);
}
impl Clone for CommonTableExpr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct InsertStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cols: *mut List,
    pub selectStmt: *mut Node,
    pub onConflictClause: *mut OnConflictClause,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
#[test]
fn bindgen_test_layout_InsertStmt() {
    assert_eq!(::std::mem::size_of::<InsertStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<InsertStmt>() , 8usize);
}
impl Clone for InsertStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DeleteStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub usingClause: *mut List,
    pub whereClause: *mut Node,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
#[test]
fn bindgen_test_layout_DeleteStmt() {
    assert_eq!(::std::mem::size_of::<DeleteStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<DeleteStmt>() , 8usize);
}
impl Clone for DeleteStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UpdateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub targetList: *mut List,
    pub whereClause: *mut Node,
    pub fromClause: *mut List,
    pub returningList: *mut List,
    pub withClause: *mut WithClause,
}
#[test]
fn bindgen_test_layout_UpdateStmt() {
    assert_eq!(::std::mem::size_of::<UpdateStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<UpdateStmt>() , 8usize);
}
impl Clone for UpdateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SetOperation {
    SETOP_NONE = 0,
    SETOP_UNION = 1,
    SETOP_INTERSECT = 2,
    SETOP_EXCEPT = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SelectStmt {
    pub type_: NodeTag,
    pub distinctClause: *mut List,
    pub intoClause: *mut IntoClause,
    pub targetList: *mut List,
    pub fromClause: *mut List,
    pub whereClause: *mut Node,
    pub groupClause: *mut List,
    pub havingClause: *mut Node,
    pub windowClause: *mut List,
    pub valuesLists: *mut List,
    pub sortClause: *mut List,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
    pub lockingClause: *mut List,
    pub withClause: *mut WithClause,
    pub op: SetOperation,
    pub all: bool_,
    pub larg: *mut SelectStmt,
    pub rarg: *mut SelectStmt,
}
#[test]
fn bindgen_test_layout_SelectStmt() {
    assert_eq!(::std::mem::size_of::<SelectStmt>() , 144usize);
    assert_eq!(::std::mem::align_of::<SelectStmt>() , 8usize);
}
impl Clone for SelectStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SetOperationStmt {
    pub type_: NodeTag,
    pub op: SetOperation,
    pub all: bool_,
    pub larg: *mut Node,
    pub rarg: *mut Node,
    pub colTypes: *mut List,
    pub colTypmods: *mut List,
    pub colCollations: *mut List,
    pub groupClauses: *mut List,
}
#[test]
fn bindgen_test_layout_SetOperationStmt() {
    assert_eq!(::std::mem::size_of::<SetOperationStmt>() , 64usize);
    assert_eq!(::std::mem::align_of::<SetOperationStmt>() , 8usize);
}
impl Clone for SetOperationStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ObjectType {
    OBJECT_ACCESS_METHOD = 0,
    OBJECT_AGGREGATE = 1,
    OBJECT_AMOP = 2,
    OBJECT_AMPROC = 3,
    OBJECT_ATTRIBUTE = 4,
    OBJECT_CAST = 5,
    OBJECT_COLUMN = 6,
    OBJECT_COLLATION = 7,
    OBJECT_CONVERSION = 8,
    OBJECT_DATABASE = 9,
    OBJECT_DEFAULT = 10,
    OBJECT_DEFACL = 11,
    OBJECT_DOMAIN = 12,
    OBJECT_DOMCONSTRAINT = 13,
    OBJECT_EVENT_TRIGGER = 14,
    OBJECT_EXTENSION = 15,
    OBJECT_FDW = 16,
    OBJECT_FOREIGN_SERVER = 17,
    OBJECT_FOREIGN_TABLE = 18,
    OBJECT_FUNCTION = 19,
    OBJECT_INDEX = 20,
    OBJECT_LANGUAGE = 21,
    OBJECT_LARGEOBJECT = 22,
    OBJECT_MATVIEW = 23,
    OBJECT_OPCLASS = 24,
    OBJECT_OPERATOR = 25,
    OBJECT_OPFAMILY = 26,
    OBJECT_POLICY = 27,
    OBJECT_ROLE = 28,
    OBJECT_RULE = 29,
    OBJECT_SCHEMA = 30,
    OBJECT_SEQUENCE = 31,
    OBJECT_TABCONSTRAINT = 32,
    OBJECT_TABLE = 33,
    OBJECT_TABLESPACE = 34,
    OBJECT_TRANSFORM = 35,
    OBJECT_TRIGGER = 36,
    OBJECT_TSCONFIGURATION = 37,
    OBJECT_TSDICTIONARY = 38,
    OBJECT_TSPARSER = 39,
    OBJECT_TSTEMPLATE = 40,
    OBJECT_TYPE = 41,
    OBJECT_USER_MAPPING = 42,
    OBJECT_VIEW = 43,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateSchemaStmt {
    pub type_: NodeTag,
    pub schemaname: *mut ::std::os::raw::c_char,
    pub authrole: *mut Node,
    pub schemaElts: *mut List,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateSchemaStmt() {
    assert_eq!(::std::mem::size_of::<CreateSchemaStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<CreateSchemaStmt>() , 8usize);
}
impl Clone for CreateSchemaStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DropBehavior { DROP_RESTRICT = 0, DROP_CASCADE = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterTableStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub cmds: *mut List,
    pub relkind: ObjectType,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableStmt() {
    assert_eq!(::std::mem::size_of::<AlterTableStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterTableStmt>() , 8usize);
}
impl Clone for AlterTableStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AlterTableType {
    AT_AddColumn = 0,
    AT_AddColumnRecurse = 1,
    AT_AddColumnToView = 2,
    AT_ColumnDefault = 3,
    AT_DropNotNull = 4,
    AT_SetNotNull = 5,
    AT_SetStatistics = 6,
    AT_SetOptions = 7,
    AT_ResetOptions = 8,
    AT_SetStorage = 9,
    AT_DropColumn = 10,
    AT_DropColumnRecurse = 11,
    AT_AddIndex = 12,
    AT_ReAddIndex = 13,
    AT_AddConstraint = 14,
    AT_AddConstraintRecurse = 15,
    AT_ReAddConstraint = 16,
    AT_AlterConstraint = 17,
    AT_ValidateConstraint = 18,
    AT_ValidateConstraintRecurse = 19,
    AT_ProcessedConstraint = 20,
    AT_AddIndexConstraint = 21,
    AT_DropConstraint = 22,
    AT_DropConstraintRecurse = 23,
    AT_ReAddComment = 24,
    AT_AlterColumnType = 25,
    AT_AlterColumnGenericOptions = 26,
    AT_ChangeOwner = 27,
    AT_ClusterOn = 28,
    AT_DropCluster = 29,
    AT_SetLogged = 30,
    AT_SetUnLogged = 31,
    AT_AddOids = 32,
    AT_AddOidsRecurse = 33,
    AT_DropOids = 34,
    AT_SetTableSpace = 35,
    AT_SetRelOptions = 36,
    AT_ResetRelOptions = 37,
    AT_ReplaceRelOptions = 38,
    AT_EnableTrig = 39,
    AT_EnableAlwaysTrig = 40,
    AT_EnableReplicaTrig = 41,
    AT_DisableTrig = 42,
    AT_EnableTrigAll = 43,
    AT_DisableTrigAll = 44,
    AT_EnableTrigUser = 45,
    AT_DisableTrigUser = 46,
    AT_EnableRule = 47,
    AT_EnableAlwaysRule = 48,
    AT_EnableReplicaRule = 49,
    AT_DisableRule = 50,
    AT_AddInherit = 51,
    AT_DropInherit = 52,
    AT_AddOf = 53,
    AT_DropOf = 54,
    AT_ReplicaIdentity = 55,
    AT_EnableRowSecurity = 56,
    AT_DisableRowSecurity = 57,
    AT_ForceRowSecurity = 58,
    AT_NoForceRowSecurity = 59,
    AT_GenericOptions = 60,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ReplicaIdentityStmt {
    pub type_: NodeTag,
    pub identity_type: ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ReplicaIdentityStmt() {
    assert_eq!(::std::mem::size_of::<ReplicaIdentityStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<ReplicaIdentityStmt>() , 8usize);
}
impl Clone for ReplicaIdentityStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterTableCmd {
    pub type_: NodeTag,
    pub subtype: AlterTableType,
    pub name: *mut ::std::os::raw::c_char,
    pub newowner: *mut Node,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableCmd() {
    assert_eq!(::std::mem::size_of::<AlterTableCmd>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterTableCmd>() , 8usize);
}
impl Clone for AlterTableCmd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterDomainStmt {
    pub type_: NodeTag,
    pub subtype: ::std::os::raw::c_char,
    pub typeName: *mut List,
    pub name: *mut ::std::os::raw::c_char,
    pub def: *mut Node,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterDomainStmt() {
    assert_eq!(::std::mem::size_of::<AlterDomainStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterDomainStmt>() , 8usize);
}
impl Clone for AlterDomainStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GrantTargetType {
    ACL_TARGET_OBJECT = 0,
    ACL_TARGET_ALL_IN_SCHEMA = 1,
    ACL_TARGET_DEFAULTS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum GrantObjectType {
    ACL_OBJECT_COLUMN = 0,
    ACL_OBJECT_RELATION = 1,
    ACL_OBJECT_SEQUENCE = 2,
    ACL_OBJECT_DATABASE = 3,
    ACL_OBJECT_DOMAIN = 4,
    ACL_OBJECT_FDW = 5,
    ACL_OBJECT_FOREIGN_SERVER = 6,
    ACL_OBJECT_FUNCTION = 7,
    ACL_OBJECT_LANGUAGE = 8,
    ACL_OBJECT_LARGEOBJECT = 9,
    ACL_OBJECT_NAMESPACE = 10,
    ACL_OBJECT_TABLESPACE = 11,
    ACL_OBJECT_TYPE = 12,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrantStmt {
    pub type_: NodeTag,
    pub is_grant: bool_,
    pub targtype: GrantTargetType,
    pub objtype: GrantObjectType,
    pub objects: *mut List,
    pub privileges: *mut List,
    pub grantees: *mut List,
    pub grant_option: bool_,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_GrantStmt() {
    assert_eq!(::std::mem::size_of::<GrantStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<GrantStmt>() , 8usize);
}
impl Clone for GrantStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FuncWithArgs {
    pub type_: NodeTag,
    pub funcname: *mut List,
    pub funcargs: *mut List,
}
#[test]
fn bindgen_test_layout_FuncWithArgs() {
    assert_eq!(::std::mem::size_of::<FuncWithArgs>() , 24usize);
    assert_eq!(::std::mem::align_of::<FuncWithArgs>() , 8usize);
}
impl Clone for FuncWithArgs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AccessPriv {
    pub type_: NodeTag,
    pub priv_name: *mut ::std::os::raw::c_char,
    pub cols: *mut List,
}
#[test]
fn bindgen_test_layout_AccessPriv() {
    assert_eq!(::std::mem::size_of::<AccessPriv>() , 24usize);
    assert_eq!(::std::mem::align_of::<AccessPriv>() , 8usize);
}
impl Clone for AccessPriv {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GrantRoleStmt {
    pub type_: NodeTag,
    pub granted_roles: *mut List,
    pub grantee_roles: *mut List,
    pub is_grant: bool_,
    pub admin_opt: bool_,
    pub grantor: *mut Node,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_GrantRoleStmt() {
    assert_eq!(::std::mem::size_of::<GrantRoleStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<GrantRoleStmt>() , 8usize);
}
impl Clone for GrantRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterDefaultPrivilegesStmt {
    pub type_: NodeTag,
    pub options: *mut List,
    pub action: *mut GrantStmt,
}
#[test]
fn bindgen_test_layout_AlterDefaultPrivilegesStmt() {
    assert_eq!(::std::mem::size_of::<AlterDefaultPrivilegesStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<AlterDefaultPrivilegesStmt>() , 8usize);
}
impl Clone for AlterDefaultPrivilegesStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CopyStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub query: *mut Node,
    pub attlist: *mut List,
    pub is_from: bool_,
    pub is_program: bool_,
    pub filename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CopyStmt() {
    assert_eq!(::std::mem::size_of::<CopyStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<CopyStmt>() , 8usize);
}
impl Clone for CopyStmt {
    fn clone(&self) -> Self { *self }
}
pub const VAR_SET_VALUE: _bindgen_ty_58 = _bindgen_ty_58::VAR_SET_VALUE;
pub const VAR_SET_DEFAULT: _bindgen_ty_58 = _bindgen_ty_58::VAR_SET_DEFAULT;
pub const VAR_SET_CURRENT: _bindgen_ty_58 = _bindgen_ty_58::VAR_SET_CURRENT;
pub const VAR_SET_MULTI: _bindgen_ty_58 = _bindgen_ty_58::VAR_SET_MULTI;
pub const VAR_RESET: _bindgen_ty_58 = _bindgen_ty_58::VAR_RESET;
pub const VAR_RESET_ALL: _bindgen_ty_58 = _bindgen_ty_58::VAR_RESET_ALL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_58 {
    VAR_SET_VALUE = 0,
    VAR_SET_DEFAULT = 1,
    VAR_SET_CURRENT = 2,
    VAR_SET_MULTI = 3,
    VAR_RESET = 4,
    VAR_RESET_ALL = 5,
}
pub use self::_bindgen_ty_58 as VariableSetKind;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VariableSetStmt {
    pub type_: NodeTag,
    pub kind: VariableSetKind,
    pub name: *mut ::std::os::raw::c_char,
    pub args: *mut List,
    pub is_local: bool_,
}
#[test]
fn bindgen_test_layout_VariableSetStmt() {
    assert_eq!(::std::mem::size_of::<VariableSetStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<VariableSetStmt>() , 8usize);
}
impl Clone for VariableSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VariableShowStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VariableShowStmt() {
    assert_eq!(::std::mem::size_of::<VariableShowStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<VariableShowStmt>() , 8usize);
}
impl Clone for VariableShowStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub tableElts: *mut List,
    pub inhRelations: *mut List,
    pub ofTypename: *mut TypeName,
    pub constraints: *mut List,
    pub options: *mut List,
    pub oncommit: OnCommitAction,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateStmt() {
    assert_eq!(::std::mem::size_of::<CreateStmt>() , 80usize);
    assert_eq!(::std::mem::align_of::<CreateStmt>() , 8usize);
}
impl Clone for CreateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ConstrType {
    CONSTR_NULL = 0,
    CONSTR_NOTNULL = 1,
    CONSTR_DEFAULT = 2,
    CONSTR_CHECK = 3,
    CONSTR_PRIMARY = 4,
    CONSTR_UNIQUE = 5,
    CONSTR_EXCLUSION = 6,
    CONSTR_FOREIGN = 7,
    CONSTR_ATTR_DEFERRABLE = 8,
    CONSTR_ATTR_NOT_DEFERRABLE = 9,
    CONSTR_ATTR_DEFERRED = 10,
    CONSTR_ATTR_IMMEDIATE = 11,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Constraint {
    pub type_: NodeTag,
    pub contype: ConstrType,
    pub conname: *mut ::std::os::raw::c_char,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub location: ::std::os::raw::c_int,
    pub is_no_inherit: bool_,
    pub raw_expr: *mut Node,
    pub cooked_expr: *mut ::std::os::raw::c_char,
    pub keys: *mut List,
    pub exclusions: *mut List,
    pub options: *mut List,
    pub indexname: *mut ::std::os::raw::c_char,
    pub indexspace: *mut ::std::os::raw::c_char,
    pub access_method: *mut ::std::os::raw::c_char,
    pub where_clause: *mut Node,
    pub pktable: *mut RangeVar,
    pub fk_attrs: *mut List,
    pub pk_attrs: *mut List,
    pub fk_matchtype: ::std::os::raw::c_char,
    pub fk_upd_action: ::std::os::raw::c_char,
    pub fk_del_action: ::std::os::raw::c_char,
    pub old_conpfeqop: *mut List,
    pub old_pktable_oid: Oid,
    pub skip_validation: bool_,
    pub initially_valid: bool_,
}
#[test]
fn bindgen_test_layout_Constraint() {
    assert_eq!(::std::mem::size_of::<Constraint>() , 152usize);
    assert_eq!(::std::mem::align_of::<Constraint>() , 8usize);
}
impl Clone for Constraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub owner: *mut Node,
    pub location: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateTableSpaceStmt() {
    assert_eq!(::std::mem::size_of::<CreateTableSpaceStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<CreateTableSpaceStmt>() , 8usize);
}
impl Clone for CreateTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DropTableSpaceStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropTableSpaceStmt() {
    assert_eq!(::std::mem::size_of::<DropTableSpaceStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<DropTableSpaceStmt>() , 8usize);
}
impl Clone for DropTableSpaceStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterTableSpaceOptionsStmt {
    pub type_: NodeTag,
    pub tablespacename: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub isReset: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableSpaceOptionsStmt() {
    assert_eq!(::std::mem::size_of::<AlterTableSpaceOptionsStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterTableSpaceOptionsStmt>() , 8usize);
}
impl Clone for AlterTableSpaceOptionsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterTableMoveAllStmt {
    pub type_: NodeTag,
    pub orig_tablespacename: *mut ::std::os::raw::c_char,
    pub objtype: ObjectType,
    pub roles: *mut List,
    pub new_tablespacename: *mut ::std::os::raw::c_char,
    pub nowait: bool_,
}
#[test]
fn bindgen_test_layout_AlterTableMoveAllStmt() {
    assert_eq!(::std::mem::size_of::<AlterTableMoveAllStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<AlterTableMoveAllStmt>() , 8usize);
}
impl Clone for AlterTableMoveAllStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub if_not_exists: bool_,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateExtensionStmt() {
    assert_eq!(::std::mem::size_of::<CreateExtensionStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<CreateExtensionStmt>() , 8usize);
}
impl Clone for CreateExtensionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterExtensionStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterExtensionStmt() {
    assert_eq!(::std::mem::size_of::<AlterExtensionStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<AlterExtensionStmt>() , 8usize);
}
impl Clone for AlterExtensionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterExtensionContentsStmt {
    pub type_: NodeTag,
    pub extname: *mut ::std::os::raw::c_char,
    pub action: ::std::os::raw::c_int,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
}
#[test]
fn bindgen_test_layout_AlterExtensionContentsStmt() {
    assert_eq!(::std::mem::size_of::<AlterExtensionContentsStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterExtensionContentsStmt>() , 8usize);
}
impl Clone for AlterExtensionContentsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateFdwStmt() {
    assert_eq!(::std::mem::size_of::<CreateFdwStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<CreateFdwStmt>() , 8usize);
}
impl Clone for CreateFdwStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterFdwStmt {
    pub type_: NodeTag,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub func_options: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterFdwStmt() {
    assert_eq!(::std::mem::size_of::<AlterFdwStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterFdwStmt>() , 8usize);
}
impl Clone for AlterFdwStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateForeignServerStmt() {
    assert_eq!(::std::mem::size_of::<CreateForeignServerStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<CreateForeignServerStmt>() , 8usize);
}
impl Clone for CreateForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterForeignServerStmt {
    pub type_: NodeTag,
    pub servername: *mut ::std::os::raw::c_char,
    pub version: *mut ::std::os::raw::c_char,
    pub options: *mut List,
    pub has_version: bool_,
}
#[test]
fn bindgen_test_layout_AlterForeignServerStmt() {
    assert_eq!(::std::mem::size_of::<AlterForeignServerStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterForeignServerStmt>() , 8usize);
}
impl Clone for AlterForeignServerStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateForeignTableStmt {
    pub base: CreateStmt,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateForeignTableStmt() {
    assert_eq!(::std::mem::size_of::<CreateForeignTableStmt>() , 96usize);
    assert_eq!(::std::mem::align_of::<CreateForeignTableStmt>() , 8usize);
}
impl Clone for CreateForeignTableStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut Node,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateUserMappingStmt() {
    assert_eq!(::std::mem::size_of::<CreateUserMappingStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<CreateUserMappingStmt>() , 8usize);
}
impl Clone for CreateUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut Node,
    pub servername: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterUserMappingStmt() {
    assert_eq!(::std::mem::size_of::<AlterUserMappingStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterUserMappingStmt>() , 8usize);
}
impl Clone for AlterUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DropUserMappingStmt {
    pub type_: NodeTag,
    pub user: *mut Node,
    pub servername: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropUserMappingStmt() {
    assert_eq!(::std::mem::size_of::<DropUserMappingStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<DropUserMappingStmt>() , 8usize);
}
impl Clone for DropUserMappingStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ImportForeignSchemaType {
    FDW_IMPORT_SCHEMA_ALL = 0,
    FDW_IMPORT_SCHEMA_LIMIT_TO = 1,
    FDW_IMPORT_SCHEMA_EXCEPT = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ImportForeignSchemaStmt {
    pub type_: NodeTag,
    pub server_name: *mut ::std::os::raw::c_char,
    pub remote_schema: *mut ::std::os::raw::c_char,
    pub local_schema: *mut ::std::os::raw::c_char,
    pub list_type: ImportForeignSchemaType,
    pub table_list: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ImportForeignSchemaStmt() {
    assert_eq!(::std::mem::size_of::<ImportForeignSchemaStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<ImportForeignSchemaStmt>() , 8usize);
}
impl Clone for ImportForeignSchemaStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreatePolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub cmd_name: *mut ::std::os::raw::c_char,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
#[test]
fn bindgen_test_layout_CreatePolicyStmt() {
    assert_eq!(::std::mem::size_of::<CreatePolicyStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<CreatePolicyStmt>() , 8usize);
}
impl Clone for CreatePolicyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterPolicyStmt {
    pub type_: NodeTag,
    pub policy_name: *mut ::std::os::raw::c_char,
    pub table: *mut RangeVar,
    pub roles: *mut List,
    pub qual: *mut Node,
    pub with_check: *mut Node,
}
#[test]
fn bindgen_test_layout_AlterPolicyStmt() {
    assert_eq!(::std::mem::size_of::<AlterPolicyStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<AlterPolicyStmt>() , 8usize);
}
impl Clone for AlterPolicyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateAmStmt {
    pub type_: NodeTag,
    pub amname: *mut ::std::os::raw::c_char,
    pub handler_name: *mut List,
    pub amtype: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CreateAmStmt() {
    assert_eq!(::std::mem::size_of::<CreateAmStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<CreateAmStmt>() , 8usize);
}
impl Clone for CreateAmStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub funcname: *mut List,
    pub args: *mut List,
    pub row: bool_,
    pub timing: int16,
    pub events: int16,
    pub columns: *mut List,
    pub whenClause: *mut Node,
    pub isconstraint: bool_,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub constrrel: *mut RangeVar,
}
#[test]
fn bindgen_test_layout_CreateTrigStmt() {
    assert_eq!(::std::mem::size_of::<CreateTrigStmt>() , 80usize);
    assert_eq!(::std::mem::align_of::<CreateTrigStmt>() , 8usize);
}
impl Clone for CreateTrigStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub eventname: *mut ::std::os::raw::c_char,
    pub whenclause: *mut List,
    pub funcname: *mut List,
}
#[test]
fn bindgen_test_layout_CreateEventTrigStmt() {
    assert_eq!(::std::mem::size_of::<CreateEventTrigStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<CreateEventTrigStmt>() , 8usize);
}
impl Clone for CreateEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterEventTrigStmt {
    pub type_: NodeTag,
    pub trigname: *mut ::std::os::raw::c_char,
    pub tgenabled: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_AlterEventTrigStmt() {
    assert_eq!(::std::mem::size_of::<AlterEventTrigStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<AlterEventTrigStmt>() , 8usize);
}
impl Clone for AlterEventTrigStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreatePLangStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub plname: *mut ::std::os::raw::c_char,
    pub plhandler: *mut List,
    pub plinline: *mut List,
    pub plvalidator: *mut List,
    pub pltrusted: bool_,
}
#[test]
fn bindgen_test_layout_CreatePLangStmt() {
    assert_eq!(::std::mem::size_of::<CreatePLangStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<CreatePLangStmt>() , 8usize);
}
impl Clone for CreatePLangStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RoleStmtType {
    ROLESTMT_ROLE = 0,
    ROLESTMT_USER = 1,
    ROLESTMT_GROUP = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateRoleStmt {
    pub type_: NodeTag,
    pub stmt_type: RoleStmtType,
    pub role: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreateRoleStmt() {
    assert_eq!(::std::mem::size_of::<CreateRoleStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<CreateRoleStmt>() , 8usize);
}
impl Clone for CreateRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterRoleStmt {
    pub type_: NodeTag,
    pub role: *mut Node,
    pub options: *mut List,
    pub action: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_AlterRoleStmt() {
    assert_eq!(::std::mem::size_of::<AlterRoleStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterRoleStmt>() , 8usize);
}
impl Clone for AlterRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterRoleSetStmt {
    pub type_: NodeTag,
    pub role: *mut Node,
    pub database: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterRoleSetStmt() {
    assert_eq!(::std::mem::size_of::<AlterRoleSetStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterRoleSetStmt>() , 8usize);
}
impl Clone for AlterRoleSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DropRoleStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropRoleStmt() {
    assert_eq!(::std::mem::size_of::<DropRoleStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<DropRoleStmt>() , 8usize);
}
impl Clone for DropRoleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub ownerId: Oid,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateSeqStmt() {
    assert_eq!(::std::mem::size_of::<CreateSeqStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<CreateSeqStmt>() , 8usize);
}
impl Clone for CreateSeqStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterSeqStmt {
    pub type_: NodeTag,
    pub sequence: *mut RangeVar,
    pub options: *mut List,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterSeqStmt() {
    assert_eq!(::std::mem::size_of::<AlterSeqStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterSeqStmt>() , 8usize);
}
impl Clone for AlterSeqStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DefineStmt {
    pub type_: NodeTag,
    pub kind: ObjectType,
    pub oldstyle: bool_,
    pub defnames: *mut List,
    pub args: *mut List,
    pub definition: *mut List,
}
#[test]
fn bindgen_test_layout_DefineStmt() {
    assert_eq!(::std::mem::size_of::<DefineStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<DefineStmt>() , 8usize);
}
impl Clone for DefineStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateDomainStmt {
    pub type_: NodeTag,
    pub domainname: *mut List,
    pub typeName: *mut TypeName,
    pub collClause: *mut CollateClause,
    pub constraints: *mut List,
}
#[test]
fn bindgen_test_layout_CreateDomainStmt() {
    assert_eq!(::std::mem::size_of::<CreateDomainStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<CreateDomainStmt>() , 8usize);
}
impl Clone for CreateDomainStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateOpClassStmt {
    pub type_: NodeTag,
    pub opclassname: *mut List,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub datatype: *mut TypeName,
    pub items: *mut List,
    pub isDefault: bool_,
}
#[test]
fn bindgen_test_layout_CreateOpClassStmt() {
    assert_eq!(::std::mem::size_of::<CreateOpClassStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<CreateOpClassStmt>() , 8usize);
}
impl Clone for CreateOpClassStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateOpClassItem {
    pub type_: NodeTag,
    pub itemtype: ::std::os::raw::c_int,
    pub name: *mut List,
    pub args: *mut List,
    pub number: ::std::os::raw::c_int,
    pub order_family: *mut List,
    pub class_args: *mut List,
    pub storedtype: *mut TypeName,
}
#[test]
fn bindgen_test_layout_CreateOpClassItem() {
    assert_eq!(::std::mem::size_of::<CreateOpClassItem>() , 56usize);
    assert_eq!(::std::mem::align_of::<CreateOpClassItem>() , 8usize);
}
impl Clone for CreateOpClassItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CreateOpFamilyStmt() {
    assert_eq!(::std::mem::size_of::<CreateOpFamilyStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<CreateOpFamilyStmt>() , 8usize);
}
impl Clone for CreateOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterOpFamilyStmt {
    pub type_: NodeTag,
    pub opfamilyname: *mut List,
    pub amname: *mut ::std::os::raw::c_char,
    pub isDrop: bool_,
    pub items: *mut List,
}
#[test]
fn bindgen_test_layout_AlterOpFamilyStmt() {
    assert_eq!(::std::mem::size_of::<AlterOpFamilyStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterOpFamilyStmt>() , 8usize);
}
impl Clone for AlterOpFamilyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DropStmt {
    pub type_: NodeTag,
    pub objects: *mut List,
    pub arguments: *mut List,
    pub removeType: ObjectType,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
    pub concurrent: bool_,
}
#[test]
fn bindgen_test_layout_DropStmt() {
    assert_eq!(::std::mem::size_of::<DropStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<DropStmt>() , 8usize);
}
impl Clone for DropStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TruncateStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub restart_seqs: bool_,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_TruncateStmt() {
    assert_eq!(::std::mem::size_of::<TruncateStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<TruncateStmt>() , 8usize);
}
impl Clone for TruncateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CommentStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub comment: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_CommentStmt() {
    assert_eq!(::std::mem::size_of::<CommentStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<CommentStmt>() , 8usize);
}
impl Clone for CommentStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SecLabelStmt {
    pub type_: NodeTag,
    pub objtype: ObjectType,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub provider: *mut ::std::os::raw::c_char,
    pub label: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_SecLabelStmt() {
    assert_eq!(::std::mem::size_of::<SecLabelStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<SecLabelStmt>() , 8usize);
}
impl Clone for SecLabelStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DeclareCursorStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
    pub query: *mut Node,
}
#[test]
fn bindgen_test_layout_DeclareCursorStmt() {
    assert_eq!(::std::mem::size_of::<DeclareCursorStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<DeclareCursorStmt>() , 8usize);
}
impl Clone for DeclareCursorStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClosePortalStmt {
    pub type_: NodeTag,
    pub portalname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ClosePortalStmt() {
    assert_eq!(::std::mem::size_of::<ClosePortalStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<ClosePortalStmt>() , 8usize);
}
impl Clone for ClosePortalStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FetchDirection {
    FETCH_FORWARD = 0,
    FETCH_BACKWARD = 1,
    FETCH_ABSOLUTE = 2,
    FETCH_RELATIVE = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FetchStmt {
    pub type_: NodeTag,
    pub direction: FetchDirection,
    pub howMany: ::std::os::raw::c_long,
    pub portalname: *mut ::std::os::raw::c_char,
    pub ismove: bool_,
}
#[test]
fn bindgen_test_layout_FetchStmt() {
    assert_eq!(::std::mem::size_of::<FetchStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<FetchStmt>() , 8usize);
}
impl Clone for FetchStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexStmt {
    pub type_: NodeTag,
    pub idxname: *mut ::std::os::raw::c_char,
    pub relation: *mut RangeVar,
    pub accessMethod: *mut ::std::os::raw::c_char,
    pub tableSpace: *mut ::std::os::raw::c_char,
    pub indexParams: *mut List,
    pub options: *mut List,
    pub whereClause: *mut Node,
    pub excludeOpNames: *mut List,
    pub idxcomment: *mut ::std::os::raw::c_char,
    pub indexOid: Oid,
    pub oldNode: Oid,
    pub unique: bool_,
    pub primary: bool_,
    pub isconstraint: bool_,
    pub deferrable: bool_,
    pub initdeferred: bool_,
    pub transformed: bool_,
    pub concurrent: bool_,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_IndexStmt() {
    assert_eq!(::std::mem::size_of::<IndexStmt>() , 96usize);
    assert_eq!(::std::mem::align_of::<IndexStmt>() , 8usize);
}
impl Clone for IndexStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateFunctionStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub funcname: *mut List,
    pub parameters: *mut List,
    pub returnType: *mut TypeName,
    pub options: *mut List,
    pub withClause: *mut List,
}
#[test]
fn bindgen_test_layout_CreateFunctionStmt() {
    assert_eq!(::std::mem::size_of::<CreateFunctionStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<CreateFunctionStmt>() , 8usize);
}
impl Clone for CreateFunctionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum FunctionParameterMode {
    FUNC_PARAM_IN = 105,
    FUNC_PARAM_OUT = 111,
    FUNC_PARAM_INOUT = 98,
    FUNC_PARAM_VARIADIC = 118,
    FUNC_PARAM_TABLE = 116,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FunctionParameter {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argType: *mut TypeName,
    pub mode: FunctionParameterMode,
    pub defexpr: *mut Node,
}
#[test]
fn bindgen_test_layout_FunctionParameter() {
    assert_eq!(::std::mem::size_of::<FunctionParameter>() , 40usize);
    assert_eq!(::std::mem::align_of::<FunctionParameter>() , 8usize);
}
impl Clone for FunctionParameter {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterFunctionStmt {
    pub type_: NodeTag,
    pub func: *mut FuncWithArgs,
    pub actions: *mut List,
}
#[test]
fn bindgen_test_layout_AlterFunctionStmt() {
    assert_eq!(::std::mem::size_of::<AlterFunctionStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<AlterFunctionStmt>() , 8usize);
}
impl Clone for AlterFunctionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DoStmt {
    pub type_: NodeTag,
    pub args: *mut List,
}
#[test]
fn bindgen_test_layout_DoStmt() {
    assert_eq!(::std::mem::size_of::<DoStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<DoStmt>() , 8usize);
}
impl Clone for DoStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct InlineCodeBlock {
    pub type_: NodeTag,
    pub source_text: *mut ::std::os::raw::c_char,
    pub langOid: Oid,
    pub langIsTrusted: bool_,
}
#[test]
fn bindgen_test_layout_InlineCodeBlock() {
    assert_eq!(::std::mem::size_of::<InlineCodeBlock>() , 24usize);
    assert_eq!(::std::mem::align_of::<InlineCodeBlock>() , 8usize);
}
impl Clone for InlineCodeBlock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RenameStmt {
    pub type_: NodeTag,
    pub renameType: ObjectType,
    pub relationType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub subname: *mut ::std::os::raw::c_char,
    pub newname: *mut ::std::os::raw::c_char,
    pub behavior: DropBehavior,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_RenameStmt() {
    assert_eq!(::std::mem::size_of::<RenameStmt>() , 64usize);
    assert_eq!(::std::mem::align_of::<RenameStmt>() , 8usize);
}
impl Clone for RenameStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterObjectDependsStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub objname: *mut List,
    pub objargs: *mut List,
    pub extname: *mut Value,
}
#[test]
fn bindgen_test_layout_AlterObjectDependsStmt() {
    assert_eq!(::std::mem::size_of::<AlterObjectDependsStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterObjectDependsStmt>() , 8usize);
}
impl Clone for AlterObjectDependsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterObjectSchemaStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newschema: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterObjectSchemaStmt() {
    assert_eq!(::std::mem::size_of::<AlterObjectSchemaStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<AlterObjectSchemaStmt>() , 8usize);
}
impl Clone for AlterObjectSchemaStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterOwnerStmt {
    pub type_: NodeTag,
    pub objectType: ObjectType,
    pub relation: *mut RangeVar,
    pub object: *mut List,
    pub objarg: *mut List,
    pub newowner: *mut Node,
}
#[test]
fn bindgen_test_layout_AlterOwnerStmt() {
    assert_eq!(::std::mem::size_of::<AlterOwnerStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterOwnerStmt>() , 8usize);
}
impl Clone for AlterOwnerStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterOperatorStmt {
    pub type_: NodeTag,
    pub opername: *mut List,
    pub operargs: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterOperatorStmt() {
    assert_eq!(::std::mem::size_of::<AlterOperatorStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<AlterOperatorStmt>() , 8usize);
}
impl Clone for AlterOperatorStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RuleStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub rulename: *mut ::std::os::raw::c_char,
    pub whereClause: *mut Node,
    pub event: CmdType,
    pub instead: bool_,
    pub actions: *mut List,
    pub replace: bool_,
}
#[test]
fn bindgen_test_layout_RuleStmt() {
    assert_eq!(::std::mem::size_of::<RuleStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<RuleStmt>() , 8usize);
}
impl Clone for RuleStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct NotifyStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
    pub payload: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NotifyStmt() {
    assert_eq!(::std::mem::size_of::<NotifyStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<NotifyStmt>() , 8usize);
}
impl Clone for NotifyStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ListenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_ListenStmt() {
    assert_eq!(::std::mem::size_of::<ListenStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<ListenStmt>() , 8usize);
}
impl Clone for ListenStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UnlistenStmt {
    pub type_: NodeTag,
    pub conditionname: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_UnlistenStmt() {
    assert_eq!(::std::mem::size_of::<UnlistenStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<UnlistenStmt>() , 8usize);
}
impl Clone for UnlistenStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TransactionStmtKind {
    TRANS_STMT_BEGIN = 0,
    TRANS_STMT_START = 1,
    TRANS_STMT_COMMIT = 2,
    TRANS_STMT_ROLLBACK = 3,
    TRANS_STMT_SAVEPOINT = 4,
    TRANS_STMT_RELEASE = 5,
    TRANS_STMT_ROLLBACK_TO = 6,
    TRANS_STMT_PREPARE = 7,
    TRANS_STMT_COMMIT_PREPARED = 8,
    TRANS_STMT_ROLLBACK_PREPARED = 9,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TransactionStmt {
    pub type_: NodeTag,
    pub kind: TransactionStmtKind,
    pub options: *mut List,
    pub gid: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_TransactionStmt() {
    assert_eq!(::std::mem::size_of::<TransactionStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<TransactionStmt>() , 8usize);
}
impl Clone for TransactionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CompositeTypeStmt {
    pub type_: NodeTag,
    pub typevar: *mut RangeVar,
    pub coldeflist: *mut List,
}
#[test]
fn bindgen_test_layout_CompositeTypeStmt() {
    assert_eq!(::std::mem::size_of::<CompositeTypeStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<CompositeTypeStmt>() , 8usize);
}
impl Clone for CompositeTypeStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub vals: *mut List,
}
#[test]
fn bindgen_test_layout_CreateEnumStmt() {
    assert_eq!(::std::mem::size_of::<CreateEnumStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<CreateEnumStmt>() , 8usize);
}
impl Clone for CreateEnumStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateRangeStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub params: *mut List,
}
#[test]
fn bindgen_test_layout_CreateRangeStmt() {
    assert_eq!(::std::mem::size_of::<CreateRangeStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<CreateRangeStmt>() , 8usize);
}
impl Clone for CreateRangeStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterEnumStmt {
    pub type_: NodeTag,
    pub typeName: *mut List,
    pub newVal: *mut ::std::os::raw::c_char,
    pub newValNeighbor: *mut ::std::os::raw::c_char,
    pub newValIsAfter: bool_,
    pub skipIfExists: bool_,
}
#[test]
fn bindgen_test_layout_AlterEnumStmt() {
    assert_eq!(::std::mem::size_of::<AlterEnumStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterEnumStmt>() , 8usize);
}
impl Clone for AlterEnumStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ViewCheckOption {
    NO_CHECK_OPTION = 0,
    LOCAL_CHECK_OPTION = 1,
    CASCADED_CHECK_OPTION = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ViewStmt {
    pub type_: NodeTag,
    pub view: *mut RangeVar,
    pub aliases: *mut List,
    pub query: *mut Node,
    pub replace: bool_,
    pub options: *mut List,
    pub withCheckOption: ViewCheckOption,
}
#[test]
fn bindgen_test_layout_ViewStmt() {
    assert_eq!(::std::mem::size_of::<ViewStmt>() , 56usize);
    assert_eq!(::std::mem::align_of::<ViewStmt>() , 8usize);
}
impl Clone for ViewStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LoadStmt {
    pub type_: NodeTag,
    pub filename: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_LoadStmt() {
    assert_eq!(::std::mem::size_of::<LoadStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<LoadStmt>() , 8usize);
}
impl Clone for LoadStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreatedbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_CreatedbStmt() {
    assert_eq!(::std::mem::size_of::<CreatedbStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<CreatedbStmt>() , 8usize);
}
impl Clone for CreatedbStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterDatabaseStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterDatabaseStmt() {
    assert_eq!(::std::mem::size_of::<AlterDatabaseStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<AlterDatabaseStmt>() , 8usize);
}
impl Clone for AlterDatabaseStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterDatabaseSetStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterDatabaseSetStmt() {
    assert_eq!(::std::mem::size_of::<AlterDatabaseSetStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<AlterDatabaseSetStmt>() , 8usize);
}
impl Clone for AlterDatabaseSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DropdbStmt {
    pub type_: NodeTag,
    pub dbname: *mut ::std::os::raw::c_char,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_DropdbStmt() {
    assert_eq!(::std::mem::size_of::<DropdbStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<DropdbStmt>() , 8usize);
}
impl Clone for DropdbStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterSystemStmt {
    pub type_: NodeTag,
    pub setstmt: *mut VariableSetStmt,
}
#[test]
fn bindgen_test_layout_AlterSystemStmt() {
    assert_eq!(::std::mem::size_of::<AlterSystemStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<AlterSystemStmt>() , 8usize);
}
impl Clone for AlterSystemStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ClusterStmt {
    pub type_: NodeTag,
    pub relation: *mut RangeVar,
    pub indexname: *mut ::std::os::raw::c_char,
    pub verbose: bool_,
}
#[test]
fn bindgen_test_layout_ClusterStmt() {
    assert_eq!(::std::mem::size_of::<ClusterStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<ClusterStmt>() , 8usize);
}
impl Clone for ClusterStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VacuumOption {
    VACOPT_VACUUM = 1,
    VACOPT_ANALYZE = 2,
    VACOPT_VERBOSE = 4,
    VACOPT_FREEZE = 8,
    VACOPT_FULL = 16,
    VACOPT_NOWAIT = 32,
    VACOPT_SKIPTOAST = 64,
    VACOPT_DISABLE_PAGE_SKIPPING = 128,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VacuumStmt {
    pub type_: NodeTag,
    pub options: ::std::os::raw::c_int,
    pub relation: *mut RangeVar,
    pub va_cols: *mut List,
}
#[test]
fn bindgen_test_layout_VacuumStmt() {
    assert_eq!(::std::mem::size_of::<VacuumStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<VacuumStmt>() , 8usize);
}
impl Clone for VacuumStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExplainStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ExplainStmt() {
    assert_eq!(::std::mem::size_of::<ExplainStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<ExplainStmt>() , 8usize);
}
impl Clone for ExplainStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateTableAsStmt {
    pub type_: NodeTag,
    pub query: *mut Node,
    pub into: *mut IntoClause,
    pub relkind: ObjectType,
    pub is_select_into: bool_,
    pub if_not_exists: bool_,
}
#[test]
fn bindgen_test_layout_CreateTableAsStmt() {
    assert_eq!(::std::mem::size_of::<CreateTableAsStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<CreateTableAsStmt>() , 8usize);
}
impl Clone for CreateTableAsStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RefreshMatViewStmt {
    pub type_: NodeTag,
    pub concurrent: bool_,
    pub skipData: bool_,
    pub relation: *mut RangeVar,
}
#[test]
fn bindgen_test_layout_RefreshMatViewStmt() {
    assert_eq!(::std::mem::size_of::<RefreshMatViewStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<RefreshMatViewStmt>() , 8usize);
}
impl Clone for RefreshMatViewStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CheckPointStmt {
    pub type_: NodeTag,
}
#[test]
fn bindgen_test_layout_CheckPointStmt() {
    assert_eq!(::std::mem::size_of::<CheckPointStmt>() , 4usize);
    assert_eq!(::std::mem::align_of::<CheckPointStmt>() , 4usize);
}
impl Clone for CheckPointStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DiscardMode {
    DISCARD_ALL = 0,
    DISCARD_PLANS = 1,
    DISCARD_SEQUENCES = 2,
    DISCARD_TEMP = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DiscardStmt {
    pub type_: NodeTag,
    pub target: DiscardMode,
}
#[test]
fn bindgen_test_layout_DiscardStmt() {
    assert_eq!(::std::mem::size_of::<DiscardStmt>() , 8usize);
    assert_eq!(::std::mem::align_of::<DiscardStmt>() , 4usize);
}
impl Clone for DiscardStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockStmt {
    pub type_: NodeTag,
    pub relations: *mut List,
    pub mode: ::std::os::raw::c_int,
    pub nowait: bool_,
}
#[test]
fn bindgen_test_layout_LockStmt() {
    assert_eq!(::std::mem::size_of::<LockStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<LockStmt>() , 8usize);
}
impl Clone for LockStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ConstraintsSetStmt {
    pub type_: NodeTag,
    pub constraints: *mut List,
    pub deferred: bool_,
}
#[test]
fn bindgen_test_layout_ConstraintsSetStmt() {
    assert_eq!(::std::mem::size_of::<ConstraintsSetStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<ConstraintsSetStmt>() , 8usize);
}
impl Clone for ConstraintsSetStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ReindexObjectType {
    REINDEX_OBJECT_INDEX = 0,
    REINDEX_OBJECT_TABLE = 1,
    REINDEX_OBJECT_SCHEMA = 2,
    REINDEX_OBJECT_SYSTEM = 3,
    REINDEX_OBJECT_DATABASE = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ReindexStmt {
    pub type_: NodeTag,
    pub kind: ReindexObjectType,
    pub relation: *mut RangeVar,
    pub name: *const ::std::os::raw::c_char,
    pub options: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ReindexStmt() {
    assert_eq!(::std::mem::size_of::<ReindexStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<ReindexStmt>() , 8usize);
}
impl Clone for ReindexStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateConversionStmt {
    pub type_: NodeTag,
    pub conversion_name: *mut List,
    pub for_encoding_name: *mut ::std::os::raw::c_char,
    pub to_encoding_name: *mut ::std::os::raw::c_char,
    pub func_name: *mut List,
    pub def: bool_,
}
#[test]
fn bindgen_test_layout_CreateConversionStmt() {
    assert_eq!(::std::mem::size_of::<CreateConversionStmt>() , 48usize);
    assert_eq!(::std::mem::align_of::<CreateConversionStmt>() , 8usize);
}
impl Clone for CreateConversionStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateCastStmt {
    pub type_: NodeTag,
    pub sourcetype: *mut TypeName,
    pub targettype: *mut TypeName,
    pub func: *mut FuncWithArgs,
    pub context: CoercionContext,
    pub inout: bool_,
}
#[test]
fn bindgen_test_layout_CreateCastStmt() {
    assert_eq!(::std::mem::size_of::<CreateCastStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<CreateCastStmt>() , 8usize);
}
impl Clone for CreateCastStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CreateTransformStmt {
    pub type_: NodeTag,
    pub replace: bool_,
    pub type_name: *mut TypeName,
    pub lang: *mut ::std::os::raw::c_char,
    pub fromsql: *mut FuncWithArgs,
    pub tosql: *mut FuncWithArgs,
}
#[test]
fn bindgen_test_layout_CreateTransformStmt() {
    assert_eq!(::std::mem::size_of::<CreateTransformStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<CreateTransformStmt>() , 8usize);
}
impl Clone for CreateTransformStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PrepareStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub argtypes: *mut List,
    pub query: *mut Node,
}
#[test]
fn bindgen_test_layout_PrepareStmt() {
    assert_eq!(::std::mem::size_of::<PrepareStmt>() , 32usize);
    assert_eq!(::std::mem::align_of::<PrepareStmt>() , 8usize);
}
impl Clone for PrepareStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ExecuteStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
    pub params: *mut List,
}
#[test]
fn bindgen_test_layout_ExecuteStmt() {
    assert_eq!(::std::mem::size_of::<ExecuteStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<ExecuteStmt>() , 8usize);
}
impl Clone for ExecuteStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DeallocateStmt {
    pub type_: NodeTag,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_DeallocateStmt() {
    assert_eq!(::std::mem::size_of::<DeallocateStmt>() , 16usize);
    assert_eq!(::std::mem::align_of::<DeallocateStmt>() , 8usize);
}
impl Clone for DeallocateStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct DropOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub behavior: DropBehavior,
}
#[test]
fn bindgen_test_layout_DropOwnedStmt() {
    assert_eq!(::std::mem::size_of::<DropOwnedStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<DropOwnedStmt>() , 8usize);
}
impl Clone for DropOwnedStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ReassignOwnedStmt {
    pub type_: NodeTag,
    pub roles: *mut List,
    pub newrole: *mut Node,
}
#[test]
fn bindgen_test_layout_ReassignOwnedStmt() {
    assert_eq!(::std::mem::size_of::<ReassignOwnedStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<ReassignOwnedStmt>() , 8usize);
}
impl Clone for ReassignOwnedStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterTSDictionaryStmt {
    pub type_: NodeTag,
    pub dictname: *mut List,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_AlterTSDictionaryStmt() {
    assert_eq!(::std::mem::size_of::<AlterTSDictionaryStmt>() , 24usize);
    assert_eq!(::std::mem::align_of::<AlterTSDictionaryStmt>() , 8usize);
}
impl Clone for AlterTSDictionaryStmt {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AlterTSConfigType {
    ALTER_TSCONFIG_ADD_MAPPING = 0,
    ALTER_TSCONFIG_ALTER_MAPPING_FOR_TOKEN = 1,
    ALTER_TSCONFIG_REPLACE_DICT = 2,
    ALTER_TSCONFIG_REPLACE_DICT_FOR_TOKEN = 3,
    ALTER_TSCONFIG_DROP_MAPPING = 4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AlterTSConfigurationStmt {
    pub type_: NodeTag,
    pub kind: AlterTSConfigType,
    pub cfgname: *mut List,
    pub tokentype: *mut List,
    pub dicts: *mut List,
    pub override_: bool_,
    pub replace: bool_,
    pub missing_ok: bool_,
}
#[test]
fn bindgen_test_layout_AlterTSConfigurationStmt() {
    assert_eq!(::std::mem::size_of::<AlterTSConfigurationStmt>() , 40usize);
    assert_eq!(::std::mem::align_of::<AlterTSConfigurationStmt>() , 8usize);
}
impl Clone for AlterTSConfigurationStmt {
    fn clone(&self) -> Self { *self }
}
pub type ExecutorStart_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
extern "C" {
    #[link_name = "ExecutorStart_hook"]
    pub static mut ExecutorStart_hook: ExecutorStart_hook_type;
}
pub type ExecutorRun_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc,
                                               direction: ScanDirection,
                                               count: uint64)>;
extern "C" {
    #[link_name = "ExecutorRun_hook"]
    pub static mut ExecutorRun_hook: ExecutorRun_hook_type;
}
pub type ExecutorFinish_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc)>;
extern "C" {
    #[link_name = "ExecutorFinish_hook"]
    pub static mut ExecutorFinish_hook: ExecutorFinish_hook_type;
}
pub type ExecutorEnd_hook_type =
    ::std::option::Option<unsafe extern "C" fn(queryDesc: *mut QueryDesc)>;
extern "C" {
    #[link_name = "ExecutorEnd_hook"]
    pub static mut ExecutorEnd_hook: ExecutorEnd_hook_type;
}
pub type ExecutorCheckPerms_hook_type =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut List, arg2: bool_)
                              -> ::std::os::raw::c_char>;
extern "C" {
    #[link_name = "ExecutorCheckPerms_hook"]
    pub static mut ExecutorCheckPerms_hook: ExecutorCheckPerms_hook_type;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Path {
    pub type_: NodeTag,
    pub pathtype: NodeTag,
    pub parent: *mut RelOptInfo,
    pub pathtarget: *mut PathTarget,
    pub param_info: *mut ParamPathInfo,
    pub parallel_aware: bool_,
    pub parallel_safe: bool_,
    pub parallel_workers: ::std::os::raw::c_int,
    pub rows: f64,
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub pathkeys: *mut List,
}
#[test]
fn bindgen_test_layout_Path() {
    assert_eq!(::std::mem::size_of::<Path>() , 72usize);
    assert_eq!(::std::mem::align_of::<Path>() , 8usize);
}
impl Clone for Path {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn ExecReScan(node: *mut PlanState);
}
extern "C" {
    pub fn ExecMarkPos(node: *mut PlanState);
}
extern "C" {
    pub fn ExecRestrPos(node: *mut PlanState);
}
extern "C" {
    pub fn ExecSupportsMarkRestore(pathnode: *mut Path) -> bool_;
}
extern "C" {
    pub fn ExecSupportsBackwardScan(node: *mut Plan) -> bool_;
}
extern "C" {
    pub fn ExecMaterializesOutput(plantype: NodeTag) -> bool_;
}
extern "C" {
    pub fn execCurrentOf(cexpr: *mut CurrentOfExpr,
                         econtext: *mut ExprContext, table_oid: Oid,
                         current_tid: ItemPointer) -> bool_;
}
extern "C" {
    pub fn execTuplesMatch(slot1: *mut TupleTableSlot,
                           slot2: *mut TupleTableSlot,
                           numCols: ::std::os::raw::c_int,
                           matchColIdx: *mut AttrNumber,
                           eqfunctions: *mut FmgrInfo,
                           evalContext: MemoryContext) -> bool_;
}
extern "C" {
    pub fn execTuplesUnequal(slot1: *mut TupleTableSlot,
                             slot2: *mut TupleTableSlot,
                             numCols: ::std::os::raw::c_int,
                             matchColIdx: *mut AttrNumber,
                             eqfunctions: *mut FmgrInfo,
                             evalContext: MemoryContext) -> bool_;
}
extern "C" {
    pub fn execTuplesMatchPrepare(numCols: ::std::os::raw::c_int,
                                  eqOperators: *mut Oid) -> *mut FmgrInfo;
}
extern "C" {
    pub fn execTuplesHashPrepare(numCols: ::std::os::raw::c_int,
                                 eqOperators: *mut Oid,
                                 eqFunctions: *mut *mut FmgrInfo,
                                 hashFunctions: *mut *mut FmgrInfo);
}
extern "C" {
    pub fn BuildTupleHashTable(numCols: ::std::os::raw::c_int,
                               keyColIdx: *mut AttrNumber,
                               eqfunctions: *mut FmgrInfo,
                               hashfunctions: *mut FmgrInfo,
                               nbuckets: ::std::os::raw::c_long,
                               entrysize: Size, tablecxt: MemoryContext,
                               tempcxt: MemoryContext) -> TupleHashTable;
}
extern "C" {
    pub fn LookupTupleHashEntry(hashtable: TupleHashTable,
                                slot: *mut TupleTableSlot, isnew: *mut bool_)
     -> TupleHashEntry;
}
extern "C" {
    pub fn FindTupleHashEntry(hashtable: TupleHashTable,
                              slot: *mut TupleTableSlot,
                              eqfunctions: *mut FmgrInfo,
                              hashfunctions: *mut FmgrInfo) -> TupleHashEntry;
}
extern "C" {
    pub fn ExecInitJunkFilter(targetList: *mut List, hasoid: bool_,
                              slot: *mut TupleTableSlot) -> *mut JunkFilter;
}
extern "C" {
    pub fn ExecInitJunkFilterConversion(targetList: *mut List,
                                        cleanTupType: TupleDesc,
                                        slot: *mut TupleTableSlot)
     -> *mut JunkFilter;
}
extern "C" {
    pub fn ExecFindJunkAttribute(junkfilter: *mut JunkFilter,
                                 attrName: *const ::std::os::raw::c_char)
     -> AttrNumber;
}
extern "C" {
    pub fn ExecFindJunkAttributeInTlist(targetlist: *mut List,
                                        attrName:
                                            *const ::std::os::raw::c_char)
     -> AttrNumber;
}
extern "C" {
    pub fn ExecGetJunkAttribute(slot: *mut TupleTableSlot, attno: AttrNumber,
                                isNull: *mut bool_) -> Datum;
}
extern "C" {
    pub fn ExecFilterJunk(junkfilter: *mut JunkFilter,
                          slot: *mut TupleTableSlot) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecutorStart(queryDesc: *mut QueryDesc,
                         eflags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn standard_ExecutorStart(queryDesc: *mut QueryDesc,
                                  eflags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ExecutorRun(queryDesc: *mut QueryDesc, direction: ScanDirection,
                       count: uint64);
}
extern "C" {
    pub fn standard_ExecutorRun(queryDesc: *mut QueryDesc,
                                direction: ScanDirection, count: uint64);
}
extern "C" {
    pub fn ExecutorFinish(queryDesc: *mut QueryDesc);
}
extern "C" {
    pub fn standard_ExecutorFinish(queryDesc: *mut QueryDesc);
}
extern "C" {
    pub fn ExecutorEnd(queryDesc: *mut QueryDesc);
}
extern "C" {
    pub fn standard_ExecutorEnd(queryDesc: *mut QueryDesc);
}
extern "C" {
    pub fn ExecutorRewind(queryDesc: *mut QueryDesc);
}
extern "C" {
    pub fn ExecCheckRTPerms(rangeTable: *mut List,
                            ereport_on_violation: bool_) -> bool_;
}
extern "C" {
    pub fn CheckValidResultRel(resultRel: Relation, operation: CmdType);
}
extern "C" {
    pub fn InitResultRelInfo(resultRelInfo: *mut ResultRelInfo,
                             resultRelationDesc: Relation,
                             resultRelationIndex: Index,
                             instrument_options: ::std::os::raw::c_int);
}
extern "C" {
    pub fn ExecGetTriggerResultRel(estate: *mut EState, relid: Oid)
     -> *mut ResultRelInfo;
}
extern "C" {
    pub fn ExecContextForcesOids(planstate: *mut PlanState,
                                 hasoids: *mut bool_) -> bool_;
}
extern "C" {
    pub fn ExecConstraints(resultRelInfo: *mut ResultRelInfo,
                           slot: *mut TupleTableSlot, estate: *mut EState);
}
extern "C" {
    pub fn ExecWithCheckOptions(kind: WCOKind,
                                resultRelInfo: *mut ResultRelInfo,
                                slot: *mut TupleTableSlot,
                                estate: *mut EState);
}
extern "C" {
    pub fn ExecUpdateLockMode(estate: *mut EState,
                              relinfo: *mut ResultRelInfo) -> LockTupleMode;
}
extern "C" {
    pub fn ExecFindRowMark(estate: *mut EState, rti: Index, missing_ok: bool_)
     -> *mut ExecRowMark;
}
extern "C" {
    pub fn ExecBuildAuxRowMark(erm: *mut ExecRowMark, targetlist: *mut List)
     -> *mut ExecAuxRowMark;
}
extern "C" {
    pub fn EvalPlanQual(estate: *mut EState, epqstate: *mut EPQState,
                        relation: Relation, rti: Index,
                        lockmode: ::std::os::raw::c_int, tid: ItemPointer,
                        priorXmax: TransactionId) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn EvalPlanQualFetch(estate: *mut EState, relation: Relation,
                             lockmode: ::std::os::raw::c_int,
                             wait_policy: LockWaitPolicy, tid: ItemPointer,
                             priorXmax: TransactionId) -> HeapTuple;
}
extern "C" {
    pub fn EvalPlanQualInit(epqstate: *mut EPQState, estate: *mut EState,
                            subplan: *mut Plan, auxrowmarks: *mut List,
                            epqParam: ::std::os::raw::c_int);
}
extern "C" {
    pub fn EvalPlanQualSetPlan(epqstate: *mut EPQState, subplan: *mut Plan,
                               auxrowmarks: *mut List);
}
extern "C" {
    pub fn EvalPlanQualSetTuple(epqstate: *mut EPQState, rti: Index,
                                tuple: HeapTuple);
}
extern "C" {
    pub fn EvalPlanQualGetTuple(epqstate: *mut EPQState, rti: Index)
     -> HeapTuple;
}
extern "C" {
    pub fn EvalPlanQualFetchRowMarks(epqstate: *mut EPQState);
}
extern "C" {
    pub fn EvalPlanQualNext(epqstate: *mut EPQState) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn EvalPlanQualBegin(epqstate: *mut EPQState,
                             parentestate: *mut EState);
}
extern "C" {
    pub fn EvalPlanQualEnd(epqstate: *mut EPQState);
}
extern "C" {
    pub fn ExecInitNode(node: *mut Plan, estate: *mut EState,
                        eflags: ::std::os::raw::c_int) -> *mut PlanState;
}
extern "C" {
    pub fn ExecProcNode(node: *mut PlanState) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn MultiExecProcNode(node: *mut PlanState) -> *mut Node;
}
extern "C" {
    pub fn ExecEndNode(node: *mut PlanState);
}
extern "C" {
    pub fn ExecShutdownNode(node: *mut PlanState) -> bool_;
}
extern "C" {
    pub fn GetAttributeByNum(tuple: HeapTupleHeader, attrno: AttrNumber,
                             isNull: *mut bool_) -> Datum;
}
extern "C" {
    pub fn GetAttributeByName(tuple: HeapTupleHeader,
                              attname: *const ::std::os::raw::c_char,
                              isNull: *mut bool_) -> Datum;
}
extern "C" {
    pub fn ExecMakeTableFunctionResult(funcexpr: *mut ExprState,
                                       econtext: *mut ExprContext,
                                       argContext: MemoryContext,
                                       expectedDesc: TupleDesc,
                                       randomAccess: bool_)
     -> *mut Tuplestorestate;
}
extern "C" {
    pub fn ExecEvalExprSwitchContext(expression: *mut ExprState,
                                     econtext: *mut ExprContext,
                                     isNull: *mut bool_,
                                     isDone: *mut ExprDoneCond) -> Datum;
}
extern "C" {
    pub fn ExecInitExpr(node: *mut Expr, parent: *mut PlanState)
     -> *mut ExprState;
}
extern "C" {
    pub fn ExecPrepareExpr(node: *mut Expr, estate: *mut EState)
     -> *mut ExprState;
}
extern "C" {
    pub fn ExecQual(qual: *mut List, econtext: *mut ExprContext,
                    resultForNull: bool_) -> bool_;
}
extern "C" {
    pub fn ExecTargetListLength(targetlist: *mut List)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExecCleanTargetListLength(targetlist: *mut List)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ExecProject(projInfo: *mut ProjectionInfo,
                       isDone: *mut ExprDoneCond) -> *mut TupleTableSlot;
}
pub type ExecScanAccessMtd =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ScanState)
                              -> *mut TupleTableSlot>;
pub type ExecScanRecheckMtd =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ScanState,
                                               slot: *mut TupleTableSlot)
                              -> ::std::os::raw::c_char>;
extern "C" {
    pub fn ExecScan(node: *mut ScanState, accessMtd: ExecScanAccessMtd,
                    recheckMtd: ExecScanRecheckMtd) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecAssignScanProjectionInfo(node: *mut ScanState);
}
extern "C" {
    pub fn ExecAssignScanProjectionInfoWithVarno(node: *mut ScanState,
                                                 varno: Index);
}
extern "C" {
    pub fn ExecScanReScan(node: *mut ScanState);
}
extern "C" {
    pub fn ExecInitResultTupleSlot(estate: *mut EState,
                                   planstate: *mut PlanState);
}
extern "C" {
    pub fn ExecInitScanTupleSlot(estate: *mut EState,
                                 scanstate: *mut ScanState);
}
extern "C" {
    pub fn ExecInitExtraTupleSlot(estate: *mut EState) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecInitNullTupleSlot(estate: *mut EState, tupType: TupleDesc)
     -> *mut TupleTableSlot;
}
extern "C" {
    pub fn ExecTypeFromTL(targetList: *mut List, hasoid: bool_) -> TupleDesc;
}
extern "C" {
    pub fn ExecCleanTypeFromTL(targetList: *mut List, hasoid: bool_)
     -> TupleDesc;
}
extern "C" {
    pub fn ExecTypeFromExprList(exprList: *mut List) -> TupleDesc;
}
extern "C" {
    pub fn ExecTypeSetColNames(typeInfo: TupleDesc, namesList: *mut List);
}
extern "C" {
    pub fn UpdateChangedParamSet(node: *mut PlanState,
                                 newchg: *mut Bitmapset);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TupOutputState {
    pub slot: *mut TupleTableSlot,
    pub dest: *mut DestReceiver,
}
#[test]
fn bindgen_test_layout_TupOutputState() {
    assert_eq!(::std::mem::size_of::<TupOutputState>() , 16usize);
    assert_eq!(::std::mem::align_of::<TupOutputState>() , 8usize);
}
impl Clone for TupOutputState {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn begin_tup_output_tupdesc(dest: *mut DestReceiver,
                                    tupdesc: TupleDesc)
     -> *mut TupOutputState;
}
extern "C" {
    pub fn do_tup_output(tstate: *mut TupOutputState, values: *mut Datum,
                         isnull: *mut bool_);
}
extern "C" {
    pub fn do_text_output_multiline(tstate: *mut TupOutputState,
                                    txt: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn end_tup_output(tstate: *mut TupOutputState);
}
extern "C" {
    pub fn CreateExecutorState() -> *mut EState;
}
extern "C" {
    pub fn FreeExecutorState(estate: *mut EState);
}
extern "C" {
    pub fn CreateExprContext(estate: *mut EState) -> *mut ExprContext;
}
extern "C" {
    pub fn CreateStandaloneExprContext() -> *mut ExprContext;
}
extern "C" {
    pub fn FreeExprContext(econtext: *mut ExprContext, isCommit: bool_);
}
extern "C" {
    pub fn ReScanExprContext(econtext: *mut ExprContext);
}
extern "C" {
    pub fn MakePerTupleExprContext(estate: *mut EState) -> *mut ExprContext;
}
extern "C" {
    pub fn ExecAssignExprContext(estate: *mut EState,
                                 planstate: *mut PlanState);
}
extern "C" {
    pub fn ExecAssignResultType(planstate: *mut PlanState,
                                tupDesc: TupleDesc);
}
extern "C" {
    pub fn ExecAssignResultTypeFromTL(planstate: *mut PlanState);
}
extern "C" {
    pub fn ExecGetResultType(planstate: *mut PlanState) -> TupleDesc;
}
extern "C" {
    pub fn ExecBuildProjectionInfo(targetList: *mut List,
                                   econtext: *mut ExprContext,
                                   slot: *mut TupleTableSlot,
                                   inputDesc: TupleDesc)
     -> *mut ProjectionInfo;
}
extern "C" {
    pub fn ExecAssignProjectionInfo(planstate: *mut PlanState,
                                    inputDesc: TupleDesc);
}
extern "C" {
    pub fn ExecFreeExprContext(planstate: *mut PlanState);
}
extern "C" {
    pub fn ExecAssignScanType(scanstate: *mut ScanState, tupDesc: TupleDesc);
}
extern "C" {
    pub fn ExecAssignScanTypeFromOuterPlan(scanstate: *mut ScanState);
}
extern "C" {
    pub fn ExecRelationIsTargetRelation(estate: *mut EState, scanrelid: Index)
     -> bool_;
}
extern "C" {
    pub fn ExecOpenScanRelation(estate: *mut EState, scanrelid: Index,
                                eflags: ::std::os::raw::c_int) -> Relation;
}
extern "C" {
    pub fn ExecCloseScanRelation(scanrel: Relation);
}
extern "C" {
    pub fn RegisterExprContextCallback(econtext: *mut ExprContext,
                                       function: ExprContextCallbackFunction,
                                       arg: Datum);
}
extern "C" {
    pub fn UnregisterExprContextCallback(econtext: *mut ExprContext,
                                         function:
                                             ExprContextCallbackFunction,
                                         arg: Datum);
}
extern "C" {
    pub fn ExecOpenIndices(resultRelInfo: *mut ResultRelInfo,
                           speculative: bool_);
}
extern "C" {
    pub fn ExecCloseIndices(resultRelInfo: *mut ResultRelInfo);
}
extern "C" {
    pub fn ExecInsertIndexTuples(slot: *mut TupleTableSlot,
                                 tupleid: ItemPointer, estate: *mut EState,
                                 noDupErr: bool_, specConflict: *mut bool_,
                                 arbiterIndexes: *mut List) -> *mut List;
}
extern "C" {
    pub fn ExecCheckIndexConstraints(slot: *mut TupleTableSlot,
                                     estate: *mut EState,
                                     conflictTid: ItemPointer,
                                     arbiterIndexes: *mut List) -> bool_;
}
extern "C" {
    pub fn check_exclusion_constraint(heap: Relation, index: Relation,
                                      indexInfo: *mut IndexInfo,
                                      tupleid: ItemPointer,
                                      values: *mut Datum, isnull: *mut bool_,
                                      estate: *mut EState, newIndex: bool_);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AttInMetadata {
    pub tupdesc: TupleDesc,
    pub attinfuncs: *mut FmgrInfo,
    pub attioparams: *mut Oid,
    pub atttypmods: *mut int32,
}
#[test]
fn bindgen_test_layout_AttInMetadata() {
    assert_eq!(::std::mem::size_of::<AttInMetadata>() , 32usize);
    assert_eq!(::std::mem::align_of::<AttInMetadata>() , 8usize);
}
impl Clone for AttInMetadata {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FuncCallContext {
    pub call_cntr: uint64,
    pub max_calls: uint64,
    pub slot: *mut TupleTableSlot,
    pub user_fctx: *mut ::std::os::raw::c_void,
    pub attinmeta: *mut AttInMetadata,
    pub multi_call_memory_ctx: MemoryContext,
    pub tuple_desc: TupleDesc,
}
#[test]
fn bindgen_test_layout_FuncCallContext() {
    assert_eq!(::std::mem::size_of::<FuncCallContext>() , 56usize);
    assert_eq!(::std::mem::align_of::<FuncCallContext>() , 8usize);
}
impl Clone for FuncCallContext {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum TypeFuncClass {
    TYPEFUNC_SCALAR = 0,
    TYPEFUNC_COMPOSITE = 1,
    TYPEFUNC_RECORD = 2,
    TYPEFUNC_OTHER = 3,
}
extern "C" {
    pub fn get_call_result_type(fcinfo: FunctionCallInfo,
                                resultTypeId: *mut Oid,
                                resultTupleDesc: *mut TupleDesc)
     -> TypeFuncClass;
}
extern "C" {
    pub fn get_expr_result_type(expr: *mut Node, resultTypeId: *mut Oid,
                                resultTupleDesc: *mut TupleDesc)
     -> TypeFuncClass;
}
extern "C" {
    pub fn get_func_result_type(functionId: Oid, resultTypeId: *mut Oid,
                                resultTupleDesc: *mut TupleDesc)
     -> TypeFuncClass;
}
extern "C" {
    pub fn resolve_polymorphic_argtypes(numargs: ::std::os::raw::c_int,
                                        argtypes: *mut Oid,
                                        argmodes: *mut ::std::os::raw::c_char,
                                        call_expr: *mut Node) -> bool_;
}
extern "C" {
    pub fn get_func_arg_info(procTup: HeapTuple, p_argtypes: *mut *mut Oid,
                             p_argnames:
                                 *mut *mut *mut ::std::os::raw::c_char,
                             p_argmodes: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_func_input_arg_names(proargnames: Datum, proargmodes: Datum,
                                    arg_names:
                                        *mut *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_func_trftypes(procTup: HeapTuple, p_trftypes: *mut *mut Oid)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_func_result_name(functionId: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn build_function_result_tupdesc_d(proallargtypes: Datum,
                                           proargmodes: Datum,
                                           proargnames: Datum) -> TupleDesc;
}
extern "C" {
    pub fn build_function_result_tupdesc_t(procTuple: HeapTuple) -> TupleDesc;
}
extern "C" {
    pub fn RelationNameGetTupleDesc(relname: *const ::std::os::raw::c_char)
     -> TupleDesc;
}
extern "C" {
    pub fn TypeGetTupleDesc(typeoid: Oid, colaliases: *mut List) -> TupleDesc;
}
extern "C" {
    pub fn BlessTupleDesc(tupdesc: TupleDesc) -> TupleDesc;
}
extern "C" {
    pub fn TupleDescGetAttInMetadata(tupdesc: TupleDesc)
     -> *mut AttInMetadata;
}
extern "C" {
    pub fn BuildTupleFromCStrings(attinmeta: *mut AttInMetadata,
                                  values: *mut *mut ::std::os::raw::c_char)
     -> HeapTuple;
}
extern "C" {
    pub fn HeapTupleHeaderGetDatum(tuple: HeapTupleHeader) -> Datum;
}
extern "C" {
    pub fn TupleDescGetSlot(tupdesc: TupleDesc) -> *mut TupleTableSlot;
}
extern "C" {
    pub fn init_MultiFuncCall(fcinfo: FunctionCallInfo)
     -> *mut FuncCallContext;
}
extern "C" {
    pub fn per_MultiFuncCall(fcinfo: FunctionCallInfo)
     -> *mut FuncCallContext;
}
extern "C" {
    pub fn end_MultiFuncCall(fcinfo: FunctionCallInfo,
                             funcctx: *mut FuncCallContext);
}
pub type bgworker_main_type =
    ::std::option::Option<unsafe extern "C" fn(main_arg: Datum)>;
pub const BgWorkerStart_PostmasterStart: _bindgen_ty_59 =
    _bindgen_ty_59::BgWorkerStart_PostmasterStart;
pub const BgWorkerStart_ConsistentState: _bindgen_ty_59 =
    _bindgen_ty_59::BgWorkerStart_ConsistentState;
pub const BgWorkerStart_RecoveryFinished: _bindgen_ty_59 =
    _bindgen_ty_59::BgWorkerStart_RecoveryFinished;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_59 {
    BgWorkerStart_PostmasterStart = 0,
    BgWorkerStart_ConsistentState = 1,
    BgWorkerStart_RecoveryFinished = 2,
}
pub use self::_bindgen_ty_59 as BgWorkerStartTime;
#[repr(C)]
pub struct BackgroundWorker {
    pub bgw_name: [::std::os::raw::c_char; 64usize],
    pub bgw_flags: ::std::os::raw::c_int,
    pub bgw_start_time: BgWorkerStartTime,
    pub bgw_restart_time: ::std::os::raw::c_int,
    pub bgw_main: bgworker_main_type,
    pub bgw_library_name: [::std::os::raw::c_char; 64usize],
    pub bgw_function_name: [::std::os::raw::c_char; 64usize],
    pub bgw_main_arg: Datum,
    pub bgw_extra: [::std::os::raw::c_char; 128usize],
    pub bgw_notify_pid: pid_t,
}
#[test]
fn bindgen_test_layout_BackgroundWorker() {
    assert_eq!(::std::mem::size_of::<BackgroundWorker>() , 360usize);
    assert_eq!(::std::mem::align_of::<BackgroundWorker>() , 8usize);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum BgwHandleStatus {
    BGWH_STARTED = 0,
    BGWH_NOT_YET_STARTED = 1,
    BGWH_STOPPED = 2,
    BGWH_POSTMASTER_DIED = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BackgroundWorkerHandle([u8; 0]);
extern "C" {
    pub fn RegisterBackgroundWorker(worker: *mut BackgroundWorker);
}
extern "C" {
    pub fn RegisterDynamicBackgroundWorker(worker: *mut BackgroundWorker,
                                           handle:
                                               *mut *mut BackgroundWorkerHandle)
     -> bool_;
}
extern "C" {
    pub fn GetBackgroundWorkerPid(handle: *mut BackgroundWorkerHandle,
                                  pidp: *mut pid_t) -> BgwHandleStatus;
}
extern "C" {
    pub fn WaitForBackgroundWorkerStartup(handle: *mut BackgroundWorkerHandle,
                                          pid: *mut pid_t) -> BgwHandleStatus;
}
extern "C" {
    pub fn WaitForBackgroundWorkerShutdown(arg1: *mut BackgroundWorkerHandle)
     -> BgwHandleStatus;
}
extern "C" {
    pub fn TerminateBackgroundWorker(handle: *mut BackgroundWorkerHandle);
}
extern "C" {
    #[link_name = "MyBgworkerEntry"]
    pub static mut MyBgworkerEntry: *mut BackgroundWorker;
}
extern "C" {
    pub fn BackgroundWorkerInitializeConnection(dbname:
                                                    *mut ::std::os::raw::c_char,
                                                username:
                                                    *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn BackgroundWorkerInitializeConnectionByOid(dboid: Oid,
                                                     useroid: Oid);
}
extern "C" {
    pub fn BackgroundWorkerBlockSignals();
}
extern "C" {
    pub fn BackgroundWorkerUnblockSignals();
}
extern "C" {
    #[link_name = "dynamic_shared_memory_type"]
    pub static mut dynamic_shared_memory_type: ::std::os::raw::c_int;
}
pub type dsm_handle = uint32;
pub const DSM_OP_CREATE: _bindgen_ty_60 = _bindgen_ty_60::DSM_OP_CREATE;
pub const DSM_OP_ATTACH: _bindgen_ty_60 = _bindgen_ty_60::DSM_OP_ATTACH;
pub const DSM_OP_DETACH: _bindgen_ty_60 = _bindgen_ty_60::DSM_OP_DETACH;
pub const DSM_OP_RESIZE: _bindgen_ty_60 = _bindgen_ty_60::DSM_OP_RESIZE;
pub const DSM_OP_DESTROY: _bindgen_ty_60 = _bindgen_ty_60::DSM_OP_DESTROY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_60 {
    DSM_OP_CREATE = 0,
    DSM_OP_ATTACH = 1,
    DSM_OP_DETACH = 2,
    DSM_OP_RESIZE = 3,
    DSM_OP_DESTROY = 4,
}
pub use self::_bindgen_ty_60 as dsm_op;
extern "C" {
    pub fn dsm_impl_op(op: dsm_op, handle: dsm_handle, request_size: Size,
                       impl_private: *mut *mut ::std::os::raw::c_void,
                       mapped_address: *mut *mut ::std::os::raw::c_void,
                       mapped_size: *mut Size, elevel: ::std::os::raw::c_int)
     -> bool_;
}
extern "C" {
    pub fn dsm_impl_can_resize() -> bool_;
}
extern "C" {
    pub fn dsm_impl_pin_segment(handle: dsm_handle,
                                impl_private: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dsm_segment([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PGShmemHeader([u8; 0]);
extern "C" {
    pub fn dsm_cleanup_using_control_segment(old_control_handle: dsm_handle);
}
extern "C" {
    pub fn dsm_postmaster_startup(arg1: *mut PGShmemHeader);
}
extern "C" {
    pub fn dsm_backend_shutdown();
}
extern "C" {
    pub fn dsm_detach_all();
}
extern "C" {
    pub fn dsm_create(size: Size, flags: ::std::os::raw::c_int)
     -> *mut dsm_segment;
}
extern "C" {
    pub fn dsm_attach(h: dsm_handle) -> *mut dsm_segment;
}
extern "C" {
    pub fn dsm_resize(seg: *mut dsm_segment, size: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dsm_remap(seg: *mut dsm_segment) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dsm_detach(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_pin_mapping(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_unpin_mapping(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_pin_segment(seg: *mut dsm_segment);
}
extern "C" {
    pub fn dsm_find_mapping(h: dsm_handle) -> *mut dsm_segment;
}
extern "C" {
    pub fn dsm_segment_address(seg: *mut dsm_segment)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dsm_segment_map_length(seg: *mut dsm_segment) -> Size;
}
extern "C" {
    pub fn dsm_segment_handle(seg: *mut dsm_segment) -> dsm_handle;
}
pub type on_dsm_detach_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut dsm_segment,
                                               arg: Datum)>;
extern "C" {
    pub fn on_dsm_detach(seg: *mut dsm_segment,
                         function: on_dsm_detach_callback, arg: Datum);
}
extern "C" {
    pub fn cancel_on_dsm_detach(seg: *mut dsm_segment,
                                function: on_dsm_detach_callback, arg: Datum);
}
extern "C" {
    pub fn reset_on_dsm_detach();
}
extern "C" {
    pub fn __sigismember(arg1: *const __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigaddset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sigdelset(arg1: *mut __sigset_t, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigval {
    pub sival_int: __BindgenUnionField<::std::os::raw::c_int>,
    pub sival_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>() , 8usize);
    assert_eq!(::std::mem::align_of::<sigval>() , 8usize);
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
pub type sigval_t = sigval;
pub type __sigchld_clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61 {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub _sifields: _bindgen_ty_61__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1 {
    pub _pad: __BindgenUnionField<[::std::os::raw::c_int; 28usize]>,
    pub _kill: __BindgenUnionField<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_1>,
    pub _timer: __BindgenUnionField<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_2>,
    pub _rt: __BindgenUnionField<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_3>,
    pub _sigchld: __BindgenUnionField<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_4>,
    pub _sigfault: __BindgenUnionField<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_5>,
    pub _sigpoll: __BindgenUnionField<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_6>,
    pub _sigsys: __BindgenUnionField<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_7>,
    pub bindgen_union_field: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_1>()
               , 4usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_2>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_2>()
               , 8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: sigval_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_3>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_3>()
               , 8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __sigchld_clock_t,
    pub si_stime: __sigchld_clock_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_4>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_4>()
               , 8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub si_addr_bnd: _bindgen_ty_61__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()
               , 8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_5>()
               , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_5>()
               , 8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_6>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_6>()
               , 8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_61__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_7>()
               , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1__bindgen_ty_7>()
               , 8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_61__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61__bindgen_ty_1>() ,
               112usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_61__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_61() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_61>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_61>() , 8usize);
}
impl Clone for _bindgen_ty_61 {
    fn clone(&self) -> Self { *self }
}
pub type siginfo_t = _bindgen_ty_61;
pub const SI_ASYNCNL: _bindgen_ty_62 = _bindgen_ty_62::SI_ASYNCNL;
pub const SI_TKILL: _bindgen_ty_62 = _bindgen_ty_62::SI_TKILL;
pub const SI_SIGIO: _bindgen_ty_62 = _bindgen_ty_62::SI_SIGIO;
pub const SI_ASYNCIO: _bindgen_ty_62 = _bindgen_ty_62::SI_ASYNCIO;
pub const SI_MESGQ: _bindgen_ty_62 = _bindgen_ty_62::SI_MESGQ;
pub const SI_TIMER: _bindgen_ty_62 = _bindgen_ty_62::SI_TIMER;
pub const SI_QUEUE: _bindgen_ty_62 = _bindgen_ty_62::SI_QUEUE;
pub const SI_USER: _bindgen_ty_62 = _bindgen_ty_62::SI_USER;
pub const SI_KERNEL: _bindgen_ty_62 = _bindgen_ty_62::SI_KERNEL;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_62 {
    SI_ASYNCNL = -60,
    SI_TKILL = -6,
    SI_SIGIO = -5,
    SI_ASYNCIO = -4,
    SI_MESGQ = -3,
    SI_TIMER = -2,
    SI_QUEUE = -1,
    SI_USER = 0,
    SI_KERNEL = 128,
}
pub const ILL_ILLOPC: _bindgen_ty_63 = _bindgen_ty_63::ILL_ILLOPC;
pub const ILL_ILLOPN: _bindgen_ty_63 = _bindgen_ty_63::ILL_ILLOPN;
pub const ILL_ILLADR: _bindgen_ty_63 = _bindgen_ty_63::ILL_ILLADR;
pub const ILL_ILLTRP: _bindgen_ty_63 = _bindgen_ty_63::ILL_ILLTRP;
pub const ILL_PRVOPC: _bindgen_ty_63 = _bindgen_ty_63::ILL_PRVOPC;
pub const ILL_PRVREG: _bindgen_ty_63 = _bindgen_ty_63::ILL_PRVREG;
pub const ILL_COPROC: _bindgen_ty_63 = _bindgen_ty_63::ILL_COPROC;
pub const ILL_BADSTK: _bindgen_ty_63 = _bindgen_ty_63::ILL_BADSTK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_63 {
    ILL_ILLOPC = 1,
    ILL_ILLOPN = 2,
    ILL_ILLADR = 3,
    ILL_ILLTRP = 4,
    ILL_PRVOPC = 5,
    ILL_PRVREG = 6,
    ILL_COPROC = 7,
    ILL_BADSTK = 8,
}
pub const FPE_INTDIV: _bindgen_ty_64 = _bindgen_ty_64::FPE_INTDIV;
pub const FPE_INTOVF: _bindgen_ty_64 = _bindgen_ty_64::FPE_INTOVF;
pub const FPE_FLTDIV: _bindgen_ty_64 = _bindgen_ty_64::FPE_FLTDIV;
pub const FPE_FLTOVF: _bindgen_ty_64 = _bindgen_ty_64::FPE_FLTOVF;
pub const FPE_FLTUND: _bindgen_ty_64 = _bindgen_ty_64::FPE_FLTUND;
pub const FPE_FLTRES: _bindgen_ty_64 = _bindgen_ty_64::FPE_FLTRES;
pub const FPE_FLTINV: _bindgen_ty_64 = _bindgen_ty_64::FPE_FLTINV;
pub const FPE_FLTSUB: _bindgen_ty_64 = _bindgen_ty_64::FPE_FLTSUB;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_64 {
    FPE_INTDIV = 1,
    FPE_INTOVF = 2,
    FPE_FLTDIV = 3,
    FPE_FLTOVF = 4,
    FPE_FLTUND = 5,
    FPE_FLTRES = 6,
    FPE_FLTINV = 7,
    FPE_FLTSUB = 8,
}
pub const SEGV_MAPERR: _bindgen_ty_65 = _bindgen_ty_65::SEGV_MAPERR;
pub const SEGV_ACCERR: _bindgen_ty_65 = _bindgen_ty_65::SEGV_ACCERR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_65 { SEGV_MAPERR = 1, SEGV_ACCERR = 2, }
pub const BUS_ADRALN: _bindgen_ty_66 = _bindgen_ty_66::BUS_ADRALN;
pub const BUS_ADRERR: _bindgen_ty_66 = _bindgen_ty_66::BUS_ADRERR;
pub const BUS_OBJERR: _bindgen_ty_66 = _bindgen_ty_66::BUS_OBJERR;
pub const BUS_MCEERR_AR: _bindgen_ty_66 = _bindgen_ty_66::BUS_MCEERR_AR;
pub const BUS_MCEERR_AO: _bindgen_ty_66 = _bindgen_ty_66::BUS_MCEERR_AO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_66 {
    BUS_ADRALN = 1,
    BUS_ADRERR = 2,
    BUS_OBJERR = 3,
    BUS_MCEERR_AR = 4,
    BUS_MCEERR_AO = 5,
}
pub const CLD_EXITED: _bindgen_ty_67 = _bindgen_ty_67::CLD_EXITED;
pub const CLD_KILLED: _bindgen_ty_67 = _bindgen_ty_67::CLD_KILLED;
pub const CLD_DUMPED: _bindgen_ty_67 = _bindgen_ty_67::CLD_DUMPED;
pub const CLD_TRAPPED: _bindgen_ty_67 = _bindgen_ty_67::CLD_TRAPPED;
pub const CLD_STOPPED: _bindgen_ty_67 = _bindgen_ty_67::CLD_STOPPED;
pub const CLD_CONTINUED: _bindgen_ty_67 = _bindgen_ty_67::CLD_CONTINUED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_67 {
    CLD_EXITED = 1,
    CLD_KILLED = 2,
    CLD_DUMPED = 3,
    CLD_TRAPPED = 4,
    CLD_STOPPED = 5,
    CLD_CONTINUED = 6,
}
pub const POLL_IN: _bindgen_ty_68 = _bindgen_ty_68::POLL_IN;
pub const POLL_OUT: _bindgen_ty_68 = _bindgen_ty_68::POLL_OUT;
pub const POLL_MSG: _bindgen_ty_68 = _bindgen_ty_68::POLL_MSG;
pub const POLL_ERR: _bindgen_ty_68 = _bindgen_ty_68::POLL_ERR;
pub const POLL_PRI: _bindgen_ty_68 = _bindgen_ty_68::POLL_PRI;
pub const POLL_HUP: _bindgen_ty_68 = _bindgen_ty_68::POLL_HUP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_68 {
    POLL_IN = 1,
    POLL_OUT = 2,
    POLL_MSG = 3,
    POLL_ERR = 4,
    POLL_PRI = 5,
    POLL_HUP = 6,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1 {
    pub _pad: __BindgenUnionField<[::std::os::raw::c_int; 12usize]>,
    pub _tid: __BindgenUnionField<__pid_t>,
    pub _sigev_thread: __BindgenUnionField<sigevent__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>() ,
               16usize);
    assert_eq!(::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
               , 8usize);
}
impl Clone for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1>() , 48usize);
    assert_eq!(::std::mem::align_of::<sigevent__bindgen_ty_1>() , 8usize);
}
impl Clone for sigevent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>() , 64usize);
    assert_eq!(::std::mem::align_of::<sigevent>() , 8usize);
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_69 = _bindgen_ty_69::SIGEV_SIGNAL;
pub const SIGEV_NONE: _bindgen_ty_69 = _bindgen_ty_69::SIGEV_NONE;
pub const SIGEV_THREAD: _bindgen_ty_69 = _bindgen_ty_69::SIGEV_THREAD;
pub const SIGEV_THREAD_ID: _bindgen_ty_69 = _bindgen_ty_69::SIGEV_THREAD_ID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_69 {
    SIGEV_SIGNAL = 0,
    SIGEV_NONE = 1,
    SIGEV_THREAD = 2,
    SIGEV_THREAD_ID = 4,
}
pub type __sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int,
                         __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
     -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int,
                   __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t,
                    __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaction__bindgen_ty_1 {
    pub sa_handler: __BindgenUnionField<__sighandler_t>,
    pub sa_sigaction: __BindgenUnionField<::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                         ::std::os::raw::c_int,
                                                                                     arg2:
                                                                                         *mut siginfo_t,
                                                                                     arg3:
                                                                                         *mut ::std::os::raw::c_void)>>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigaction__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<sigaction__bindgen_ty_1>() , 8usize);
}
impl Clone for sigaction__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>() , 152usize);
    assert_eq!(::std::mem::align_of::<sigaction>() , 8usize);
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn sigprocmask(__how: ::std::os::raw::c_int, __set: *const sigset_t,
                       __oset: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(__sig: ::std::os::raw::c_int, __act: *const sigaction,
                     __oact: *mut sigaction) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(__set: *const sigset_t, __info: *mut siginfo_t,
                        __timeout: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: ::std::os::raw::c_int,
                    __val: sigval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "_sys_siglist"]
    pub static mut _sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
extern "C" {
    #[link_name = "sys_siglist"]
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub padding: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(::std::mem::size_of::<_fpx_sw_bytes>() , 48usize);
    assert_eq!(::std::mem::align_of::<_fpx_sw_bytes>() , 8usize);
}
impl Clone for _fpx_sw_bytes {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(::std::mem::size_of::<_fpreg>() , 10usize);
    assert_eq!(::std::mem::align_of::<_fpreg>() , 2usize);
}
impl Clone for _fpreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(::std::mem::size_of::<_fpxreg>() , 16usize);
    assert_eq!(::std::mem::align_of::<_fpxreg>() , 2usize);
}
impl Clone for _fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(::std::mem::size_of::<_xmmreg>() , 16usize);
    assert_eq!(::std::mem::align_of::<_xmmreg>() , 4usize);
}
impl Clone for _xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(::std::mem::size_of::<_fpstate>() , 512usize);
    assert_eq!(::std::mem::align_of::<_fpstate>() , 8usize);
}
impl Clone for _fpstate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigcontext__bindgen_ty_1 {
    pub fpstate: __BindgenUnionField<*mut _fpstate>,
    pub __fpstate_word: __BindgenUnionField<__uint64_t>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigcontext__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<sigcontext__bindgen_ty_1>() , 8usize);
}
impl Clone for sigcontext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::std::mem::size_of::<sigcontext>() , 256usize);
    assert_eq!(::std::mem::align_of::<sigcontext>() , 8usize);
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub reserved1: [__uint64_t; 2usize],
    pub reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(::std::mem::size_of::<_xsave_hdr>() , 64usize);
    assert_eq!(::std::mem::align_of::<_xsave_hdr>() , 8usize);
}
impl Clone for _xsave_hdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(::std::mem::size_of::<_ymmh_state>() , 256usize);
    assert_eq!(::std::mem::align_of::<_ymmh_state>() , 4usize);
}
#[repr(C)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(::std::mem::size_of::<_xstate>() , 832usize);
    assert_eq!(::std::mem::align_of::<_xstate>() , 8usize);
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siginterrupt(__sig: ::std::os::raw::c_int,
                        __interrupt: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>() , 16usize);
    assert_eq!(::std::mem::align_of::<sigstack>() , 8usize);
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
pub const SS_ONSTACK: _bindgen_ty_70 = _bindgen_ty_70::SS_ONSTACK;
pub const SS_DISABLE: _bindgen_ty_70 = _bindgen_ty_70::SS_DISABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_70 { SS_ONSTACK = 1, SS_DISABLE = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(::std::mem::size_of::<sigaltstack>() , 24usize);
    assert_eq!(::std::mem::align_of::<sigaltstack>() , 8usize);
}
impl Clone for sigaltstack {
    fn clone(&self) -> Self { *self }
}
pub type stack_t = sigaltstack;
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub padding: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(::std::mem::size_of::<_libc_fpxreg>() , 16usize);
    assert_eq!(::std::mem::align_of::<_libc_fpxreg>() , 2usize);
}
impl Clone for _libc_fpxreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(::std::mem::size_of::<_libc_xmmreg>() , 16usize);
    assert_eq!(::std::mem::align_of::<_libc_xmmreg>() , 4usize);
}
impl Clone for _libc_xmmreg {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub padding: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(::std::mem::size_of::<_libc_fpstate>() , 512usize);
    assert_eq!(::std::mem::align_of::<_libc_fpstate>() , 8usize);
}
impl Clone for _libc_fpstate {
    fn clone(&self) -> Self { *self }
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_71 {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_71() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_71>() , 256usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_71>() , 8usize);
}
impl Clone for _bindgen_ty_71 {
    fn clone(&self) -> Self { *self }
}
pub type mcontext_t = _bindgen_ty_71;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ucontext {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: __sigset_t,
    pub __fpregs_mem: _libc_fpstate,
}
#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(::std::mem::size_of::<ucontext>() , 936usize);
    assert_eq!(::std::mem::align_of::<ucontext>() , 8usize);
}
impl Clone for ucontext {
    fn clone(&self) -> Self { *self }
}
pub type ucontext_t = ucontext;
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaltstack(__ss: *const sigaltstack, __oss: *mut sigaltstack)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(__how: ::std::os::raw::c_int,
                           __newmask: *const __sigset_t,
                           __oldmask: *mut __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Latch {
    pub is_set: sig_atomic_t,
    pub is_shared: bool_,
    pub owner_pid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Latch() {
    assert_eq!(::std::mem::size_of::<Latch>() , 12usize);
    assert_eq!(::std::mem::align_of::<Latch>() , 4usize);
}
impl Clone for Latch {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WaitEvent {
    pub pos: ::std::os::raw::c_int,
    pub events: uint32,
    pub fd: pgsocket,
    pub user_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_WaitEvent() {
    assert_eq!(::std::mem::size_of::<WaitEvent>() , 24usize);
    assert_eq!(::std::mem::align_of::<WaitEvent>() , 8usize);
}
impl Clone for WaitEvent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitEventSet([u8; 0]);
extern "C" {
    pub fn InitializeLatchSupport();
}
extern "C" {
    pub fn InitLatch(latch: *mut Latch);
}
extern "C" {
    pub fn InitSharedLatch(latch: *mut Latch);
}
extern "C" {
    pub fn OwnLatch(latch: *mut Latch);
}
extern "C" {
    pub fn DisownLatch(latch: *mut Latch);
}
extern "C" {
    pub fn SetLatch(latch: *mut Latch);
}
extern "C" {
    pub fn ResetLatch(latch: *mut Latch);
}
extern "C" {
    pub fn CreateWaitEventSet(context: MemoryContext,
                              nevents: ::std::os::raw::c_int)
     -> *mut WaitEventSet;
}
extern "C" {
    pub fn FreeWaitEventSet(set: *mut WaitEventSet);
}
extern "C" {
    pub fn AddWaitEventToSet(set: *mut WaitEventSet, events: uint32,
                             fd: pgsocket, latch: *mut Latch,
                             user_data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ModifyWaitEvent(set: *mut WaitEventSet, pos: ::std::os::raw::c_int,
                           events: uint32, latch: *mut Latch);
}
extern "C" {
    pub fn WaitEventSetWait(set: *mut WaitEventSet,
                            timeout: ::std::os::raw::c_long,
                            occurred_events: *mut WaitEvent,
                            nevents: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WaitLatch(latch: *mut Latch, wakeEvents: ::std::os::raw::c_int,
                     timeout: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn WaitLatchOrSocket(latch: *mut Latch,
                             wakeEvents: ::std::os::raw::c_int,
                             sock: pgsocket, timeout: ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn latch_sigusr1_handler();
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PGSemaphoreData {
    pub semId: ::std::os::raw::c_int,
    pub semNum: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PGSemaphoreData() {
    assert_eq!(::std::mem::size_of::<PGSemaphoreData>() , 8usize);
    assert_eq!(::std::mem::align_of::<PGSemaphoreData>() , 4usize);
}
impl Clone for PGSemaphoreData {
    fn clone(&self) -> Self { *self }
}
pub type PGSemaphore = *mut PGSemaphoreData;
extern "C" {
    pub fn PGReserveSemaphores(maxSemas: ::std::os::raw::c_int,
                               port: ::std::os::raw::c_int);
}
extern "C" {
    pub fn PGSemaphoreCreate(sema: PGSemaphore);
}
extern "C" {
    pub fn PGSemaphoreReset(sema: PGSemaphore);
}
extern "C" {
    pub fn PGSemaphoreLock(sema: PGSemaphore);
}
extern "C" {
    pub fn PGSemaphoreUnlock(sema: PGSemaphore);
}
extern "C" {
    pub fn PGSemaphoreTryLock(sema: PGSemaphore) -> bool_;
}
#[repr(C)]
pub struct XidCache {
    pub xids: [TransactionId; 64usize],
}
#[test]
fn bindgen_test_layout_XidCache() {
    assert_eq!(::std::mem::size_of::<XidCache>() , 256usize);
    assert_eq!(::std::mem::align_of::<XidCache>() , 4usize);
}
extern "C" {
    #[link_name = "MyProc"]
    pub static mut MyProc: *mut PGPROC;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PGXACT {
    pub xid: TransactionId,
    pub xmin: TransactionId,
    pub vacuumFlags: uint8,
    pub overflowed: bool_,
    pub delayChkpt: bool_,
    pub nxids: uint8,
}
#[test]
fn bindgen_test_layout_PGXACT() {
    assert_eq!(::std::mem::size_of::<PGXACT>() , 12usize);
    assert_eq!(::std::mem::align_of::<PGXACT>() , 4usize);
}
impl Clone for PGXACT {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "MyPgXact"]
    pub static mut MyPgXact: *mut PGXACT;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PROC_HDR {
    pub allProcs: *mut PGPROC,
    pub allPgXact: *mut PGXACT,
    pub allProcCount: uint32,
    pub freeProcs: *mut PGPROC,
    pub autovacFreeProcs: *mut PGPROC,
    pub bgworkerFreeProcs: *mut PGPROC,
    pub procArrayGroupFirst: pg_atomic_uint32,
    pub walwriterLatch: *mut Latch,
    pub checkpointerLatch: *mut Latch,
    pub spins_per_delay: ::std::os::raw::c_int,
    pub startupProc: *mut PGPROC,
    pub startupProcPid: ::std::os::raw::c_int,
    pub startupBufferPinWaitBufId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PROC_HDR() {
    assert_eq!(::std::mem::size_of::<PROC_HDR>() , 96usize);
    assert_eq!(::std::mem::align_of::<PROC_HDR>() , 8usize);
}
impl Clone for PROC_HDR {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ProcGlobal"]
    pub static mut ProcGlobal: *mut PROC_HDR;
}
extern "C" {
    #[link_name = "PreparedXactProcs"]
    pub static mut PreparedXactProcs: *mut PGPROC;
}
extern "C" {
    #[link_name = "DeadlockTimeout"]
    pub static mut DeadlockTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "StatementTimeout"]
    pub static mut StatementTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "LockTimeout"]
    pub static mut LockTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "IdleInTransactionSessionTimeout"]
    pub static mut IdleInTransactionSessionTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "log_lock_waits"]
    pub static mut log_lock_waits: bool_;
}
extern "C" {
    pub fn ProcGlobalSemas() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ProcGlobalShmemSize() -> Size;
}
extern "C" {
    pub fn InitProcGlobal();
}
extern "C" {
    pub fn InitProcess();
}
extern "C" {
    pub fn InitProcessPhase2();
}
extern "C" {
    pub fn InitAuxiliaryProcess();
}
extern "C" {
    pub fn PublishStartupProcessInformation();
}
extern "C" {
    pub fn SetStartupBufferPinWaitBufId(bufid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn GetStartupBufferPinWaitBufId() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HaveNFreeProcs(n: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn ProcReleaseLocks(isCommit: bool_);
}
extern "C" {
    pub fn ProcQueueInit(queue: *mut PROC_QUEUE);
}
extern "C" {
    pub fn ProcSleep(locallock: *mut LOCALLOCK, lockMethodTable: LockMethod)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ProcWakeup(proc_: *mut PGPROC, waitStatus: ::std::os::raw::c_int)
     -> *mut PGPROC;
}
extern "C" {
    pub fn ProcLockWakeup(lockMethodTable: LockMethod, lock: *mut LOCK);
}
extern "C" {
    pub fn CheckDeadLockAlert();
}
extern "C" {
    pub fn IsWaitingForLock() -> bool_;
}
extern "C" {
    pub fn LockErrorCleanup();
}
extern "C" {
    pub fn ProcWaitForSignal();
}
extern "C" {
    pub fn ProcSendSignal(pid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn BecomeLockGroupLeader();
}
extern "C" {
    pub fn BecomeLockGroupMember(leader: *mut PGPROC,
                                 pid: ::std::os::raw::c_int) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_mq_handle([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_72 {
    pub data: *const ::std::os::raw::c_char,
    pub len: Size,
}
#[test]
fn bindgen_test_layout__bindgen_ty_72() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_72>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_72>() , 8usize);
}
impl Clone for _bindgen_ty_72 {
    fn clone(&self) -> Self { *self }
}
pub type shm_mq_iovec = _bindgen_ty_72;
pub const SHM_MQ_SUCCESS: _bindgen_ty_73 = _bindgen_ty_73::SHM_MQ_SUCCESS;
pub const SHM_MQ_WOULD_BLOCK: _bindgen_ty_73 =
    _bindgen_ty_73::SHM_MQ_WOULD_BLOCK;
pub const SHM_MQ_DETACHED: _bindgen_ty_73 = _bindgen_ty_73::SHM_MQ_DETACHED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_73 {
    SHM_MQ_SUCCESS = 0,
    SHM_MQ_WOULD_BLOCK = 1,
    SHM_MQ_DETACHED = 2,
}
pub use self::_bindgen_ty_73 as shm_mq_result;
extern "C" {
    pub fn shm_mq_create(address: *mut ::std::os::raw::c_void, size: Size)
     -> *mut shm_mq;
}
extern "C" {
    pub fn shm_mq_set_receiver(mq: *mut shm_mq, arg1: *mut PGPROC);
}
extern "C" {
    pub fn shm_mq_set_sender(mq: *mut shm_mq, arg1: *mut PGPROC);
}
extern "C" {
    pub fn shm_mq_get_receiver(arg1: *mut shm_mq) -> *mut PGPROC;
}
extern "C" {
    pub fn shm_mq_get_sender(arg1: *mut shm_mq) -> *mut PGPROC;
}
extern "C" {
    pub fn shm_mq_attach(mq: *mut shm_mq, seg: *mut dsm_segment,
                         handle: *mut BackgroundWorkerHandle)
     -> *mut shm_mq_handle;
}
extern "C" {
    pub fn shm_mq_set_handle(arg1: *mut shm_mq_handle,
                             arg2: *mut BackgroundWorkerHandle);
}
extern "C" {
    pub fn shm_mq_detach(arg1: *mut shm_mq);
}
extern "C" {
    pub fn shm_mq_get_queue(mqh: *mut shm_mq_handle) -> *mut shm_mq;
}
extern "C" {
    pub fn shm_mq_send(mqh: *mut shm_mq_handle, nbytes: Size,
                       data: *const ::std::os::raw::c_void, nowait: bool_)
     -> shm_mq_result;
}
extern "C" {
    pub fn shm_mq_sendv(mqh: *mut shm_mq_handle, iov: *mut shm_mq_iovec,
                        iovcnt: ::std::os::raw::c_int, nowait: bool_)
     -> shm_mq_result;
}
extern "C" {
    pub fn shm_mq_receive(mqh: *mut shm_mq_handle, nbytesp: *mut Size,
                          datap: *mut *mut ::std::os::raw::c_void,
                          nowait: bool_) -> shm_mq_result;
}
extern "C" {
    pub fn shm_mq_wait_for_attach(mqh: *mut shm_mq_handle) -> shm_mq_result;
}
extern "C" {
    #[link_name = "shm_mq_minimum_size"]
    pub static shm_mq_minimum_size: Size;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct shm_toc([u8; 0]);
extern "C" {
    pub fn shm_toc_create(magic: uint64, address: *mut ::std::os::raw::c_void,
                          nbytes: Size) -> *mut shm_toc;
}
extern "C" {
    pub fn shm_toc_attach(magic: uint64, address: *mut ::std::os::raw::c_void)
     -> *mut shm_toc;
}
extern "C" {
    pub fn shm_toc_allocate(toc: *mut shm_toc, nbytes: Size)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn shm_toc_freespace(toc: *mut shm_toc) -> Size;
}
extern "C" {
    pub fn shm_toc_insert(toc: *mut shm_toc, key: uint64,
                          address: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn shm_toc_lookup(toc: *mut shm_toc, key: uint64)
     -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_74 {
    pub space_for_chunks: Size,
    pub number_of_keys: Size,
}
#[test]
fn bindgen_test_layout__bindgen_ty_74() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_74>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_74>() , 8usize);
}
impl Clone for _bindgen_ty_74 {
    fn clone(&self) -> Self { *self }
}
pub type shm_toc_estimator = _bindgen_ty_74;
extern "C" {
    pub fn shm_toc_estimate(arg1: *mut shm_toc_estimator) -> Size;
}
pub type parallel_worker_main_type =
    ::std::option::Option<unsafe extern "C" fn(seg: *mut dsm_segment,
                                               toc: *mut shm_toc)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ParallelWorkerInfo {
    pub bgwhandle: *mut BackgroundWorkerHandle,
    pub error_mqh: *mut shm_mq_handle,
    pub pid: int32,
}
#[test]
fn bindgen_test_layout_ParallelWorkerInfo() {
    assert_eq!(::std::mem::size_of::<ParallelWorkerInfo>() , 24usize);
    assert_eq!(::std::mem::align_of::<ParallelWorkerInfo>() , 8usize);
}
impl Clone for ParallelWorkerInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ParallelContext {
    pub node: dlist_node,
    pub subid: SubTransactionId,
    pub nworkers: ::std::os::raw::c_int,
    pub nworkers_launched: ::std::os::raw::c_int,
    pub entrypoint: parallel_worker_main_type,
    pub library_name: *mut ::std::os::raw::c_char,
    pub function_name: *mut ::std::os::raw::c_char,
    pub error_context_stack: *mut ErrorContextCallback,
    pub estimator: shm_toc_estimator,
    pub seg: *mut dsm_segment,
    pub private_memory: *mut ::std::os::raw::c_void,
    pub toc: *mut shm_toc,
    pub worker: *mut ParallelWorkerInfo,
}
#[test]
fn bindgen_test_layout_ParallelContext() {
    assert_eq!(::std::mem::size_of::<ParallelContext>() , 112usize);
    assert_eq!(::std::mem::align_of::<ParallelContext>() , 8usize);
}
impl Clone for ParallelContext {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ParallelMessagePending"]
    pub static mut ParallelMessagePending: bool_;
}
extern "C" {
    #[link_name = "ParallelWorkerNumber"]
    pub static mut ParallelWorkerNumber: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "InitializingParallelWorker"]
    pub static mut InitializingParallelWorker: bool_;
}
extern "C" {
    pub fn CreateParallelContext(entrypoint: parallel_worker_main_type,
                                 nworkers: ::std::os::raw::c_int)
     -> *mut ParallelContext;
}
extern "C" {
    pub fn CreateParallelContextForExternalFunction(library_name:
                                                        *mut ::std::os::raw::c_char,
                                                    function_name:
                                                        *mut ::std::os::raw::c_char,
                                                    nworkers:
                                                        ::std::os::raw::c_int)
     -> *mut ParallelContext;
}
extern "C" {
    pub fn InitializeParallelDSM(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn ReinitializeParallelDSM(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn LaunchParallelWorkers(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn WaitForParallelWorkersToFinish(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn DestroyParallelContext(pcxt: *mut ParallelContext);
}
extern "C" {
    pub fn ParallelContextActive() -> bool_;
}
extern "C" {
    pub fn HandleParallelMessageInterrupt();
}
extern "C" {
    pub fn HandleParallelMessages();
}
extern "C" {
    pub fn AtEOXact_Parallel(isCommit: bool_);
}
extern "C" {
    pub fn AtEOSubXact_Parallel(isCommit: bool_, mySubId: SubTransactionId);
}
extern "C" {
    pub fn ParallelWorkerReportLastRecEnd(last_xlog_end: XLogRecPtr);
}
pub type Relids = *mut Bitmapset;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum CostSelector { STARTUP_COST = 0, TOTAL_COST = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct QualCost {
    pub startup: Cost,
    pub per_tuple: Cost,
}
#[test]
fn bindgen_test_layout_QualCost() {
    assert_eq!(::std::mem::size_of::<QualCost>() , 16usize);
    assert_eq!(::std::mem::align_of::<QualCost>() , 8usize);
}
impl Clone for QualCost {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AggClauseCosts {
    pub numAggs: ::std::os::raw::c_int,
    pub numOrderedAggs: ::std::os::raw::c_int,
    pub hasNonPartial: bool_,
    pub hasNonSerial: bool_,
    pub transCost: QualCost,
    pub finalCost: Cost,
    pub transitionSpace: Size,
}
#[test]
fn bindgen_test_layout_AggClauseCosts() {
    assert_eq!(::std::mem::size_of::<AggClauseCosts>() , 48usize);
    assert_eq!(::std::mem::align_of::<AggClauseCosts>() , 8usize);
}
impl Clone for AggClauseCosts {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum UpperRelationKind {
    UPPERREL_SETOP = 0,
    UPPERREL_GROUP_AGG = 1,
    UPPERREL_WINDOW = 2,
    UPPERREL_DISTINCT = 3,
    UPPERREL_ORDERED = 4,
    UPPERREL_FINAL = 5,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlannerGlobal {
    pub type_: NodeTag,
    pub boundParams: ParamListInfo,
    pub subplans: *mut List,
    pub subroots: *mut List,
    pub rewindPlanIDs: *mut Bitmapset,
    pub finalrtable: *mut List,
    pub finalrowmarks: *mut List,
    pub resultRelations: *mut List,
    pub relationOids: *mut List,
    pub invalItems: *mut List,
    pub nParamExec: ::std::os::raw::c_int,
    pub lastPHId: Index,
    pub lastRowMarkId: Index,
    pub lastPlanNodeId: ::std::os::raw::c_int,
    pub transientPlan: bool_,
    pub dependsOnRole: bool_,
    pub parallelModeOK: bool_,
    pub parallelModeNeeded: bool_,
}
#[test]
fn bindgen_test_layout_PlannerGlobal() {
    assert_eq!(::std::mem::size_of::<PlannerGlobal>() , 104usize);
    assert_eq!(::std::mem::align_of::<PlannerGlobal>() , 8usize);
}
impl Clone for PlannerGlobal {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RelOptKind {
    RELOPT_BASEREL = 0,
    RELOPT_JOINREL = 1,
    RELOPT_OTHER_MEMBER_REL = 2,
    RELOPT_UPPER_REL = 3,
    RELOPT_DEADREL = 4,
}
pub type RelOptInfo = PlannerInfo_RelOptInfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct IndexOptInfo {
    pub type_: NodeTag,
    pub indexoid: Oid,
    pub reltablespace: Oid,
    pub rel: *mut RelOptInfo,
    pub pages: BlockNumber,
    pub tuples: f64,
    pub tree_height: ::std::os::raw::c_int,
    pub ncolumns: ::std::os::raw::c_int,
    pub indexkeys: *mut ::std::os::raw::c_int,
    pub indexcollations: *mut Oid,
    pub opfamily: *mut Oid,
    pub opcintype: *mut Oid,
    pub sortopfamily: *mut Oid,
    pub reverse_sort: *mut bool_,
    pub nulls_first: *mut bool_,
    pub canreturn: *mut bool_,
    pub relam: Oid,
    pub indexprs: *mut List,
    pub indpred: *mut List,
    pub indextlist: *mut List,
    pub indrestrictinfo: *mut List,
    pub predOK: bool_,
    pub unique: bool_,
    pub immediate: bool_,
    pub hypothetical: bool_,
    pub amcanorderbyop: bool_,
    pub amoptionalkey: bool_,
    pub amsearcharray: bool_,
    pub amsearchnulls: bool_,
    pub amhasgettuple: bool_,
    pub amhasgetbitmap: bool_,
    pub amcostestimate: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_IndexOptInfo() {
    assert_eq!(::std::mem::size_of::<IndexOptInfo>() , 176usize);
    assert_eq!(::std::mem::align_of::<IndexOptInfo>() , 8usize);
}
impl Clone for IndexOptInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignKeyOptInfo {
    pub type_: NodeTag,
    pub con_relid: Index,
    pub ref_relid: Index,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
    pub nmatched_ec: ::std::os::raw::c_int,
    pub nmatched_rcols: ::std::os::raw::c_int,
    pub nmatched_ri: ::std::os::raw::c_int,
    pub eclass: [*mut ForeignKeyOptInfo_EquivalenceClass; 32usize],
    pub rinfos: [*mut List; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignKeyOptInfo_EquivalenceClass {
    pub type_: NodeTag,
    pub ec_opfamilies: *mut List,
    pub ec_collation: Oid,
    pub ec_members: *mut List,
    pub ec_sources: *mut List,
    pub ec_derives: *mut List,
    pub ec_relids: Relids,
    pub ec_has_const: bool_,
    pub ec_has_volatile: bool_,
    pub ec_below_outer_join: bool_,
    pub ec_broken: bool_,
    pub ec_sortref: Index,
    pub ec_merged: *mut ForeignKeyOptInfo_EquivalenceClass,
}
#[test]
fn bindgen_test_layout_ForeignKeyOptInfo_EquivalenceClass() {
    assert_eq!(::std::mem::size_of::<ForeignKeyOptInfo_EquivalenceClass>() ,
               72usize);
    assert_eq!(::std::mem::align_of::<ForeignKeyOptInfo_EquivalenceClass>() ,
               8usize);
}
impl Clone for ForeignKeyOptInfo_EquivalenceClass {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ForeignKeyOptInfo() {
    assert_eq!(::std::mem::size_of::<ForeignKeyOptInfo>() , 800usize);
    assert_eq!(::std::mem::align_of::<ForeignKeyOptInfo>() , 8usize);
}
impl Clone for ForeignKeyOptInfo {
    fn clone(&self) -> Self { *self }
}
pub type EquivalenceClass = ForeignKeyOptInfo_EquivalenceClass;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct EquivalenceMember {
    pub type_: NodeTag,
    pub em_expr: *mut Expr,
    pub em_relids: Relids,
    pub em_nullable_relids: Relids,
    pub em_is_const: bool_,
    pub em_is_child: bool_,
    pub em_datatype: Oid,
}
#[test]
fn bindgen_test_layout_EquivalenceMember() {
    assert_eq!(::std::mem::size_of::<EquivalenceMember>() , 40usize);
    assert_eq!(::std::mem::align_of::<EquivalenceMember>() , 8usize);
}
impl Clone for EquivalenceMember {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PathKey {
    pub type_: NodeTag,
    pub pk_eclass: *mut EquivalenceClass,
    pub pk_opfamily: Oid,
    pub pk_strategy: ::std::os::raw::c_int,
    pub pk_nulls_first: bool_,
}
#[test]
fn bindgen_test_layout_PathKey() {
    assert_eq!(::std::mem::size_of::<PathKey>() , 32usize);
    assert_eq!(::std::mem::align_of::<PathKey>() , 8usize);
}
impl Clone for PathKey {
    fn clone(&self) -> Self { *self }
}
pub type PathTarget = PlannerInfo_PathTarget;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ParamPathInfo {
    pub type_: NodeTag,
    pub ppi_req_outer: Relids,
    pub ppi_rows: f64,
    pub ppi_clauses: *mut List,
}
#[test]
fn bindgen_test_layout_ParamPathInfo() {
    assert_eq!(::std::mem::size_of::<ParamPathInfo>() , 32usize);
    assert_eq!(::std::mem::align_of::<ParamPathInfo>() , 8usize);
}
impl Clone for ParamPathInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapHeapPath {
    pub path: Path,
    pub bitmapqual: *mut Path,
}
#[test]
fn bindgen_test_layout_BitmapHeapPath() {
    assert_eq!(::std::mem::size_of::<BitmapHeapPath>() , 80usize);
    assert_eq!(::std::mem::align_of::<BitmapHeapPath>() , 8usize);
}
impl Clone for BitmapHeapPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapAndPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
#[test]
fn bindgen_test_layout_BitmapAndPath() {
    assert_eq!(::std::mem::size_of::<BitmapAndPath>() , 88usize);
    assert_eq!(::std::mem::align_of::<BitmapAndPath>() , 8usize);
}
impl Clone for BitmapAndPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct BitmapOrPath {
    pub path: Path,
    pub bitmapquals: *mut List,
    pub bitmapselectivity: Selectivity,
}
#[test]
fn bindgen_test_layout_BitmapOrPath() {
    assert_eq!(::std::mem::size_of::<BitmapOrPath>() , 88usize);
    assert_eq!(::std::mem::align_of::<BitmapOrPath>() , 8usize);
}
impl Clone for BitmapOrPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TidPath {
    pub path: Path,
    pub tidquals: *mut List,
}
#[test]
fn bindgen_test_layout_TidPath() {
    assert_eq!(::std::mem::size_of::<TidPath>() , 80usize);
    assert_eq!(::std::mem::align_of::<TidPath>() , 8usize);
}
impl Clone for TidPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SubqueryScanPath {
    pub path: Path,
    pub subpath: *mut Path,
}
#[test]
fn bindgen_test_layout_SubqueryScanPath() {
    assert_eq!(::std::mem::size_of::<SubqueryScanPath>() , 80usize);
    assert_eq!(::std::mem::align_of::<SubqueryScanPath>() , 8usize);
}
impl Clone for SubqueryScanPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignPath {
    pub path: Path,
    pub fdw_outerpath: *mut Path,
    pub fdw_private: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignPath() {
    assert_eq!(::std::mem::size_of::<ForeignPath>() , 88usize);
    assert_eq!(::std::mem::align_of::<ForeignPath>() , 8usize);
}
impl Clone for ForeignPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomPathMethods([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CustomPath {
    pub path: Path,
    pub flags: uint32,
    pub custom_paths: *mut List,
    pub custom_private: *mut List,
    pub methods: *const CustomPathMethods,
}
#[test]
fn bindgen_test_layout_CustomPath() {
    assert_eq!(::std::mem::size_of::<CustomPath>() , 104usize);
    assert_eq!(::std::mem::align_of::<CustomPath>() , 8usize);
}
impl Clone for CustomPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AppendPath {
    pub path: Path,
    pub subpaths: *mut List,
}
#[test]
fn bindgen_test_layout_AppendPath() {
    assert_eq!(::std::mem::size_of::<AppendPath>() , 80usize);
    assert_eq!(::std::mem::align_of::<AppendPath>() , 8usize);
}
impl Clone for AppendPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MergeAppendPath {
    pub path: Path,
    pub subpaths: *mut List,
    pub limit_tuples: f64,
}
#[test]
fn bindgen_test_layout_MergeAppendPath() {
    assert_eq!(::std::mem::size_of::<MergeAppendPath>() , 88usize);
    assert_eq!(::std::mem::align_of::<MergeAppendPath>() , 8usize);
}
impl Clone for MergeAppendPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ResultPath {
    pub path: Path,
    pub quals: *mut List,
}
#[test]
fn bindgen_test_layout_ResultPath() {
    assert_eq!(::std::mem::size_of::<ResultPath>() , 80usize);
    assert_eq!(::std::mem::align_of::<ResultPath>() , 8usize);
}
impl Clone for ResultPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MaterialPath {
    pub path: Path,
    pub subpath: *mut Path,
}
#[test]
fn bindgen_test_layout_MaterialPath() {
    assert_eq!(::std::mem::size_of::<MaterialPath>() , 80usize);
    assert_eq!(::std::mem::align_of::<MaterialPath>() , 8usize);
}
impl Clone for MaterialPath {
    fn clone(&self) -> Self { *self }
}
pub const UNIQUE_PATH_NOOP: _bindgen_ty_75 = _bindgen_ty_75::UNIQUE_PATH_NOOP;
pub const UNIQUE_PATH_HASH: _bindgen_ty_75 = _bindgen_ty_75::UNIQUE_PATH_HASH;
pub const UNIQUE_PATH_SORT: _bindgen_ty_75 = _bindgen_ty_75::UNIQUE_PATH_SORT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_75 {
    UNIQUE_PATH_NOOP = 0,
    UNIQUE_PATH_HASH = 1,
    UNIQUE_PATH_SORT = 2,
}
pub use self::_bindgen_ty_75 as UniquePathMethod;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub umethod: UniquePathMethod,
    pub in_operators: *mut List,
    pub uniq_exprs: *mut List,
}
#[test]
fn bindgen_test_layout_UniquePath() {
    assert_eq!(::std::mem::size_of::<UniquePath>() , 104usize);
    assert_eq!(::std::mem::align_of::<UniquePath>() , 8usize);
}
impl Clone for UniquePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GatherPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub single_copy: bool_,
}
#[test]
fn bindgen_test_layout_GatherPath() {
    assert_eq!(::std::mem::size_of::<GatherPath>() , 88usize);
    assert_eq!(::std::mem::align_of::<GatherPath>() , 8usize);
}
impl Clone for GatherPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JoinPath {
    pub path: Path,
    pub jointype: JoinType,
    pub outerjoinpath: *mut Path,
    pub innerjoinpath: *mut Path,
    pub joinrestrictinfo: *mut List,
}
#[test]
fn bindgen_test_layout_JoinPath() {
    assert_eq!(::std::mem::size_of::<JoinPath>() , 104usize);
    assert_eq!(::std::mem::align_of::<JoinPath>() , 8usize);
}
impl Clone for JoinPath {
    fn clone(&self) -> Self { *self }
}
pub type NestPath = JoinPath;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MergePath {
    pub jpath: JoinPath,
    pub path_mergeclauses: *mut List,
    pub outersortkeys: *mut List,
    pub innersortkeys: *mut List,
    pub materialize_inner: bool_,
}
#[test]
fn bindgen_test_layout_MergePath() {
    assert_eq!(::std::mem::size_of::<MergePath>() , 136usize);
    assert_eq!(::std::mem::align_of::<MergePath>() , 8usize);
}
impl Clone for MergePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct HashPath {
    pub jpath: JoinPath,
    pub path_hashclauses: *mut List,
    pub num_batches: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HashPath() {
    assert_eq!(::std::mem::size_of::<HashPath>() , 120usize);
    assert_eq!(::std::mem::align_of::<HashPath>() , 8usize);
}
impl Clone for HashPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ProjectionPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub dummypp: bool_,
}
#[test]
fn bindgen_test_layout_ProjectionPath() {
    assert_eq!(::std::mem::size_of::<ProjectionPath>() , 88usize);
    assert_eq!(::std::mem::align_of::<ProjectionPath>() , 8usize);
}
impl Clone for ProjectionPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SortPath {
    pub path: Path,
    pub subpath: *mut Path,
}
#[test]
fn bindgen_test_layout_SortPath() {
    assert_eq!(::std::mem::size_of::<SortPath>() , 80usize);
    assert_eq!(::std::mem::align_of::<SortPath>() , 8usize);
}
impl Clone for SortPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GroupPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
#[test]
fn bindgen_test_layout_GroupPath() {
    assert_eq!(::std::mem::size_of::<GroupPath>() , 96usize);
    assert_eq!(::std::mem::align_of::<GroupPath>() , 8usize);
}
impl Clone for GroupPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UpperUniquePath {
    pub path: Path,
    pub subpath: *mut Path,
    pub numkeys: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_UpperUniquePath() {
    assert_eq!(::std::mem::size_of::<UpperUniquePath>() , 88usize);
    assert_eq!(::std::mem::align_of::<UpperUniquePath>() , 8usize);
}
impl Clone for UpperUniquePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub aggstrategy: AggStrategy,
    pub aggsplit: AggSplit,
    pub numGroups: f64,
    pub groupClause: *mut List,
    pub qual: *mut List,
}
#[test]
fn bindgen_test_layout_AggPath() {
    assert_eq!(::std::mem::size_of::<AggPath>() , 112usize);
    assert_eq!(::std::mem::align_of::<AggPath>() , 8usize);
}
impl Clone for AggPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct GroupingSetsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub rollup_groupclauses: *mut List,
    pub rollup_lists: *mut List,
    pub qual: *mut List,
}
#[test]
fn bindgen_test_layout_GroupingSetsPath() {
    assert_eq!(::std::mem::size_of::<GroupingSetsPath>() , 104usize);
    assert_eq!(::std::mem::align_of::<GroupingSetsPath>() , 8usize);
}
impl Clone for GroupingSetsPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MinMaxAggPath {
    pub path: Path,
    pub mmaggregates: *mut List,
    pub quals: *mut List,
}
#[test]
fn bindgen_test_layout_MinMaxAggPath() {
    assert_eq!(::std::mem::size_of::<MinMaxAggPath>() , 88usize);
    assert_eq!(::std::mem::align_of::<MinMaxAggPath>() , 8usize);
}
impl Clone for MinMaxAggPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct WindowAggPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub winclause: *mut WindowClause,
    pub winpathkeys: *mut List,
}
#[test]
fn bindgen_test_layout_WindowAggPath() {
    assert_eq!(::std::mem::size_of::<WindowAggPath>() , 96usize);
    assert_eq!(::std::mem::align_of::<WindowAggPath>() , 8usize);
}
impl Clone for WindowAggPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SetOpPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub cmd: SetOpCmd,
    pub strategy: SetOpStrategy,
    pub distinctList: *mut List,
    pub flagColIdx: AttrNumber,
    pub firstFlag: ::std::os::raw::c_int,
    pub numGroups: f64,
}
#[test]
fn bindgen_test_layout_SetOpPath() {
    assert_eq!(::std::mem::size_of::<SetOpPath>() , 112usize);
    assert_eq!(::std::mem::align_of::<SetOpPath>() , 8usize);
}
impl Clone for SetOpPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RecursiveUnionPath {
    pub path: Path,
    pub leftpath: *mut Path,
    pub rightpath: *mut Path,
    pub distinctList: *mut List,
    pub wtParam: ::std::os::raw::c_int,
    pub numGroups: f64,
}
#[test]
fn bindgen_test_layout_RecursiveUnionPath() {
    assert_eq!(::std::mem::size_of::<RecursiveUnionPath>() , 112usize);
    assert_eq!(::std::mem::align_of::<RecursiveUnionPath>() , 8usize);
}
impl Clone for RecursiveUnionPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockRowsPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub rowMarks: *mut List,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LockRowsPath() {
    assert_eq!(::std::mem::size_of::<LockRowsPath>() , 96usize);
    assert_eq!(::std::mem::align_of::<LockRowsPath>() , 8usize);
}
impl Clone for LockRowsPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModifyTablePath {
    pub path: Path,
    pub operation: CmdType,
    pub canSetTag: bool_,
    pub nominalRelation: Index,
    pub resultRelations: *mut List,
    pub subpaths: *mut List,
    pub subroots: *mut List,
    pub withCheckOptionLists: *mut List,
    pub returningLists: *mut List,
    pub rowMarks: *mut List,
    pub onconflict: *mut OnConflictExpr,
    pub epqParam: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ModifyTablePath() {
    assert_eq!(::std::mem::size_of::<ModifyTablePath>() , 152usize);
    assert_eq!(::std::mem::align_of::<ModifyTablePath>() , 8usize);
}
impl Clone for ModifyTablePath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LimitPath {
    pub path: Path,
    pub subpath: *mut Path,
    pub limitOffset: *mut Node,
    pub limitCount: *mut Node,
}
#[test]
fn bindgen_test_layout_LimitPath() {
    assert_eq!(::std::mem::size_of::<LimitPath>() , 96usize);
    assert_eq!(::std::mem::align_of::<LimitPath>() , 8usize);
}
impl Clone for LimitPath {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RestrictInfo {
    pub type_: NodeTag,
    pub clause: *mut Expr,
    pub is_pushed_down: bool_,
    pub outerjoin_delayed: bool_,
    pub can_join: bool_,
    pub pseudoconstant: bool_,
    pub clause_relids: Relids,
    pub required_relids: Relids,
    pub outer_relids: Relids,
    pub nullable_relids: Relids,
    pub left_relids: Relids,
    pub right_relids: Relids,
    pub orclause: *mut Expr,
    pub parent_ec: *mut EquivalenceClass,
    pub eval_cost: QualCost,
    pub norm_selec: Selectivity,
    pub outer_selec: Selectivity,
    pub mergeopfamilies: *mut List,
    pub left_ec: *mut EquivalenceClass,
    pub right_ec: *mut EquivalenceClass,
    pub left_em: *mut EquivalenceMember,
    pub right_em: *mut EquivalenceMember,
    pub scansel_cache: *mut List,
    pub outer_is_left: bool_,
    pub hashjoinoperator: Oid,
    pub left_bucketsize: Selectivity,
    pub right_bucketsize: Selectivity,
}
#[test]
fn bindgen_test_layout_RestrictInfo() {
    assert_eq!(::std::mem::size_of::<RestrictInfo>() , 192usize);
    assert_eq!(::std::mem::align_of::<RestrictInfo>() , 8usize);
}
impl Clone for RestrictInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MergeScanSelCache {
    pub opfamily: Oid,
    pub collation: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub nulls_first: bool_,
    pub leftstartsel: Selectivity,
    pub leftendsel: Selectivity,
    pub rightstartsel: Selectivity,
    pub rightendsel: Selectivity,
}
#[test]
fn bindgen_test_layout_MergeScanSelCache() {
    assert_eq!(::std::mem::size_of::<MergeScanSelCache>() , 48usize);
    assert_eq!(::std::mem::align_of::<MergeScanSelCache>() , 8usize);
}
impl Clone for MergeScanSelCache {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlaceHolderVar {
    pub xpr: Expr,
    pub phexpr: *mut Expr,
    pub phrels: Relids,
    pub phid: Index,
    pub phlevelsup: Index,
}
#[test]
fn bindgen_test_layout_PlaceHolderVar() {
    assert_eq!(::std::mem::size_of::<PlaceHolderVar>() , 32usize);
    assert_eq!(::std::mem::align_of::<PlaceHolderVar>() , 8usize);
}
impl Clone for PlaceHolderVar {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SpecialJoinInfo {
    pub type_: NodeTag,
    pub min_lefthand: Relids,
    pub min_righthand: Relids,
    pub syn_lefthand: Relids,
    pub syn_righthand: Relids,
    pub jointype: JoinType,
    pub lhs_strict: bool_,
    pub delay_upper_joins: bool_,
    pub semi_can_btree: bool_,
    pub semi_can_hash: bool_,
    pub semi_operators: *mut List,
    pub semi_rhs_exprs: *mut List,
}
#[test]
fn bindgen_test_layout_SpecialJoinInfo() {
    assert_eq!(::std::mem::size_of::<SpecialJoinInfo>() , 64usize);
    assert_eq!(::std::mem::align_of::<SpecialJoinInfo>() , 8usize);
}
impl Clone for SpecialJoinInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AppendRelInfo {
    pub type_: NodeTag,
    pub parent_relid: Index,
    pub child_relid: Index,
    pub parent_reltype: Oid,
    pub child_reltype: Oid,
    pub translated_vars: *mut List,
    pub parent_reloid: Oid,
}
#[test]
fn bindgen_test_layout_AppendRelInfo() {
    assert_eq!(::std::mem::size_of::<AppendRelInfo>() , 40usize);
    assert_eq!(::std::mem::align_of::<AppendRelInfo>() , 8usize);
}
impl Clone for AppendRelInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlaceHolderInfo {
    pub type_: NodeTag,
    pub phid: Index,
    pub ph_var: *mut PlaceHolderVar,
    pub ph_eval_at: Relids,
    pub ph_lateral: Relids,
    pub ph_needed: Relids,
    pub ph_width: int32,
}
#[test]
fn bindgen_test_layout_PlaceHolderInfo() {
    assert_eq!(::std::mem::size_of::<PlaceHolderInfo>() , 48usize);
    assert_eq!(::std::mem::align_of::<PlaceHolderInfo>() , 8usize);
}
impl Clone for PlaceHolderInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct MinMaxAggInfo {
    pub type_: NodeTag,
    pub aggfnoid: Oid,
    pub aggsortop: Oid,
    pub target: *mut Expr,
    pub subroot: *mut PlannerInfo,
    pub path: *mut Path,
    pub pathcost: Cost,
    pub param: *mut Param,
}
#[test]
fn bindgen_test_layout_MinMaxAggInfo() {
    assert_eq!(::std::mem::size_of::<MinMaxAggInfo>() , 56usize);
    assert_eq!(::std::mem::align_of::<MinMaxAggInfo>() , 8usize);
}
impl Clone for MinMaxAggInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PlannerParamItem {
    pub type_: NodeTag,
    pub item: *mut Node,
    pub paramId: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PlannerParamItem() {
    assert_eq!(::std::mem::size_of::<PlannerParamItem>() , 24usize);
    assert_eq!(::std::mem::align_of::<PlannerParamItem>() , 8usize);
}
impl Clone for PlannerParamItem {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SemiAntiJoinFactors {
    pub outer_match_frac: Selectivity,
    pub match_count: Selectivity,
}
#[test]
fn bindgen_test_layout_SemiAntiJoinFactors() {
    assert_eq!(::std::mem::size_of::<SemiAntiJoinFactors>() , 16usize);
    assert_eq!(::std::mem::align_of::<SemiAntiJoinFactors>() , 8usize);
}
impl Clone for SemiAntiJoinFactors {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JoinPathExtraData {
    pub restrictlist: *mut List,
    pub mergeclause_list: *mut List,
    pub sjinfo: *mut SpecialJoinInfo,
    pub semifactors: SemiAntiJoinFactors,
    pub param_source_rels: Relids,
}
#[test]
fn bindgen_test_layout_JoinPathExtraData() {
    assert_eq!(::std::mem::size_of::<JoinPathExtraData>() , 48usize);
    assert_eq!(::std::mem::align_of::<JoinPathExtraData>() , 8usize);
}
impl Clone for JoinPathExtraData {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct JoinCostWorkspace {
    pub startup_cost: Cost,
    pub total_cost: Cost,
    pub run_cost: Cost,
    pub inner_run_cost: Cost,
    pub inner_rescan_run_cost: Cost,
    pub outer_rows: f64,
    pub inner_rows: f64,
    pub outer_skip_rows: f64,
    pub inner_skip_rows: f64,
    pub numbuckets: ::std::os::raw::c_int,
    pub numbatches: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_JoinCostWorkspace() {
    assert_eq!(::std::mem::size_of::<JoinCostWorkspace>() , 80usize);
    assert_eq!(::std::mem::align_of::<JoinCostWorkspace>() , 8usize);
}
impl Clone for JoinCostWorkspace {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExplainState([u8; 0]);
pub type GetForeignRelSize_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid)>;
pub type GetForeignPaths_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid)>;
pub type GetForeignPlan_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               baserel: *mut RelOptInfo,
                                               foreigntableid: Oid,
                                               best_path: *mut ForeignPath,
                                               tlist: *mut List,
                                               scan_clauses: *mut List,
                                               outer_plan: *mut Plan)
                              -> *mut ForeignScan>;
pub type BeginForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type IterateForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)
                              -> *mut TupleTableSlot>;
pub type RecheckForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               slot: *mut TupleTableSlot)
                              -> ::std::os::raw::c_char>;
pub type ReScanForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type EndForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignJoinPaths_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               joinrel: *mut RelOptInfo,
                                               outerrel: *mut RelOptInfo,
                                               innerrel: *mut RelOptInfo,
                                               jointype: JoinType,
                                               extra:
                                                   *mut JoinPathExtraData)>;
pub type GetForeignUpperPaths_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               stage: UpperRelationKind,
                                               input_rel: *mut RelOptInfo,
                                               output_rel: *mut RelOptInfo)>;
pub type AddForeignUpdateTargets_function =
    ::std::option::Option<unsafe extern "C" fn(parsetree: *mut Query,
                                               target_rte: *mut RangeTblEntry,
                                               target_relation: Relation)>;
pub type PlanForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               plan: *mut ModifyTable,
                                               resultRelation: Index,
                                               subplan_index:
                                                   ::std::os::raw::c_int)
                              -> *mut List>;
pub type BeginForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(mtstate: *mut ModifyTableState,
                                               rinfo: *mut ResultRelInfo,
                                               fdw_private: *mut List,
                                               subplan_index:
                                                   ::std::os::raw::c_int,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type ExecForeignInsert_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type ExecForeignUpdate_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type ExecForeignDelete_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo,
                                               slot: *mut TupleTableSlot,
                                               planSlot: *mut TupleTableSlot)
                              -> *mut TupleTableSlot>;
pub type EndForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               rinfo: *mut ResultRelInfo)>;
pub type IsForeignRelUpdatable_function =
    ::std::option::Option<unsafe extern "C" fn(rel: Relation)
                              -> ::std::os::raw::c_int>;
pub type PlanDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               plan: *mut ModifyTable,
                                               resultRelation: Index,
                                               subplan_index:
                                                   ::std::os::raw::c_int)
                              -> ::std::os::raw::c_char>;
pub type BeginDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               eflags:
                                                   ::std::os::raw::c_int)>;
pub type IterateDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)
                              -> *mut TupleTableSlot>;
pub type EndDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState)>;
pub type GetForeignRowMarkType_function =
    ::std::option::Option<unsafe extern "C" fn(rte: *mut RangeTblEntry,
                                               strength: LockClauseStrength)
                              -> RowMarkType>;
pub type RefetchForeignRow_function =
    ::std::option::Option<unsafe extern "C" fn(estate: *mut EState,
                                               erm: *mut ExecRowMark,
                                               rowid: Datum,
                                               updated: *mut bool_)
                              -> *mut HeapTupleData>;
pub type ExplainForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               es: *mut ExplainState)>;
pub type ExplainForeignModify_function =
    ::std::option::Option<unsafe extern "C" fn(mtstate: *mut ModifyTableState,
                                               rinfo: *mut ResultRelInfo,
                                               fdw_private: *mut List,
                                               subplan_index:
                                                   ::std::os::raw::c_int,
                                               es: *mut ExplainState)>;
pub type ExplainDirectModify_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               es: *mut ExplainState)>;
pub type AcquireSampleRowsFunc =
    ::std::option::Option<unsafe extern "C" fn(relation: Relation,
                                               elevel: ::std::os::raw::c_int,
                                               rows: *mut HeapTuple,
                                               targrows:
                                                   ::std::os::raw::c_int,
                                               totalrows: *mut f64,
                                               totaldeadrows: *mut f64)
                              -> ::std::os::raw::c_int>;
pub type AnalyzeForeignTable_function =
    ::std::option::Option<unsafe extern "C" fn(relation: Relation,
                                               func:
                                                   *mut AcquireSampleRowsFunc,
                                               totalpages: *mut BlockNumber)
                              -> ::std::os::raw::c_char>;
pub type ImportForeignSchema_function =
    ::std::option::Option<unsafe extern "C" fn(stmt:
                                                   *mut ImportForeignSchemaStmt,
                                               serverOid: Oid) -> *mut List>;
pub type EstimateDSMForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               pcxt: *mut ParallelContext)
                              -> ::std::os::raw::c_ulong>;
pub type InitializeDSMForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               pcxt: *mut ParallelContext,
                                               coordinate:
                                                   *mut ::std::os::raw::c_void)>;
pub type InitializeWorkerForeignScan_function =
    ::std::option::Option<unsafe extern "C" fn(node: *mut ForeignScanState,
                                               toc: *mut shm_toc,
                                               coordinate:
                                                   *mut ::std::os::raw::c_void)>;
pub type IsForeignScanParallelSafe_function =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               rel: *mut RelOptInfo,
                                               rte: *mut RangeTblEntry)
                              -> ::std::os::raw::c_char>;
pub type FdwRoutine = ResultRelInfo_FdwRoutine;
extern "C" {
    pub fn GetFdwRoutine(fdwhandler: Oid) -> *mut FdwRoutine;
}
extern "C" {
    pub fn GetForeignServerIdByRelId(relid: Oid) -> Oid;
}
extern "C" {
    pub fn GetFdwRoutineByServerId(serverid: Oid) -> *mut FdwRoutine;
}
extern "C" {
    pub fn GetFdwRoutineByRelId(relid: Oid) -> *mut FdwRoutine;
}
extern "C" {
    pub fn GetFdwRoutineForRelation(relation: Relation, makecopy: bool_)
     -> *mut FdwRoutine;
}
extern "C" {
    pub fn IsImportableForeignTable(tablename: *const ::std::os::raw::c_char,
                                    stmt: *mut ImportForeignSchemaStmt)
     -> bool_;
}
extern "C" {
    pub fn GetExistingLocalJoinPath(joinrel: *mut RelOptInfo) -> *mut Path;
}
pub const ServerOpt: _bindgen_ty_76 = _bindgen_ty_76::ServerOpt;
pub const UserMappingOpt: _bindgen_ty_76 = _bindgen_ty_76::UserMappingOpt;
pub const FdwOpt: _bindgen_ty_76 = _bindgen_ty_76::FdwOpt;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_76 { ServerOpt = 1, UserMappingOpt = 2, FdwOpt = 4, }
pub use self::_bindgen_ty_76 as GenericOptionFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignDataWrapper {
    pub fdwid: Oid,
    pub owner: Oid,
    pub fdwname: *mut ::std::os::raw::c_char,
    pub fdwhandler: Oid,
    pub fdwvalidator: Oid,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignDataWrapper() {
    assert_eq!(::std::mem::size_of::<ForeignDataWrapper>() , 32usize);
    assert_eq!(::std::mem::align_of::<ForeignDataWrapper>() , 8usize);
}
impl Clone for ForeignDataWrapper {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignServer {
    pub serverid: Oid,
    pub fdwid: Oid,
    pub owner: Oid,
    pub servername: *mut ::std::os::raw::c_char,
    pub servertype: *mut ::std::os::raw::c_char,
    pub serverversion: *mut ::std::os::raw::c_char,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignServer() {
    assert_eq!(::std::mem::size_of::<ForeignServer>() , 48usize);
    assert_eq!(::std::mem::align_of::<ForeignServer>() , 8usize);
}
impl Clone for ForeignServer {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct UserMapping {
    pub umid: Oid,
    pub userid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_UserMapping() {
    assert_eq!(::std::mem::size_of::<UserMapping>() , 24usize);
    assert_eq!(::std::mem::align_of::<UserMapping>() , 8usize);
}
impl Clone for UserMapping {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignTable {
    pub relid: Oid,
    pub serverid: Oid,
    pub options: *mut List,
}
#[test]
fn bindgen_test_layout_ForeignTable() {
    assert_eq!(::std::mem::size_of::<ForeignTable>() , 16usize);
    assert_eq!(::std::mem::align_of::<ForeignTable>() , 8usize);
}
impl Clone for ForeignTable {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn GetForeignServer(serverid: Oid) -> *mut ForeignServer;
}
extern "C" {
    pub fn GetForeignServerByName(name: *const ::std::os::raw::c_char,
                                  missing_ok: bool_) -> *mut ForeignServer;
}
extern "C" {
    pub fn GetUserMapping(userid: Oid, serverid: Oid) -> *mut UserMapping;
}
extern "C" {
    pub fn GetForeignDataWrapper(fdwid: Oid) -> *mut ForeignDataWrapper;
}
extern "C" {
    pub fn GetForeignDataWrapperByName(name: *const ::std::os::raw::c_char,
                                       missing_ok: bool_)
     -> *mut ForeignDataWrapper;
}
extern "C" {
    pub fn GetForeignTable(relid: Oid) -> *mut ForeignTable;
}
extern "C" {
    pub fn GetForeignColumnOptions(relid: Oid, attnum: AttrNumber)
     -> *mut List;
}
extern "C" {
    pub fn get_foreign_data_wrapper_oid(fdwname:
                                            *const ::std::os::raw::c_char,
                                        missing_ok: bool_) -> Oid;
}
extern "C" {
    pub fn get_foreign_server_oid(servername: *const ::std::os::raw::c_char,
                                  missing_ok: bool_) -> Oid;
}
extern "C" {
    pub fn compare_path_costs(path1: *mut Path, path2: *mut Path,
                              criterion: CostSelector)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn compare_fractional_path_costs(path1: *mut Path, path2: *mut Path,
                                         fraction: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_cheapest(parent_rel: *mut RelOptInfo);
}
extern "C" {
    pub fn add_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
}
extern "C" {
    pub fn add_path_precheck(parent_rel: *mut RelOptInfo, startup_cost: Cost,
                             total_cost: Cost, pathkeys: *mut List,
                             required_outer: Relids) -> bool_;
}
extern "C" {
    pub fn add_partial_path(parent_rel: *mut RelOptInfo, new_path: *mut Path);
}
extern "C" {
    pub fn add_partial_path_precheck(parent_rel: *mut RelOptInfo,
                                     total_cost: Cost, pathkeys: *mut List)
     -> bool_;
}
extern "C" {
    pub fn create_seqscan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               required_outer: Relids,
                               parallel_workers: ::std::os::raw::c_int)
     -> *mut Path;
}
extern "C" {
    pub fn create_samplescan_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_index_path(root: *mut PlannerInfo, index: *mut IndexOptInfo,
                             indexclauses: *mut List,
                             indexclausecols: *mut List,
                             indexorderbys: *mut List,
                             indexorderbycols: *mut List, pathkeys: *mut List,
                             indexscandir: ScanDirection, indexonly: bool_,
                             required_outer: Relids, loop_count: f64)
     -> *mut IndexPath;
}
extern "C" {
    pub fn create_bitmap_heap_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo,
                                   bitmapqual: *mut Path,
                                   required_outer: Relids, loop_count: f64)
     -> *mut BitmapHeapPath;
}
extern "C" {
    pub fn create_bitmap_and_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  bitmapquals: *mut List)
     -> *mut BitmapAndPath;
}
extern "C" {
    pub fn create_bitmap_or_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                 bitmapquals: *mut List) -> *mut BitmapOrPath;
}
extern "C" {
    pub fn create_tidscan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               tidquals: *mut List, required_outer: Relids)
     -> *mut TidPath;
}
extern "C" {
    pub fn create_append_path(rel: *mut RelOptInfo, subpaths: *mut List,
                              required_outer: Relids,
                              parallel_workers: ::std::os::raw::c_int)
     -> *mut AppendPath;
}
extern "C" {
    pub fn create_merge_append_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpaths: *mut List,
                                    pathkeys: *mut List,
                                    required_outer: Relids)
     -> *mut MergeAppendPath;
}
extern "C" {
    pub fn create_result_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                              target: *mut PathTarget,
                              resconstantqual: *mut List) -> *mut ResultPath;
}
extern "C" {
    pub fn create_material_path(rel: *mut RelOptInfo, subpath: *mut Path)
     -> *mut MaterialPath;
}
extern "C" {
    pub fn create_unique_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                              subpath: *mut Path,
                              sjinfo: *mut SpecialJoinInfo)
     -> *mut UniquePath;
}
extern "C" {
    pub fn create_gather_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                              subpath: *mut Path, target: *mut PathTarget,
                              required_outer: Relids, rows: *mut f64)
     -> *mut GatherPath;
}
extern "C" {
    pub fn create_subqueryscan_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpath: *mut Path,
                                    pathkeys: *mut List,
                                    required_outer: Relids)
     -> *mut SubqueryScanPath;
}
extern "C" {
    pub fn create_functionscan_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, pathkeys: *mut List,
                                    required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_valuesscan_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo,
                                  required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_ctescan_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                               required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_worktablescan_path(root: *mut PlannerInfo,
                                     rel: *mut RelOptInfo,
                                     required_outer: Relids) -> *mut Path;
}
extern "C" {
    pub fn create_foreignscan_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo,
                                   target: *mut PathTarget, rows: f64,
                                   startup_cost: Cost, total_cost: Cost,
                                   pathkeys: *mut List,
                                   required_outer: Relids,
                                   fdw_outerpath: *mut Path,
                                   fdw_private: *mut List)
     -> *mut ForeignPath;
}
extern "C" {
    pub fn calc_nestloop_required_outer(outer_path: *mut Path,
                                        inner_path: *mut Path) -> Relids;
}
extern "C" {
    pub fn calc_non_nestloop_required_outer(outer_path: *mut Path,
                                            inner_path: *mut Path) -> Relids;
}
extern "C" {
    pub fn create_nestloop_path(root: *mut PlannerInfo,
                                joinrel: *mut RelOptInfo, jointype: JoinType,
                                workspace: *mut JoinCostWorkspace,
                                sjinfo: *mut SpecialJoinInfo,
                                semifactors: *mut SemiAntiJoinFactors,
                                outer_path: *mut Path, inner_path: *mut Path,
                                restrict_clauses: *mut List,
                                pathkeys: *mut List, required_outer: Relids)
     -> *mut NestPath;
}
extern "C" {
    pub fn create_mergejoin_path(root: *mut PlannerInfo,
                                 joinrel: *mut RelOptInfo, jointype: JoinType,
                                 workspace: *mut JoinCostWorkspace,
                                 sjinfo: *mut SpecialJoinInfo,
                                 outer_path: *mut Path, inner_path: *mut Path,
                                 restrict_clauses: *mut List,
                                 pathkeys: *mut List, required_outer: Relids,
                                 mergeclauses: *mut List,
                                 outersortkeys: *mut List,
                                 innersortkeys: *mut List) -> *mut MergePath;
}
extern "C" {
    pub fn create_hashjoin_path(root: *mut PlannerInfo,
                                joinrel: *mut RelOptInfo, jointype: JoinType,
                                workspace: *mut JoinCostWorkspace,
                                sjinfo: *mut SpecialJoinInfo,
                                semifactors: *mut SemiAntiJoinFactors,
                                outer_path: *mut Path, inner_path: *mut Path,
                                restrict_clauses: *mut List,
                                required_outer: Relids,
                                hashclauses: *mut List) -> *mut HashPath;
}
extern "C" {
    pub fn create_projection_path(root: *mut PlannerInfo,
                                  rel: *mut RelOptInfo, subpath: *mut Path,
                                  target: *mut PathTarget)
     -> *mut ProjectionPath;
}
extern "C" {
    pub fn apply_projection_to_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, path: *mut Path,
                                    target: *mut PathTarget) -> *mut Path;
}
extern "C" {
    pub fn create_sort_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                            subpath: *mut Path, pathkeys: *mut List,
                            limit_tuples: f64) -> *mut SortPath;
}
extern "C" {
    pub fn create_group_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                             subpath: *mut Path, target: *mut PathTarget,
                             groupClause: *mut List, qual: *mut List,
                             numGroups: f64) -> *mut GroupPath;
}
extern "C" {
    pub fn create_upper_unique_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpath: *mut Path,
                                    numCols: ::std::os::raw::c_int,
                                    numGroups: f64) -> *mut UpperUniquePath;
}
extern "C" {
    pub fn create_agg_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                           subpath: *mut Path, target: *mut PathTarget,
                           aggstrategy: AggStrategy, aggsplit: AggSplit,
                           groupClause: *mut List, qual: *mut List,
                           aggcosts: *const AggClauseCosts, numGroups: f64)
     -> *mut AggPath;
}
extern "C" {
    pub fn create_groupingsets_path(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo, subpath: *mut Path,
                                    target: *mut PathTarget,
                                    having_qual: *mut List,
                                    rollup_lists: *mut List,
                                    rollup_groupclauses: *mut List,
                                    agg_costs: *const AggClauseCosts,
                                    numGroups: f64) -> *mut GroupingSetsPath;
}
extern "C" {
    pub fn create_minmaxagg_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                 target: *mut PathTarget,
                                 mmaggregates: *mut List, quals: *mut List)
     -> *mut MinMaxAggPath;
}
extern "C" {
    pub fn create_windowagg_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                 subpath: *mut Path, target: *mut PathTarget,
                                 windowFuncs: *mut List,
                                 winclause: *mut WindowClause,
                                 winpathkeys: *mut List)
     -> *mut WindowAggPath;
}
extern "C" {
    pub fn create_setop_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                             subpath: *mut Path, cmd: SetOpCmd,
                             strategy: SetOpStrategy, distinctList: *mut List,
                             flagColIdx: AttrNumber,
                             firstFlag: ::std::os::raw::c_int, numGroups: f64,
                             outputRows: f64) -> *mut SetOpPath;
}
extern "C" {
    pub fn create_recursiveunion_path(root: *mut PlannerInfo,
                                      rel: *mut RelOptInfo,
                                      leftpath: *mut Path,
                                      rightpath: *mut Path,
                                      target: *mut PathTarget,
                                      distinctList: *mut List,
                                      wtParam: ::std::os::raw::c_int,
                                      numGroups: f64)
     -> *mut RecursiveUnionPath;
}
extern "C" {
    pub fn create_lockrows_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                                subpath: *mut Path, rowMarks: *mut List,
                                epqParam: ::std::os::raw::c_int)
     -> *mut LockRowsPath;
}
extern "C" {
    pub fn create_modifytable_path(root: *mut PlannerInfo,
                                   rel: *mut RelOptInfo, operation: CmdType,
                                   canSetTag: bool_, nominalRelation: Index,
                                   resultRelations: *mut List,
                                   subpaths: *mut List, subroots: *mut List,
                                   withCheckOptionLists: *mut List,
                                   returningLists: *mut List,
                                   rowMarks: *mut List,
                                   onconflict: *mut OnConflictExpr,
                                   epqParam: ::std::os::raw::c_int)
     -> *mut ModifyTablePath;
}
extern "C" {
    pub fn create_limit_path(root: *mut PlannerInfo, rel: *mut RelOptInfo,
                             subpath: *mut Path, limitOffset: *mut Node,
                             limitCount: *mut Node, offset_est: int64,
                             count_est: int64) -> *mut LimitPath;
}
extern "C" {
    pub fn reparameterize_path(root: *mut PlannerInfo, path: *mut Path,
                               required_outer: Relids, loop_count: f64)
     -> *mut Path;
}
extern "C" {
    pub fn setup_simple_rel_arrays(root: *mut PlannerInfo);
}
extern "C" {
    pub fn build_simple_rel(root: *mut PlannerInfo,
                            relid: ::std::os::raw::c_int,
                            reloptkind: RelOptKind) -> *mut RelOptInfo;
}
extern "C" {
    pub fn find_base_rel(root: *mut PlannerInfo, relid: ::std::os::raw::c_int)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn find_join_rel(root: *mut PlannerInfo, relids: Relids)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn build_join_rel(root: *mut PlannerInfo, joinrelids: Relids,
                          outer_rel: *mut RelOptInfo,
                          inner_rel: *mut RelOptInfo,
                          sjinfo: *mut SpecialJoinInfo,
                          restrictlist_ptr: *mut *mut List)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn min_join_parameterization(root: *mut PlannerInfo,
                                     joinrelids: Relids,
                                     outer_rel: *mut RelOptInfo,
                                     inner_rel: *mut RelOptInfo) -> Relids;
}
extern "C" {
    pub fn build_empty_join_rel(root: *mut PlannerInfo) -> *mut RelOptInfo;
}
extern "C" {
    pub fn fetch_upper_rel(root: *mut PlannerInfo, kind: UpperRelationKind,
                           relids: Relids) -> *mut RelOptInfo;
}
extern "C" {
    pub fn find_childrel_appendrelinfo(root: *mut PlannerInfo,
                                       rel: *mut RelOptInfo)
     -> *mut AppendRelInfo;
}
extern "C" {
    pub fn find_childrel_top_parent(root: *mut PlannerInfo,
                                    rel: *mut RelOptInfo) -> *mut RelOptInfo;
}
extern "C" {
    pub fn find_childrel_parents(root: *mut PlannerInfo, rel: *mut RelOptInfo)
     -> Relids;
}
extern "C" {
    pub fn get_baserel_parampathinfo(root: *mut PlannerInfo,
                                     baserel: *mut RelOptInfo,
                                     required_outer: Relids)
     -> *mut ParamPathInfo;
}
extern "C" {
    pub fn get_joinrel_parampathinfo(root: *mut PlannerInfo,
                                     joinrel: *mut RelOptInfo,
                                     outer_path: *mut Path,
                                     inner_path: *mut Path,
                                     sjinfo: *mut SpecialJoinInfo,
                                     required_outer: Relids,
                                     restrict_clauses: *mut *mut List)
     -> *mut ParamPathInfo;
}
extern "C" {
    pub fn get_appendrel_parampathinfo(appendrel: *mut RelOptInfo,
                                       required_outer: Relids)
     -> *mut ParamPathInfo;
}
pub const FORCE_PARALLEL_OFF: _bindgen_ty_77 =
    _bindgen_ty_77::FORCE_PARALLEL_OFF;
pub const FORCE_PARALLEL_ON: _bindgen_ty_77 =
    _bindgen_ty_77::FORCE_PARALLEL_ON;
pub const FORCE_PARALLEL_REGRESS: _bindgen_ty_77 =
    _bindgen_ty_77::FORCE_PARALLEL_REGRESS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_77 {
    FORCE_PARALLEL_OFF = 0,
    FORCE_PARALLEL_ON = 1,
    FORCE_PARALLEL_REGRESS = 2,
}
pub use self::_bindgen_ty_77 as ForceParallelMode;
extern "C" {
    #[link_name = "cursor_tuple_fraction"]
    pub static mut cursor_tuple_fraction: f64;
}
extern "C" {
    #[link_name = "force_parallel_mode"]
    pub static mut force_parallel_mode: ::std::os::raw::c_int;
}
pub type query_pathkeys_callback =
    ::std::option::Option<unsafe extern "C" fn(root: *mut PlannerInfo,
                                               extra:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn query_planner(root: *mut PlannerInfo, tlist: *mut List,
                         qp_callback: query_pathkeys_callback,
                         qp_extra: *mut ::std::os::raw::c_void)
     -> *mut RelOptInfo;
}
extern "C" {
    pub fn preprocess_minmax_aggregates(root: *mut PlannerInfo,
                                        tlist: *mut List);
}
extern "C" {
    pub fn create_plan(root: *mut PlannerInfo, best_path: *mut Path)
     -> *mut Plan;
}
extern "C" {
    pub fn make_foreignscan(qptlist: *mut List, qpqual: *mut List,
                            scanrelid: Index, fdw_exprs: *mut List,
                            fdw_private: *mut List, fdw_scan_tlist: *mut List,
                            fdw_recheck_quals: *mut List,
                            outer_plan: *mut Plan) -> *mut ForeignScan;
}
extern "C" {
    pub fn materialize_finished_plan(subplan: *mut Plan) -> *mut Plan;
}
extern "C" {
    pub fn is_projection_capable_path(path: *mut Path) -> bool_;
}
extern "C" {
    pub fn is_projection_capable_plan(plan: *mut Plan) -> bool_;
}
extern "C" {
    pub fn make_sort_from_sortclauses(sortcls: *mut List, lefttree: *mut Plan)
     -> *mut Sort;
}
extern "C" {
    pub fn make_agg(tlist: *mut List, qual: *mut List,
                    aggstrategy: AggStrategy, aggsplit: AggSplit,
                    numGroupCols: ::std::os::raw::c_int,
                    grpColIdx: *mut AttrNumber, grpOperators: *mut Oid,
                    groupingSets: *mut List, chain: *mut List,
                    dNumGroups: f64, lefttree: *mut Plan) -> *mut Agg;
}
extern "C" {
    pub fn make_limit(lefttree: *mut Plan, limitOffset: *mut Node,
                      limitCount: *mut Node) -> *mut Limit;
}
extern "C" {
    #[link_name = "from_collapse_limit"]
    pub static mut from_collapse_limit: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "join_collapse_limit"]
    pub static mut join_collapse_limit: ::std::os::raw::c_int;
}
extern "C" {
    pub fn add_base_rels_to_query(root: *mut PlannerInfo, jtnode: *mut Node);
}
extern "C" {
    pub fn build_base_rel_tlists(root: *mut PlannerInfo,
                                 final_tlist: *mut List);
}
extern "C" {
    pub fn add_vars_to_targetlist(root: *mut PlannerInfo, vars: *mut List,
                                  where_needed: Relids, create_new_ph: bool_);
}
extern "C" {
    pub fn find_lateral_references(root: *mut PlannerInfo);
}
extern "C" {
    pub fn create_lateral_join_info(root: *mut PlannerInfo);
}
extern "C" {
    pub fn deconstruct_jointree(root: *mut PlannerInfo) -> *mut List;
}
extern "C" {
    pub fn distribute_restrictinfo_to_rels(root: *mut PlannerInfo,
                                           restrictinfo: *mut RestrictInfo);
}
extern "C" {
    pub fn process_implied_equality(root: *mut PlannerInfo, opno: Oid,
                                    collation: Oid, item1: *mut Expr,
                                    item2: *mut Expr, qualscope: Relids,
                                    nullable_relids: Relids,
                                    below_outer_join: bool_,
                                    both_const: bool_);
}
extern "C" {
    pub fn build_implied_join_equality(opno: Oid, collation: Oid,
                                       item1: *mut Expr, item2: *mut Expr,
                                       qualscope: Relids,
                                       nullable_relids: Relids)
     -> *mut RestrictInfo;
}
extern "C" {
    pub fn match_foreign_keys_to_quals(root: *mut PlannerInfo);
}
extern "C" {
    pub fn remove_useless_joins(root: *mut PlannerInfo, joinlist: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn query_supports_distinctness(query: *mut Query) -> bool_;
}
extern "C" {
    pub fn query_is_distinct_for(query: *mut Query, colnos: *mut List,
                                 opids: *mut List) -> bool_;
}
extern "C" {
    pub fn set_plan_references(root: *mut PlannerInfo, plan: *mut Plan)
     -> *mut Plan;
}
extern "C" {
    pub fn record_plan_function_dependency(root: *mut PlannerInfo,
                                           funcid: Oid);
}
extern "C" {
    pub fn extract_query_dependencies(query: *mut Node,
                                      relationOids: *mut *mut List,
                                      invalItems: *mut *mut List,
                                      hasRowSecurity: *mut bool_);
}
extern "C" {
    pub fn make_restrictinfo(clause: *mut Expr, is_pushed_down: bool_,
                             outerjoin_delayed: bool_, pseudoconstant: bool_,
                             required_relids: Relids, outer_relids: Relids,
                             nullable_relids: Relids) -> *mut RestrictInfo;
}
extern "C" {
    pub fn make_restrictinfos_from_actual_clauses(root: *mut PlannerInfo,
                                                  clause_list: *mut List)
     -> *mut List;
}
extern "C" {
    pub fn restriction_is_or_clause(restrictinfo: *mut RestrictInfo) -> bool_;
}
extern "C" {
    pub fn get_actual_clauses(restrictinfo_list: *mut List) -> *mut List;
}
extern "C" {
    pub fn get_all_actual_clauses(restrictinfo_list: *mut List) -> *mut List;
}
extern "C" {
    pub fn extract_actual_clauses(restrictinfo_list: *mut List,
                                  pseudoconstant: bool_) -> *mut List;
}
extern "C" {
    pub fn extract_actual_join_clauses(restrictinfo_list: *mut List,
                                       joinquals: *mut *mut List,
                                       otherquals: *mut *mut List);
}
extern "C" {
    pub fn join_clause_is_movable_to(rinfo: *mut RestrictInfo,
                                     baserel: *mut RelOptInfo) -> bool_;
}
extern "C" {
    pub fn join_clause_is_movable_into(rinfo: *mut RestrictInfo,
                                       currentrelids: Relids,
                                       current_and_outer: Relids) -> bool_;
}
extern "C" {
    pub fn has_any_column_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_any_column_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_id_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_name_attnum(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_column_privilege_id_attnum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_table_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_sequence_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_database_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_database_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name_name(fcinfo:
                                                            FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name_id(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id_name(fcinfo:
                                                          FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_foreign_data_wrapper_privilege_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_function_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_function_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_function_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_language_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_language_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_schema_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_server_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_name_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_name_id(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_id_name(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_tablespace_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn has_type_privilege_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_name_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_name_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_id_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_id_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_has_role_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_indexam_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_index_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_index_column_has_property(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn booltext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn booleq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boollt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn booland_statefunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn boolor_statefunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_alltrue(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_anytrue(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn parse_bool(value: *const ::std::os::raw::c_char,
                      result: *mut bool_) -> bool_;
}
extern "C" {
    pub fn parse_bool_with_len(value: *const ::std::os::raw::c_char,
                               len: usize, result: *mut bool_) -> bool_;
}
extern "C" {
    pub fn charin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chareq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chargt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn charge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chartoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4tochar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn char_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn domain_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn domain_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn domain_check(value: Datum, isnull: bool_, domainType: Oid,
                        extra: *mut *mut ::std::os::raw::c_void,
                        mcxt: MemoryContext);
}
extern "C" {
    pub fn errdatatype(datatypeOid: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn errdomainconstraint(datatypeOid: Oid,
                               conname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn binary_encode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn binary_decode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hex_encode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hex_decode(src: *const ::std::os::raw::c_char,
                      len: ::std::os::raw::c_uint,
                      dst: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn enum_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_first(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_last(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_range_bounds(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn enum_range_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2vectoreq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i2toi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4toi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_bool(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bool_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int24div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int42div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2xor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2shl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2shr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_step_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn buildint2vector(int2s: *const int16, n: ::std::os::raw::c_int)
     -> *mut int2vector;
}
extern "C" {
    pub fn namein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namene(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namelt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namele(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namegt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namege(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namecpy(n1: Name, n2: Name) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn namestrcpy(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn namestrcmp(name: Name, str: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn current_user(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn session_user(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_schema(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_schemas(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_atoi(s: *const ::std::os::raw::c_char,
                   size: ::std::os::raw::c_int, c: ::std::os::raw::c_int)
     -> int32;
}
extern "C" {
    pub fn pg_itoa(i: int16, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pg_ltoa(l: int32, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pg_lltoa(ll: int64, a: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn pg_ltostr_zeropad(str: *mut ::std::os::raw::c_char, value: int32,
                             minwidth: int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_ltostr(str: *mut ::std::os::raw::c_char, value: int32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_strtouint64(str: *const ::std::os::raw::c_char,
                          endptr: *mut *mut ::std::os::raw::c_char,
                          base: ::std::os::raw::c_int) -> uint64;
}
extern "C" {
    pub fn btboolcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint2cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint4cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint8cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat4cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat8cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint48cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint84cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint24cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint42cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint28cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint82cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat48cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat84cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btoidcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btoidvectorcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btabstimecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btreltimecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttintervalcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btcharcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btnamecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttextcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttextsortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint2sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btint8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat4sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btfloat8sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btoidsortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btnamesortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "extra_float_digits"]
    pub static mut extra_float_digits: ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_float8_infinity() -> f64;
}
extern "C" {
    pub fn get_float4_infinity() -> f32;
}
extern "C" {
    pub fn get_float8_nan() -> f64;
}
extern "C" {
    pub fn get_float4_nan() -> f32;
}
extern "C" {
    pub fn is_infinite(val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn float8in_internal(num: *mut ::std::os::raw::c_char,
                             endptr_p: *mut *mut ::std::os::raw::c_char,
                             type_name: *const ::std::os::raw::c_char,
                             orig_string: *const ::std::os::raw::c_char)
     -> f64;
}
extern "C" {
    pub fn float8out_internal(num: f64) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn float4_cmp_internal(a: float4, b: float4) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn float8_cmp_internal(a: float8, b: float8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn float4in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8um(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8up(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ftod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i2tod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtoi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i4tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn i2tof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ftoi4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ftoi2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dround(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dceil(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dfloor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsign(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtrunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsqrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcbrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dpow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dexp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dlog1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dlog10(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dacos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dasin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datan(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datan2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtan(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dacosd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dasind(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn datan2d(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcosd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dcotd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dsind(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dtand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn degrees(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn dpi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn radians(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn drandom(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn setseed(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_sxx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_syy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_sxy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_avgx(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_avgy(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_covar_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_covar_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_corr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_r2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_slope(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_regr_intercept(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84pl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84mi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float48ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float84ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn width_bucket_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_tablespace_size_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_tablespace_size_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_database_size_oid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_database_size_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_total_relation_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_size_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_size_pretty_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_size_bytes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_table_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_indexes_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_filenode(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_filenode_relation(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_filepath(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_stat_file_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_file_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_binary_file(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_binary_file_off_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_read_binary_file_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ls_dir(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ls_dir_1arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_num_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_num_nonnulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_database(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn current_query(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_cancel_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_terminate_backend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_reload_conf(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_tablespace_databases(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_tablespace_location(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_rotate_logfile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_sleep(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_keywords(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_collation_for(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_relation_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_column_is_updatable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn parse_ident(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectoreq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn oidvectorgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn buildoidvector(oids: *const Oid, n: ::std::os::raw::c_int)
     -> *mut oidvector;
}
extern "C" {
    pub fn oidparse(node: *mut Node) -> Oid;
}
extern "C" {
    pub fn ordered_set_transition(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ordered_set_transition_multi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_disc_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_cont_float8_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_cont_interval_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_disc_multi_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn percentile_cont_float8_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn percentile_cont_interval_multi_final(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn mode_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_percent_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_cume_dist_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hypothetical_dense_rank_final(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn any_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn any_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyarray_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anynonarray_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anynonarray_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyenum_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyenum_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyrange_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyrange_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn void_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn trigger_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn trigger_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn event_trigger_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn event_trigger_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn language_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn language_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn fdw_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn fdw_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn index_am_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn index_am_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_handler_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_handler_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn internal_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn internal_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn opaque_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn opaque_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyelement_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn anyelement_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn shell_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn shell_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_node_tree_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_ddl_command_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameicregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameicregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticregexeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticregexne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexsubstr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexreplace_noopt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textregexreplace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn similar_escape(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_matches(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_matches_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_table(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_table_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_split_to_array_no_flags(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regexp_fixed_prefix(text_re: *mut text, case_insensitive: bool_,
                               collation: Oid, exact: *mut bool_)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn regprocin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regproc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regprocedure(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocedurein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocedureout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regprocedurerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regproceduresend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regopersend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regoper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regoperator(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regoperatorsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclassin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclassout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclassrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regclasssend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regclass(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtypein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtypeout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtyperecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regtypesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regtype(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regrolein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regroleout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regrolerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regrolesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regrole(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regnamespacein(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regnamespaceout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regnamespacerecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regnamespacesend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_regnamespace(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regconfigsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionaryin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionaryout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionaryrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn regdictionarysend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_regclass(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn stringToQualifiedNameList(string: *const ::std::os::raw::c_char)
     -> *mut List;
}
extern "C" {
    pub fn format_procedure(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_procedure_qualified(procedure_oid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_procedure_parts(operator_oid: Oid, objnames: *mut *mut List,
                                  objargs: *mut *mut List);
}
extern "C" {
    pub fn format_operator(operator_oid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_operator_qualified(operator_oid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_operator_parts(operator_oid: Oid, objnames: *mut *mut List,
                                 objargs: *mut *mut List);
}
extern "C" {
    pub fn record_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrecordcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn record_image_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrecordimagecmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    #[link_name = "quote_all_identifiers"]
    pub static mut quote_all_identifiers: bool_;
}
extern "C" {
    pub fn pg_get_ruledef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_ruledef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_wrap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_viewdef_name_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_indexdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_indexdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_triggerdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_triggerdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_constraintdef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_constraintdef_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_expr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_expr_ext(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_userbyid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_serial_sequence(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_functiondef(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_function_arguments(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_function_identity_arguments(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_get_function_result(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_function_arg_default(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn quote_identifier(ident: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn quote_qualified_identifier(qualifier:
                                          *const ::std::os::raw::c_char,
                                      ident: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidgt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttidcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidlarger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tidsmaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn currtid_byreloid(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn currtid_byrelname(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn char_bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn name_bpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchareq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharlt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharle(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchargt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharcmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchartruelen(s: *mut ::std::os::raw::c_char,
                         len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bpcharlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpcharoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashbpchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bpchar_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btbpchar_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btbpchar_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varcharsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varchartypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varchartypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varchar_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varchar(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cstring_to_text(s: *const ::std::os::raw::c_char) -> *mut text;
}
extern "C" {
    pub fn cstring_to_text_with_len(s: *const ::std::os::raw::c_char,
                                    len: ::std::os::raw::c_int) -> *mut text;
}
extern "C" {
    pub fn text_to_cstring(t: *const text) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text_to_cstring_buffer(src: *const text,
                                  dst: *mut ::std::os::raw::c_char,
                                  dst_len: usize);
}
extern "C" {
    pub fn textin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textcat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texteq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_pattern_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttext_pattern_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bttext_pattern_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textoctetlen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textpos(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_substr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_substr_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textoverlay(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textoverlay_no_len(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn name_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn varstr_cmp(arg1: *mut ::std::os::raw::c_char,
                      len1: ::std::os::raw::c_int,
                      arg2: *mut ::std::os::raw::c_char,
                      len2: ::std::os::raw::c_int, collid: Oid)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn varstr_sortsupport(ssup: SortSupport, collid: Oid, bpchar: bool_);
}
extern "C" {
    pub fn varstr_levenshtein(source: *const ::std::os::raw::c_char,
                              slen: ::std::os::raw::c_int,
                              target: *const ::std::os::raw::c_char,
                              tlen: ::std::os::raw::c_int,
                              ins_c: ::std::os::raw::c_int,
                              del_c: ::std::os::raw::c_int,
                              sub_c: ::std::os::raw::c_int, trusted: bool_)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn varstr_levenshtein_less_equal(source:
                                             *const ::std::os::raw::c_char,
                                         slen: ::std::os::raw::c_int,
                                         target:
                                             *const ::std::os::raw::c_char,
                                         tlen: ::std::os::raw::c_int,
                                         ins_c: ::std::os::raw::c_int,
                                         del_c: ::std::os::raw::c_int,
                                         sub_c: ::std::os::raw::c_int,
                                         max_d: ::std::os::raw::c_int,
                                         trusted: bool_)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn textToQualifiedNameList(textval: *mut text) -> *mut List;
}
extern "C" {
    pub fn SplitIdentifierString(rawstring: *mut ::std::os::raw::c_char,
                                 separator: ::std::os::raw::c_char,
                                 namelist: *mut *mut List) -> bool_;
}
extern "C" {
    pub fn SplitDirectoriesString(rawstring: *mut ::std::os::raw::c_char,
                                  separator: ::std::os::raw::c_char,
                                  namelist: *mut *mut List) -> bool_;
}
extern "C" {
    pub fn replace_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn replace_text_regexp(src_text: *mut text,
                               regexp: *mut ::std::os::raw::c_void,
                               replace_text: *mut text, glob: bool_)
     -> *mut text;
}
extern "C" {
    pub fn split_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_to_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_to_array_null(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_text_null(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_hex32(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_hex64(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn md5_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn md5_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unknownsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_column_size(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytea_string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytea_string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn string_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn string_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_concat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_concat_ws(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_left(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_right(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_reverse(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_format(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn text_format_nv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pgsql_version(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidneq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xid_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn mxid_age(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn xidComparator(arg1: *const ::std::os::raw::c_void,
                         arg2: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cidin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidrecv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidsend(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cideq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namelike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn namenlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameiclike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn nameicnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn textnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn texticnlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn bytealike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteanlike(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn like_escape(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn like_escape_bytea(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lower(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn upper(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn initcap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn lpad(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn rpad(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn btrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn byteatrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ltrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ltrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn rtrim(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn rtrim1(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn translate(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn chr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn repeat(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ascii(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_cidr_ntop(af: ::std::os::raw::c_int,
                          src: *const ::std::os::raw::c_void,
                          bits: ::std::os::raw::c_int,
                          dst: *mut ::std::os::raw::c_char, size: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn inet_net_pton(af: ::std::os::raw::c_int,
                         src: *const ::std::os::raw::c_char,
                         dst: *mut ::std::os::raw::c_void, size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn inet_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashinet(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_subeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_sup(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_supeq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_overlap(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_network(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_netmask(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_hostmask(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_family(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_broadcast(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_host(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_show(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_abbrev(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_abbrev(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn convert_network_to_scalar(value: Datum, typid: Oid) -> f64;
}
extern "C" {
    pub fn inet_to_cidr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn cidr_set_masklen(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn network_scan_first(in_: Datum) -> Datum;
}
extern "C" {
    pub fn network_scan_last(in_: Datum) -> Datum;
}
extern "C" {
    pub fn inet_client_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_client_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_server_addr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_server_port(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetnot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetand(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetpl(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetmi_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inetmi(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn clean_ipv6_addr(addr_family: ::std::os::raw::c_int,
                           addr: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn inet_same_family(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn inet_merge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_not(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_and(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_or(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn macaddr_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hashmacaddr(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numerictypmodin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numerictypmodout(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_transform(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_abs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_uminus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_uplus(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sign(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_round(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ceil(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_floor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_add(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sub(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_mul(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_div(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_div_trunc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_mod(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_inc(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_smaller(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_larger(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_fac(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sqrt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_exp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_ln(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_log(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_power(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_scale(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_int2(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float8_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_float8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_float8_no_overflow(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn float4_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_float4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_serialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_deserialize(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_var_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_var_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_stddev_pop(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn numeric_poly_stddev_samp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_avg_accum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_avg_combine(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int4_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg_accum_inv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int8_avg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn int2int4_sum(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn width_bucket_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn hash_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn generate_series_step_numeric(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_check_ins(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_check_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_noaction_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_noaction_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_cascade_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_cascade_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_restrict_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_restrict_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setnull_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setnull_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setdefault_del(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn RI_FKey_setdefault_upd(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn suppress_redundant_updates_trigger(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn getdatabaseencoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn database_character_set(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_client_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn PG_encoding_to_char(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn PG_char_to_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn PG_character_set_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn PG_character_set_id(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_convert(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_convert_to(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_convert_from(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn length_in_encoding(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_encoding_max_length_sql(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn format_type(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn format_type_be(type_oid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_type_be_qualified(type_oid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_type_with_typemod(type_oid: Oid, typemod: int32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn format_type_with_typemod_qualified(type_oid: Oid, typemod: int32)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn oidvectortypes(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn type_maximum_size(type_oid: Oid, typemod: int32) -> int32;
}
extern "C" {
    pub fn quote_ident(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn quote_literal(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn quote_literal_cstr(rawstr: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn quote_nullable(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_config_by_name_missing_ok(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn set_config_by_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_all_settings(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn show_all_file_settings(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_checkpoint(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_system(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_init(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_control_recovery(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_security_active(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_security_active_name(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_lock_status(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_blocking_pids(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_shared_int8(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_shared_int8(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_lock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_try_advisory_xact_lock_shared_int4(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_shared_int4(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_advisory_unlock_all(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_current(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_current_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_xmin(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_xmax(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_snapshot_xip(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn txid_visible_in_snapshot(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_lt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_le(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_eq(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_ge(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_gt(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_ne(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_cmp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_sortsupport(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn uuid_hash(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_row_number(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_dense_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_percent_rank(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_cume_dist(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_ntile(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lag(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lag_with_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lag_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn window_lead(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lead_with_offset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_lead_with_offset_and_default(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn window_first_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_last_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn window_nth_value(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_quad_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_kd_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_config(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_choose(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_picksplit(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_inner_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn spg_text_leaf_consistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginarrayextract(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginarrayextract_2args(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginqueryarrayextract(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginarrayconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn ginarraytriconsistent(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_bernoulli_handler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn tsm_system_handler(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_prepared_xact(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_multixact_members(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_xact_commit_timestamp(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_last_committed_xact(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_describe_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_identify_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_identify_object_as_address(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_get_object_address(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn unique_key_recheck(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_dropped_objects(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_table_rewrite_oid(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_table_rewrite_reason(fcinfo: FunctionCallInfo)
     -> Datum;
}
extern "C" {
    pub fn pg_event_trigger_ddl_commands(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_available_extensions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_available_extension_versions(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_extension_update_paths(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_extension_config_dump(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_prepared_statement(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn pg_cursor(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_in(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_out(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_recv(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_send(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn array_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn row_to_json_pretty(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn to_json(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_agg_finalfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_agg_transfn(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_object_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_array(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_build_array_noargs(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_two_arg(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn escape_json(buf: StringInfo, str: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn json_typeof(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_field(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_element(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_extract_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_object_keys(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_each(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_each_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_elements(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_populate_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_to_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn json_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_field(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_field_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_element(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_element_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_extract_path(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_extract_path_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_object_keys(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_length(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_each(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_each_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_elements_text(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_array_elements(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_populate_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_populate_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_to_record(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_to_recordset(fcinfo: FunctionCallInfo) -> Datum;
}
extern "C" {
    pub fn jsonb_strip_nulls(fcinfo: FunctionCallInfo) -> Datum;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OpBtreeInterpretation {
    pub opfamily_id: Oid,
    pub strategy: ::std::os::raw::c_int,
    pub oplefttype: Oid,
    pub oprighttype: Oid,
}
#[test]
fn bindgen_test_layout_OpBtreeInterpretation() {
    assert_eq!(::std::mem::size_of::<OpBtreeInterpretation>() , 16usize);
    assert_eq!(::std::mem::align_of::<OpBtreeInterpretation>() , 4usize);
}
impl Clone for OpBtreeInterpretation {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IOFuncSelector {
    IOFunc_input = 0,
    IOFunc_output = 1,
    IOFunc_receive = 2,
    IOFunc_send = 3,
}
pub type get_attavgwidth_hook_type =
    ::std::option::Option<unsafe extern "C" fn(relid: Oid, attnum: AttrNumber)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "get_attavgwidth_hook"]
    pub static mut get_attavgwidth_hook: get_attavgwidth_hook_type;
}
extern "C" {
    pub fn op_in_opfamily(opno: Oid, opfamily: Oid) -> bool_;
}
extern "C" {
    pub fn get_op_opfamily_strategy(opno: Oid, opfamily: Oid)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_op_opfamily_sortfamily(opno: Oid, opfamily: Oid) -> Oid;
}
extern "C" {
    pub fn get_op_opfamily_properties(opno: Oid, opfamily: Oid,
                                      ordering_op: bool_,
                                      strategy: *mut ::std::os::raw::c_int,
                                      lefttype: *mut Oid,
                                      righttype: *mut Oid);
}
extern "C" {
    pub fn get_opfamily_member(opfamily: Oid, lefttype: Oid, righttype: Oid,
                               strategy: int16) -> Oid;
}
extern "C" {
    pub fn get_ordering_op_properties(opno: Oid, opfamily: *mut Oid,
                                      opcintype: *mut Oid,
                                      strategy: *mut int16) -> bool_;
}
extern "C" {
    pub fn get_equality_op_for_ordering_op(opno: Oid, reverse: *mut bool_)
     -> Oid;
}
extern "C" {
    pub fn get_ordering_op_for_equality_op(opno: Oid, use_lhs_type: bool_)
     -> Oid;
}
extern "C" {
    pub fn get_mergejoin_opfamilies(opno: Oid) -> *mut List;
}
extern "C" {
    pub fn get_compatible_hash_operators(opno: Oid, lhs_opno: *mut Oid,
                                         rhs_opno: *mut Oid) -> bool_;
}
extern "C" {
    pub fn get_op_hash_functions(opno: Oid, lhs_procno: *mut RegProcedure,
                                 rhs_procno: *mut RegProcedure) -> bool_;
}
extern "C" {
    pub fn get_op_btree_interpretation(opno: Oid) -> *mut List;
}
extern "C" {
    pub fn equality_ops_are_compatible(opno1: Oid, opno2: Oid) -> bool_;
}
extern "C" {
    pub fn get_opfamily_proc(opfamily: Oid, lefttype: Oid, righttype: Oid,
                             procnum: int16) -> Oid;
}
extern "C" {
    pub fn get_attname(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_relid_attribute_name(relid: Oid, attnum: AttrNumber)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_attnum(relid: Oid, attname: *const ::std::os::raw::c_char)
     -> AttrNumber;
}
extern "C" {
    pub fn get_atttype(relid: Oid, attnum: AttrNumber) -> Oid;
}
extern "C" {
    pub fn get_atttypmod(relid: Oid, attnum: AttrNumber) -> int32;
}
extern "C" {
    pub fn get_atttypetypmodcoll(relid: Oid, attnum: AttrNumber,
                                 typid: *mut Oid, typmod: *mut int32,
                                 collid: *mut Oid);
}
extern "C" {
    pub fn get_collation_name(colloid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_constraint_name(conoid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_language_name(langoid: Oid, missing_ok: bool_)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_opclass_family(opclass: Oid) -> Oid;
}
extern "C" {
    pub fn get_opclass_input_type(opclass: Oid) -> Oid;
}
extern "C" {
    pub fn get_opcode(opno: Oid) -> RegProcedure;
}
extern "C" {
    pub fn get_opname(opno: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_op_rettype(opno: Oid) -> Oid;
}
extern "C" {
    pub fn op_input_types(opno: Oid, lefttype: *mut Oid, righttype: *mut Oid);
}
extern "C" {
    pub fn op_mergejoinable(opno: Oid, inputtype: Oid) -> bool_;
}
extern "C" {
    pub fn op_hashjoinable(opno: Oid, inputtype: Oid) -> bool_;
}
extern "C" {
    pub fn op_strict(opno: Oid) -> bool_;
}
extern "C" {
    pub fn op_volatile(opno: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_commutator(opno: Oid) -> Oid;
}
extern "C" {
    pub fn get_negator(opno: Oid) -> Oid;
}
extern "C" {
    pub fn get_oprrest(opno: Oid) -> RegProcedure;
}
extern "C" {
    pub fn get_oprjoin(opno: Oid) -> RegProcedure;
}
extern "C" {
    pub fn get_func_name(funcid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_func_namespace(funcid: Oid) -> Oid;
}
extern "C" {
    pub fn get_func_rettype(funcid: Oid) -> Oid;
}
extern "C" {
    pub fn get_func_nargs(funcid: Oid) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_func_signature(funcid: Oid, argtypes: *mut *mut Oid,
                              nargs: *mut ::std::os::raw::c_int) -> Oid;
}
extern "C" {
    pub fn get_func_variadictype(funcid: Oid) -> Oid;
}
extern "C" {
    pub fn get_func_retset(funcid: Oid) -> bool_;
}
extern "C" {
    pub fn func_strict(funcid: Oid) -> bool_;
}
extern "C" {
    pub fn func_volatile(funcid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn func_parallel(funcid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_func_leakproof(funcid: Oid) -> bool_;
}
extern "C" {
    pub fn get_func_cost(funcid: Oid) -> float4;
}
extern "C" {
    pub fn get_func_rows(funcid: Oid) -> float4;
}
extern "C" {
    pub fn get_relname_relid(relname: *const ::std::os::raw::c_char,
                             relnamespace: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_name(relid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_rel_namespace(relid: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_type_id(relid: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_relkind(relid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_rel_tablespace(relid: Oid) -> Oid;
}
extern "C" {
    pub fn get_rel_persistence(relid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_transform_fromsql(typid: Oid, langid: Oid, trftypes: *mut List)
     -> Oid;
}
extern "C" {
    pub fn get_transform_tosql(typid: Oid, langid: Oid, trftypes: *mut List)
     -> Oid;
}
extern "C" {
    pub fn get_typisdefined(typid: Oid) -> bool_;
}
extern "C" {
    pub fn get_typlen(typid: Oid) -> int16;
}
extern "C" {
    pub fn get_typbyval(typid: Oid) -> bool_;
}
extern "C" {
    pub fn get_typlenbyval(typid: Oid, typlen: *mut int16,
                           typbyval: *mut bool_);
}
extern "C" {
    pub fn get_typlenbyvalalign(typid: Oid, typlen: *mut int16,
                                typbyval: *mut bool_,
                                typalign: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn getTypeIOParam(typeTuple: HeapTuple) -> Oid;
}
extern "C" {
    pub fn get_type_io_data(typid: Oid, which_func: IOFuncSelector,
                            typlen: *mut int16, typbyval: *mut bool_,
                            typalign: *mut ::std::os::raw::c_char,
                            typdelim: *mut ::std::os::raw::c_char,
                            typioparam: *mut Oid, func: *mut Oid);
}
extern "C" {
    pub fn get_typstorage(typid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_typdefault(typid: Oid) -> *mut Node;
}
extern "C" {
    pub fn get_typtype(typid: Oid) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn type_is_rowtype(typid: Oid) -> bool_;
}
extern "C" {
    pub fn type_is_enum(typid: Oid) -> bool_;
}
extern "C" {
    pub fn type_is_range(typid: Oid) -> bool_;
}
extern "C" {
    pub fn get_type_category_preferred(typid: Oid,
                                       typcategory:
                                           *mut ::std::os::raw::c_char,
                                       typispreferred: *mut bool_);
}
extern "C" {
    pub fn get_typ_typrelid(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_element_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_array_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_promoted_array_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_base_element_type(typid: Oid) -> Oid;
}
extern "C" {
    pub fn getTypeInputInfo(type_: Oid, typInput: *mut Oid,
                            typIOParam: *mut Oid);
}
extern "C" {
    pub fn getTypeOutputInfo(type_: Oid, typOutput: *mut Oid,
                             typIsVarlena: *mut bool_);
}
extern "C" {
    pub fn getTypeBinaryInputInfo(type_: Oid, typReceive: *mut Oid,
                                  typIOParam: *mut Oid);
}
extern "C" {
    pub fn getTypeBinaryOutputInfo(type_: Oid, typSend: *mut Oid,
                                   typIsVarlena: *mut bool_);
}
extern "C" {
    pub fn get_typmodin(typid: Oid) -> Oid;
}
extern "C" {
    pub fn get_typcollation(typid: Oid) -> Oid;
}
extern "C" {
    pub fn type_is_collatable(typid: Oid) -> bool_;
}
extern "C" {
    pub fn getBaseType(typid: Oid) -> Oid;
}
extern "C" {
    pub fn getBaseTypeAndTypmod(typid: Oid, typmod: *mut int32) -> Oid;
}
extern "C" {
    pub fn get_typavgwidth(typid: Oid, typmod: int32) -> int32;
}
extern "C" {
    pub fn get_attavgwidth(relid: Oid, attnum: AttrNumber) -> int32;
}
extern "C" {
    pub fn get_attstatsslot(statstuple: HeapTuple, atttype: Oid,
                            atttypmod: int32, reqkind: ::std::os::raw::c_int,
                            reqop: Oid, actualop: *mut Oid,
                            values: *mut *mut Datum,
                            nvalues: *mut ::std::os::raw::c_int,
                            numbers: *mut *mut float4,
                            nnumbers: *mut ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn free_attstatsslot(atttype: Oid, values: *mut Datum,
                             nvalues: ::std::os::raw::c_int,
                             numbers: *mut float4,
                             nnumbers: ::std::os::raw::c_int);
}
extern "C" {
    pub fn get_namespace_name(nspid: Oid) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_namespace_name_or_temp(nspid: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_range_subtype(rangeOid: Oid) -> Oid;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DomainConstraintCache([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TypeCacheEnumData([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TypeCacheEntry {
    pub type_id: Oid,
    pub typlen: int16,
    pub typbyval: bool_,
    pub typalign: ::std::os::raw::c_char,
    pub typstorage: ::std::os::raw::c_char,
    pub typtype: ::std::os::raw::c_char,
    pub typrelid: Oid,
    pub btree_opf: Oid,
    pub btree_opintype: Oid,
    pub hash_opf: Oid,
    pub hash_opintype: Oid,
    pub eq_opr: Oid,
    pub lt_opr: Oid,
    pub gt_opr: Oid,
    pub cmp_proc: Oid,
    pub hash_proc: Oid,
    pub eq_opr_finfo: FmgrInfo,
    pub cmp_proc_finfo: FmgrInfo,
    pub hash_proc_finfo: FmgrInfo,
    pub tupDesc: TupleDesc,
    pub rngelemtype: *mut TypeCacheEntry,
    pub rng_collation: Oid,
    pub rng_cmp_proc_finfo: FmgrInfo,
    pub rng_canonical_finfo: FmgrInfo,
    pub rng_subdiff_finfo: FmgrInfo,
    pub domainData: *mut DomainConstraintCache,
    pub flags: ::std::os::raw::c_int,
    pub enumData: *mut TypeCacheEnumData,
    pub nextDomain: *mut TypeCacheEntry,
}
#[test]
fn bindgen_test_layout_TypeCacheEntry() {
    assert_eq!(::std::mem::size_of::<TypeCacheEntry>() , 400usize);
    assert_eq!(::std::mem::align_of::<TypeCacheEntry>() , 8usize);
}
impl Clone for TypeCacheEntry {
    fn clone(&self) -> Self { *self }
}
pub type DomainConstraintRef = CoerceToDomainState_DomainConstraintRef;
extern "C" {
    pub fn lookup_type_cache(type_id: Oid, flags: ::std::os::raw::c_int)
     -> *mut TypeCacheEntry;
}
extern "C" {
    pub fn InitDomainConstraintRef(type_id: Oid,
                                   ref_: *mut DomainConstraintRef,
                                   refctx: MemoryContext);
}
extern "C" {
    pub fn UpdateDomainConstraintRef(ref_: *mut DomainConstraintRef);
}
extern "C" {
    pub fn DomainHasConstraints(type_id: Oid) -> bool_;
}
extern "C" {
    pub fn lookup_rowtype_tupdesc(type_id: Oid, typmod: int32) -> TupleDesc;
}
extern "C" {
    pub fn lookup_rowtype_tupdesc_noerror(type_id: Oid, typmod: int32,
                                          noError: bool_) -> TupleDesc;
}
extern "C" {
    pub fn lookup_rowtype_tupdesc_copy(type_id: Oid, typmod: int32)
     -> TupleDesc;
}
extern "C" {
    pub fn assign_record_type_typmod(tupDesc: TupleDesc);
}
extern "C" {
    pub fn compare_values_of_enum(tcache: *mut TypeCacheEntry, arg1: Oid,
                                  arg2: Oid) -> ::std::os::raw::c_int;
}
pub type RmgrId = uint8;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RmgrIds {
    RM_XLOG_ID = 0,
    RM_XACT_ID = 1,
    RM_SMGR_ID = 2,
    RM_CLOG_ID = 3,
    RM_DBASE_ID = 4,
    RM_TBLSPC_ID = 5,
    RM_MULTIXACT_ID = 6,
    RM_RELMAP_ID = 7,
    RM_STANDBY_ID = 8,
    RM_HEAP2_ID = 9,
    RM_HEAP_ID = 10,
    RM_BTREE_ID = 11,
    RM_HASH_ID = 12,
    RM_GIN_ID = 13,
    RM_GIST_ID = 14,
    RM_SEQ_ID = 15,
    RM_SPGIST_ID = 16,
    RM_BRIN_ID = 17,
    RM_COMMIT_TS_ID = 18,
    RM_REPLORIGIN_ID = 19,
    RM_GENERIC_ID = 20,
    RM_LOGICALMSG_ID = 21,
    RM_NEXT_ID = 22,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ForkNumber {
    InvalidForkNumber = -1,
    MAIN_FORKNUM = 0,
    FSM_FORKNUM = 1,
    VISIBILITYMAP_FORKNUM = 2,
    INIT_FORKNUM = 3,
}
extern "C" {
    #[link_name = "forkNames"]
    pub static mut forkNames: *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn forkname_to_number(forkName: *const ::std::os::raw::c_char)
     -> ForkNumber;
}
extern "C" {
    pub fn forkname_chars(str: *const ::std::os::raw::c_char,
                          fork: *mut ForkNumber) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetDatabasePath(dbNode: Oid, spcNode: Oid)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn GetRelationPath(dbNode: Oid, spcNode: Oid, relNode: Oid,
                           backendId: ::std::os::raw::c_int,
                           forkNumber: ForkNumber)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RelFileNode {
    pub spcNode: Oid,
    pub dbNode: Oid,
    pub relNode: Oid,
}
#[test]
fn bindgen_test_layout_RelFileNode() {
    assert_eq!(::std::mem::size_of::<RelFileNode>() , 12usize);
    assert_eq!(::std::mem::align_of::<RelFileNode>() , 4usize);
}
impl Clone for RelFileNode {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RelFileNodeBackend {
    pub node: RelFileNode,
    pub backend: BackendId,
}
#[test]
fn bindgen_test_layout_RelFileNodeBackend() {
    assert_eq!(::std::mem::size_of::<RelFileNodeBackend>() , 16usize);
    assert_eq!(::std::mem::align_of::<RelFileNodeBackend>() , 4usize);
}
impl Clone for RelFileNodeBackend {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn XLogBeginInsert();
}
extern "C" {
    pub fn XLogIncludeOrigin();
}
extern "C" {
    pub fn XLogInsert(rmid: RmgrId, info: uint8) -> XLogRecPtr;
}
extern "C" {
    pub fn XLogEnsureRecordSpace(nbuffers: ::std::os::raw::c_int,
                                 ndatas: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XLogRegisterData(data: *mut ::std::os::raw::c_char,
                            len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XLogRegisterBuffer(block_id: uint8, buffer: Buffer, flags: uint8);
}
extern "C" {
    pub fn XLogRegisterBlock(block_id: uint8, rnode: *mut RelFileNode,
                             forknum: ForkNumber, blknum: BlockNumber,
                             page: *mut ::std::os::raw::c_char, flags: uint8);
}
extern "C" {
    pub fn XLogRegisterBufData(block_id: uint8,
                               data: *mut ::std::os::raw::c_char,
                               len: ::std::os::raw::c_int);
}
extern "C" {
    pub fn XLogResetInsertion();
}
extern "C" {
    pub fn XLogCheckBufferNeedsBackup(buffer: Buffer) -> bool_;
}
extern "C" {
    pub fn log_newpage(rnode: *mut RelFileNode, forkNum: ForkNumber,
                       blk: BlockNumber, page: *mut ::std::os::raw::c_char,
                       page_std: bool_) -> XLogRecPtr;
}
extern "C" {
    pub fn log_newpage_buffer(buffer: Buffer, page_std: bool_) -> XLogRecPtr;
}
extern "C" {
    pub fn XLogSaveBufferForHint(buffer: Buffer, buffer_std: bool_)
     -> XLogRecPtr;
}
extern "C" {
    pub fn InitXLogInsert();
}
pub type pg_crc32c = uint32;
extern "C" {
    pub fn pg_comp_crc32c_sse42(crc: pg_crc32c,
                                data: *const ::std::os::raw::c_void,
                                len: usize) -> pg_crc32c;
}
extern "C" {
    pub fn pg_comp_crc32c_sb8(crc: pg_crc32c,
                              data: *const ::std::os::raw::c_void, len: usize)
     -> pg_crc32c;
}
extern "C" {
    #[link_name = "pg_comp_crc32c"]
    pub static mut pg_comp_crc32c:
               ::std::option::Option<unsafe extern "C" fn(crc: pg_crc32c,
                                                          data:
                                                              *const ::std::os::raw::c_void,
                                                          len: usize)
                                         -> ::std::os::raw::c_uint>;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XLogRecord {
    pub xl_tot_len: uint32,
    pub xl_xid: TransactionId,
    pub xl_prev: XLogRecPtr,
    pub xl_info: uint8,
    pub xl_rmid: RmgrId,
    pub xl_crc: pg_crc32c,
}
#[test]
fn bindgen_test_layout_XLogRecord() {
    assert_eq!(::std::mem::size_of::<XLogRecord>() , 24usize);
    assert_eq!(::std::mem::align_of::<XLogRecord>() , 8usize);
}
impl Clone for XLogRecord {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XLogRecordBlockHeader {
    pub id: uint8,
    pub fork_flags: uint8,
    pub data_length: uint16,
}
#[test]
fn bindgen_test_layout_XLogRecordBlockHeader() {
    assert_eq!(::std::mem::size_of::<XLogRecordBlockHeader>() , 4usize);
    assert_eq!(::std::mem::align_of::<XLogRecordBlockHeader>() , 2usize);
}
impl Clone for XLogRecordBlockHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XLogRecordBlockImageHeader {
    pub length: uint16,
    pub hole_offset: uint16,
    pub bimg_info: uint8,
}
#[test]
fn bindgen_test_layout_XLogRecordBlockImageHeader() {
    assert_eq!(::std::mem::size_of::<XLogRecordBlockImageHeader>() , 6usize);
    assert_eq!(::std::mem::align_of::<XLogRecordBlockImageHeader>() , 2usize);
}
impl Clone for XLogRecordBlockImageHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XLogRecordBlockCompressHeader {
    pub hole_length: uint16,
}
#[test]
fn bindgen_test_layout_XLogRecordBlockCompressHeader() {
    assert_eq!(::std::mem::size_of::<XLogRecordBlockCompressHeader>() ,
               2usize);
    assert_eq!(::std::mem::align_of::<XLogRecordBlockCompressHeader>() ,
               2usize);
}
impl Clone for XLogRecordBlockCompressHeader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XLogRecordDataHeaderShort {
    pub id: uint8,
    pub data_length: uint8,
}
#[test]
fn bindgen_test_layout_XLogRecordDataHeaderShort() {
    assert_eq!(::std::mem::size_of::<XLogRecordDataHeaderShort>() , 2usize);
    assert_eq!(::std::mem::align_of::<XLogRecordDataHeaderShort>() , 1usize);
}
impl Clone for XLogRecordDataHeaderShort {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct XLogRecordDataHeaderLong {
    pub id: uint8,
}
#[test]
fn bindgen_test_layout_XLogRecordDataHeaderLong() {
    assert_eq!(::std::mem::size_of::<XLogRecordDataHeaderLong>() , 1usize);
    assert_eq!(::std::mem::align_of::<XLogRecordDataHeaderLong>() , 1usize);
}
impl Clone for XLogRecordDataHeaderLong {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct XLogReaderState {
    pub read_page: XLogPageReadCB,
    pub system_identifier: uint64,
    pub private_data: *mut ::std::os::raw::c_void,
    pub ReadRecPtr: XLogRecPtr,
    pub EndRecPtr: XLogRecPtr,
    pub decoded_record: *mut XLogRecord,
    pub main_data: *mut ::std::os::raw::c_char,
    pub main_data_len: uint32,
    pub main_data_bufsz: uint32,
    pub record_origin: RepOriginId,
    pub blocks: [DecodedBkpBlock; 33usize],
    pub max_block_id: ::std::os::raw::c_int,
    pub readBuf: *mut ::std::os::raw::c_char,
    pub readLen: uint32,
    pub readSegNo: XLogSegNo,
    pub readOff: uint32,
    pub readPageTLI: TimeLineID,
    pub latestPagePtr: XLogRecPtr,
    pub latestPageTLI: TimeLineID,
    pub currRecPtr: XLogRecPtr,
    pub readRecordBuf: *mut ::std::os::raw::c_char,
    pub readRecordBufSize: uint32,
    pub errormsg_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_XLogReaderState() {
    assert_eq!(::std::mem::size_of::<XLogReaderState>() , 2272usize);
    assert_eq!(::std::mem::align_of::<XLogReaderState>() , 8usize);
}
pub type XLogPageReadCB =
    ::std::option::Option<unsafe extern "C" fn(xlogreader:
                                                   *mut XLogReaderState,
                                               targetPagePtr: XLogRecPtr,
                                               reqLen: ::std::os::raw::c_int,
                                               targetRecPtr: XLogRecPtr,
                                               readBuf:
                                                   *mut ::std::os::raw::c_char,
                                               pageTLI: *mut TimeLineID)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_78 {
    pub in_use: bool_,
    pub rnode: RelFileNode,
    pub forknum: ForkNumber,
    pub blkno: BlockNumber,
    pub flags: uint8,
    pub has_image: bool_,
    pub bkp_image: *mut ::std::os::raw::c_char,
    pub hole_offset: uint16,
    pub hole_length: uint16,
    pub bimg_len: uint16,
    pub bimg_info: uint8,
    pub has_data: bool_,
    pub data: *mut ::std::os::raw::c_char,
    pub data_len: uint16,
    pub data_bufsz: uint16,
}
#[test]
fn bindgen_test_layout__bindgen_ty_78() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_78>() , 64usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_78>() , 8usize);
}
impl Clone for _bindgen_ty_78 {
    fn clone(&self) -> Self { *self }
}
pub type DecodedBkpBlock = _bindgen_ty_78;
extern "C" {
    pub fn XLogReaderAllocate(pagereadfunc: XLogPageReadCB,
                              private_data: *mut ::std::os::raw::c_void)
     -> *mut XLogReaderState;
}
extern "C" {
    pub fn XLogReaderFree(state: *mut XLogReaderState);
}
extern "C" {
    pub fn XLogReadRecord(state: *mut XLogReaderState, recptr: XLogRecPtr,
                          errormsg: *mut *mut ::std::os::raw::c_char)
     -> *mut XLogRecord;
}
extern "C" {
    pub fn XLogReaderInvalReadState(state: *mut XLogReaderState);
}
extern "C" {
    pub fn DecodeXLogRecord(state: *mut XLogReaderState,
                            record: *mut XLogRecord,
                            errmsg: *mut *mut ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn RestoreBlockImage(recoder: *mut XLogReaderState, block_id: uint8,
                             dst: *mut ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn XLogRecGetBlockData(record: *mut XLogReaderState, block_id: uint8,
                               len: *mut Size) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn XLogRecGetBlockTag(record: *mut XLogReaderState, block_id: uint8,
                              rnode: *mut RelFileNode,
                              forknum: *mut ForkNumber,
                              blknum: *mut BlockNumber) -> bool_;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int)
     -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isinfl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isnanl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int)
     -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "signgam"]
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_79 = _bindgen_ty_79::FP_NAN;
pub const FP_INFINITE: _bindgen_ty_79 = _bindgen_ty_79::FP_INFINITE;
pub const FP_ZERO: _bindgen_ty_79 = _bindgen_ty_79::FP_ZERO;
pub const FP_SUBNORMAL: _bindgen_ty_79 = _bindgen_ty_79::FP_SUBNORMAL;
pub const FP_NORMAL: _bindgen_ty_79 = _bindgen_ty_79::FP_NORMAL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_79 {
    FP_NAN = 0,
    FP_INFINITE = 1,
    FP_ZERO = 2,
    FP_SUBNORMAL = 3,
    FP_NORMAL = 4,
}
pub const _IEEE_: _bindgen_ty_80 = _bindgen_ty_80::_IEEE_;
pub const _SVID_: _bindgen_ty_80 = _bindgen_ty_80::_SVID_;
pub const _XOPEN_: _bindgen_ty_80 = _bindgen_ty_80::_XOPEN_;
pub const _POSIX_: _bindgen_ty_80 = _bindgen_ty_80::_POSIX_;
pub const _ISOC_: _bindgen_ty_80 = _bindgen_ty_80::_ISOC_;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_80 {
    _IEEE_ = -1,
    _SVID_ = 0,
    _XOPEN_ = 1,
    _POSIX_ = 2,
    _ISOC_ = 3,
}
pub use self::_bindgen_ty_80 as _LIB_VERSION_TYPE;
extern "C" {
    #[link_name = "_LIB_VERSION"]
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(::std::mem::size_of::<exception>() , 40usize);
    assert_eq!(::std::mem::align_of::<exception>() , 8usize);
}
impl Clone for exception {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn matherr(__exc: *mut exception) -> ::std::os::raw::c_int;
}
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_81 {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[test]
fn bindgen_test_layout__bindgen_ty_81() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_81>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_81>() , 8usize);
}
impl Clone for _bindgen_ty_81 {
    fn clone(&self) -> Self { *self }
}
pub type Interval = _bindgen_ty_81;
#[repr(C)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(::std::mem::size_of::<dirent>() , 280usize);
    assert_eq!(::std::mem::align_of::<dirent>() , 8usize);
}
pub const DT_UNKNOWN: _bindgen_ty_82 = _bindgen_ty_82::DT_UNKNOWN;
pub const DT_FIFO: _bindgen_ty_82 = _bindgen_ty_82::DT_FIFO;
pub const DT_CHR: _bindgen_ty_82 = _bindgen_ty_82::DT_CHR;
pub const DT_DIR: _bindgen_ty_82 = _bindgen_ty_82::DT_DIR;
pub const DT_BLK: _bindgen_ty_82 = _bindgen_ty_82::DT_BLK;
pub const DT_REG: _bindgen_ty_82 = _bindgen_ty_82::DT_REG;
pub const DT_LNK: _bindgen_ty_82 = _bindgen_ty_82::DT_LNK;
pub const DT_SOCK: _bindgen_ty_82 = _bindgen_ty_82::DT_SOCK;
pub const DT_WHT: _bindgen_ty_82 = _bindgen_ty_82::DT_WHT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_82 {
    DT_UNKNOWN = 0,
    DT_FIFO = 1,
    DT_CHR = 2,
    DT_DIR = 4,
    DT_BLK = 6,
    DT_REG = 8,
    DT_LNK = 10,
    DT_SOCK = 12,
    DT_WHT = 14,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream([u8; 0]);
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(__dirp: *mut DIR, __entry: *mut dirent,
                     __result: *mut *mut dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(__dir: *const ::std::os::raw::c_char,
                   __namelist: *mut *mut *mut dirent,
                   __selector:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const dirent)
                                                 -> ::std::os::raw::c_int>,
                   __cmp:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut *const dirent,
                                                                  arg2:
                                                                      *mut *const dirent)
                                                 -> ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(__fd: ::std::os::raw::c_int,
                         __buf: *mut ::std::os::raw::c_char, __nbytes: usize,
                         __basep: *mut __off_t) -> __ssize_t;
}
pub type FileName = *mut ::std::os::raw::c_char;
pub type File = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "max_files_per_process"]
    pub static mut max_files_per_process: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_safe_fds"]
    pub static mut max_safe_fds: ::std::os::raw::c_int;
}
extern "C" {
    pub fn PathNameOpenFile(fileName: FileName,
                            fileFlags: ::std::os::raw::c_int,
                            fileMode: ::std::os::raw::c_int) -> File;
}
extern "C" {
    pub fn OpenTemporaryFile(interXact: bool_) -> File;
}
extern "C" {
    pub fn FileClose(file: File);
}
extern "C" {
    pub fn FilePrefetch(file: File, offset: off_t,
                        amount: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileRead(file: File, buffer: *mut ::std::os::raw::c_char,
                    amount: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileWrite(file: File, buffer: *mut ::std::os::raw::c_char,
                     amount: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileSync(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileSeek(file: File, offset: off_t, whence: ::std::os::raw::c_int)
     -> off_t;
}
extern "C" {
    pub fn FileTruncate(file: File, offset: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileWriteback(file: File, offset: off_t, nbytes: off_t);
}
extern "C" {
    pub fn FilePathName(file: File) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn FileGetRawDesc(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileGetRawFlags(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FileGetRawMode(file: File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AllocateFile(name: *const ::std::os::raw::c_char,
                        mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn FreeFile(file: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OpenPipeStream(command: *const ::std::os::raw::c_char,
                          mode: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn ClosePipeStream(file: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn AllocateDir(dirname: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn ReadDir(dir: *mut DIR, dirname: *const ::std::os::raw::c_char)
     -> *mut dirent;
}
extern "C" {
    pub fn FreeDir(dir: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OpenTransientFile(fileName: FileName,
                             fileFlags: ::std::os::raw::c_int,
                             fileMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CloseTransientFile(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn BasicOpenFile(fileName: FileName, fileFlags: ::std::os::raw::c_int,
                         fileMode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn InitFileAccess();
}
extern "C" {
    pub fn set_max_safe_fds();
}
extern "C" {
    pub fn closeAllVfds();
}
extern "C" {
    pub fn SetTempTablespaces(tableSpaces: *mut Oid,
                              numSpaces: ::std::os::raw::c_int);
}
extern "C" {
    pub fn TempTablespacesAreSet() -> bool_;
}
extern "C" {
    pub fn GetNextTempTableSpace() -> Oid;
}
extern "C" {
    pub fn AtEOXact_Files();
}
extern "C" {
    pub fn AtEOSubXact_Files(isCommit: bool_, mySubid: SubTransactionId,
                             parentSubid: SubTransactionId);
}
extern "C" {
    pub fn RemovePgTempFiles();
}
extern "C" {
    pub fn pg_fsync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_fsync_no_writethrough(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_fsync_writethrough(fd: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_fdatasync(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_flush_data(fd: ::std::os::raw::c_int, offset: off_t,
                         amount: off_t);
}
extern "C" {
    pub fn fsync_fname(fname: *const ::std::os::raw::c_char, isdir: bool_);
}
extern "C" {
    pub fn durable_rename(oldfile: *const ::std::os::raw::c_char,
                          newfile: *const ::std::os::raw::c_char,
                          loglevel: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn durable_link_or_rename(oldfile: *const ::std::os::raw::c_char,
                                  newfile: *const ::std::os::raw::c_char,
                                  loglevel: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn SyncDataDirectory();
}
extern "C" {
    #[link_name = "sync_method"]
    pub static mut sync_method: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ThisTimeLineID"]
    pub static mut ThisTimeLineID: TimeLineID;
}
extern "C" {
    #[link_name = "InRecovery"]
    pub static mut InRecovery: bool_;
}
pub const STANDBY_DISABLED: _bindgen_ty_83 = _bindgen_ty_83::STANDBY_DISABLED;
pub const STANDBY_INITIALIZED: _bindgen_ty_83 =
    _bindgen_ty_83::STANDBY_INITIALIZED;
pub const STANDBY_SNAPSHOT_PENDING: _bindgen_ty_83 =
    _bindgen_ty_83::STANDBY_SNAPSHOT_PENDING;
pub const STANDBY_SNAPSHOT_READY: _bindgen_ty_83 =
    _bindgen_ty_83::STANDBY_SNAPSHOT_READY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_83 {
    STANDBY_DISABLED = 0,
    STANDBY_INITIALIZED = 1,
    STANDBY_SNAPSHOT_PENDING = 2,
    STANDBY_SNAPSHOT_READY = 3,
}
pub use self::_bindgen_ty_83 as HotStandbyState;
extern "C" {
    #[link_name = "standbyState"]
    pub static mut standbyState: HotStandbyState;
}
pub const RECOVERY_TARGET_UNSET: _bindgen_ty_84 =
    _bindgen_ty_84::RECOVERY_TARGET_UNSET;
pub const RECOVERY_TARGET_XID: _bindgen_ty_84 =
    _bindgen_ty_84::RECOVERY_TARGET_XID;
pub const RECOVERY_TARGET_TIME: _bindgen_ty_84 =
    _bindgen_ty_84::RECOVERY_TARGET_TIME;
pub const RECOVERY_TARGET_NAME: _bindgen_ty_84 =
    _bindgen_ty_84::RECOVERY_TARGET_NAME;
pub const RECOVERY_TARGET_IMMEDIATE: _bindgen_ty_84 =
    _bindgen_ty_84::RECOVERY_TARGET_IMMEDIATE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_84 {
    RECOVERY_TARGET_UNSET = 0,
    RECOVERY_TARGET_XID = 1,
    RECOVERY_TARGET_TIME = 2,
    RECOVERY_TARGET_NAME = 3,
    RECOVERY_TARGET_IMMEDIATE = 4,
}
pub use self::_bindgen_ty_84 as RecoveryTargetType;
extern "C" {
    #[link_name = "ProcLastRecPtr"]
    pub static mut ProcLastRecPtr: XLogRecPtr;
}
extern "C" {
    #[link_name = "XactLastRecEnd"]
    pub static mut XactLastRecEnd: XLogRecPtr;
}
extern "C" {
    #[link_name = "XactLastCommitEnd"]
    pub static mut XactLastCommitEnd: XLogRecPtr;
}
extern "C" {
    #[link_name = "reachedConsistency"]
    pub static mut reachedConsistency: bool_;
}
extern "C" {
    #[link_name = "min_wal_size"]
    pub static mut min_wal_size: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_wal_size"]
    pub static mut max_wal_size: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "wal_keep_segments"]
    pub static mut wal_keep_segments: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "XLOGbuffers"]
    pub static mut XLOGbuffers: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "XLogArchiveTimeout"]
    pub static mut XLogArchiveTimeout: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "wal_retrieve_retry_interval"]
    pub static mut wal_retrieve_retry_interval: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "XLogArchiveCommand"]
    pub static mut XLogArchiveCommand: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "EnableHotStandby"]
    pub static mut EnableHotStandby: bool_;
}
extern "C" {
    #[link_name = "fullPageWrites"]
    pub static mut fullPageWrites: bool_;
}
extern "C" {
    #[link_name = "wal_log_hints"]
    pub static mut wal_log_hints: bool_;
}
extern "C" {
    #[link_name = "wal_compression"]
    pub static mut wal_compression: bool_;
}
extern "C" {
    #[link_name = "log_checkpoints"]
    pub static mut log_checkpoints: bool_;
}
extern "C" {
    #[link_name = "CheckPointSegments"]
    pub static mut CheckPointSegments: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ArchiveMode {
    ARCHIVE_MODE_OFF = 0,
    ARCHIVE_MODE_ON = 1,
    ARCHIVE_MODE_ALWAYS = 2,
}
extern "C" {
    #[link_name = "XLogArchiveMode"]
    pub static mut XLogArchiveMode: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum WalLevel {
    WAL_LEVEL_MINIMAL = 0,
    WAL_LEVEL_REPLICA = 1,
    WAL_LEVEL_LOGICAL = 2,
}
extern "C" {
    #[link_name = "wal_level"]
    pub static mut wal_level: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CheckpointStatsData {
    pub ckpt_start_t: TimestampTz,
    pub ckpt_write_t: TimestampTz,
    pub ckpt_sync_t: TimestampTz,
    pub ckpt_sync_end_t: TimestampTz,
    pub ckpt_end_t: TimestampTz,
    pub ckpt_bufs_written: ::std::os::raw::c_int,
    pub ckpt_segs_added: ::std::os::raw::c_int,
    pub ckpt_segs_removed: ::std::os::raw::c_int,
    pub ckpt_segs_recycled: ::std::os::raw::c_int,
    pub ckpt_sync_rels: ::std::os::raw::c_int,
    pub ckpt_longest_sync: uint64,
    pub ckpt_agg_sync_time: uint64,
}
#[test]
fn bindgen_test_layout_CheckpointStatsData() {
    assert_eq!(::std::mem::size_of::<CheckpointStatsData>() , 80usize);
    assert_eq!(::std::mem::align_of::<CheckpointStatsData>() , 8usize);
}
impl Clone for CheckpointStatsData {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "CheckpointStats"]
    pub static mut CheckpointStats: CheckpointStatsData;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XLogRecData([u8; 0]);
extern "C" {
    pub fn XLogInsertRecord(rdata: *mut XLogRecData, fpw_lsn: XLogRecPtr)
     -> XLogRecPtr;
}
extern "C" {
    pub fn XLogFlush(RecPtr: XLogRecPtr);
}
extern "C" {
    pub fn XLogBackgroundFlush() -> bool_;
}
extern "C" {
    pub fn XLogNeedsFlush(RecPtr: XLogRecPtr) -> bool_;
}
extern "C" {
    pub fn XLogFileInit(segno: XLogSegNo, use_existent: *mut bool_,
                        use_lock: bool_) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn XLogFileOpen(segno: XLogSegNo) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CheckXLogRemoved(segno: XLogSegNo, tli: TimeLineID);
}
extern "C" {
    pub fn XLogGetLastRemovedSegno() -> XLogSegNo;
}
extern "C" {
    pub fn XLogSetAsyncXactLSN(record: XLogRecPtr);
}
extern "C" {
    pub fn XLogSetReplicationSlotMinimumLSN(lsn: XLogRecPtr);
}
extern "C" {
    pub fn xlog_redo(record: *mut XLogReaderState);
}
extern "C" {
    pub fn xlog_desc(buf: StringInfo, record: *mut XLogReaderState);
}
extern "C" {
    pub fn xlog_identify(info: uint8) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn issue_xlog_fsync(fd: ::std::os::raw::c_int, segno: XLogSegNo);
}
extern "C" {
    pub fn RecoveryInProgress() -> bool_;
}
extern "C" {
    pub fn HotStandbyActive() -> bool_;
}
extern "C" {
    pub fn HotStandbyActiveInReplay() -> bool_;
}
extern "C" {
    pub fn XLogInsertAllowed() -> bool_;
}
extern "C" {
    pub fn GetXLogReceiptTime(rtime: *mut TimestampTz,
                              fromStream: *mut bool_);
}
extern "C" {
    pub fn GetXLogReplayRecPtr(replayTLI: *mut TimeLineID) -> XLogRecPtr;
}
extern "C" {
    pub fn GetXLogInsertRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetXLogWriteRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn RecoveryIsPaused() -> bool_;
}
extern "C" {
    pub fn SetRecoveryPause(recoveryPause: bool_);
}
extern "C" {
    pub fn GetLatestXTime() -> TimestampTz;
}
extern "C" {
    pub fn GetCurrentChunkReplayStartTime() -> TimestampTz;
}
extern "C" {
    pub fn XLogFileNameP(tli: TimeLineID, segno: XLogSegNo)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn UpdateControlFile();
}
extern "C" {
    pub fn GetSystemIdentifier() -> uint64;
}
extern "C" {
    pub fn DataChecksumsEnabled() -> bool_;
}
extern "C" {
    pub fn GetFakeLSNForUnloggedRel() -> XLogRecPtr;
}
extern "C" {
    pub fn XLOGShmemSize() -> Size;
}
extern "C" {
    pub fn XLOGShmemInit();
}
extern "C" {
    pub fn BootStrapXLOG();
}
extern "C" {
    pub fn StartupXLOG();
}
extern "C" {
    pub fn ShutdownXLOG(code: ::std::os::raw::c_int, arg: Datum);
}
extern "C" {
    pub fn InitXLOGAccess();
}
extern "C" {
    pub fn CreateCheckPoint(flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn CreateRestartPoint(flags: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn XLogPutNextOid(nextOid: Oid);
}
extern "C" {
    pub fn XLogRestorePoint(rpName: *const ::std::os::raw::c_char)
     -> XLogRecPtr;
}
extern "C" {
    pub fn UpdateFullPageWrites();
}
extern "C" {
    pub fn GetFullPageWriteInfo(RedoRecPtr_p: *mut XLogRecPtr,
                                doPageWrites_p: *mut bool_);
}
extern "C" {
    pub fn GetRedoRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetInsertRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetFlushRecPtr() -> XLogRecPtr;
}
extern "C" {
    pub fn GetNextXidAndEpoch(xid: *mut TransactionId, epoch: *mut uint32);
}
extern "C" {
    pub fn RemovePromoteSignalFiles();
}
extern "C" {
    pub fn CheckPromoteSignal() -> bool_;
}
extern "C" {
    pub fn WakeupRecovery();
}
extern "C" {
    pub fn SetWalWriterSleeping(sleeping: bool_);
}
extern "C" {
    pub fn XLogRequestWalReceiverReply();
}
extern "C" {
    pub fn assign_max_wal_size(newval: ::std::os::raw::c_int,
                               extra: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn assign_checkpoint_completion_target(newval: f64,
                                               extra:
                                                   *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn do_pg_start_backup(backupidstr: *const ::std::os::raw::c_char,
                              fast: bool_, starttli_p: *mut TimeLineID,
                              labelfile: StringInfo, tblspcdir: *mut DIR,
                              tablespaces: *mut *mut List,
                              tblspcmapfile: StringInfo, infotbssize: bool_,
                              needtblspcmapfile: bool_) -> XLogRecPtr;
}
extern "C" {
    pub fn do_pg_stop_backup(labelfile: *mut ::std::os::raw::c_char,
                             waitforarchive: bool_,
                             stoptli_p: *mut TimeLineID) -> XLogRecPtr;
}
extern "C" {
    pub fn do_pg_abort_backup();
}
#[repr(C)]
pub struct FormData_pg_class {
    pub relname: NameData,
    pub relnamespace: Oid,
    pub reltype: Oid,
    pub reloftype: Oid,
    pub relowner: Oid,
    pub relam: Oid,
    pub relfilenode: Oid,
    pub reltablespace: Oid,
    pub relpages: int32,
    pub reltuples: float4,
    pub relallvisible: int32,
    pub reltoastrelid: Oid,
    pub relhasindex: bool_,
    pub relisshared: bool_,
    pub relpersistence: ::std::os::raw::c_char,
    pub relkind: ::std::os::raw::c_char,
    pub relnatts: int16,
    pub relchecks: int16,
    pub relhasoids: bool_,
    pub relhaspkey: bool_,
    pub relhasrules: bool_,
    pub relhastriggers: bool_,
    pub relhassubclass: bool_,
    pub relrowsecurity: bool_,
    pub relforcerowsecurity: bool_,
    pub relispopulated: bool_,
    pub relreplident: ::std::os::raw::c_char,
    pub relfrozenxid: TransactionId,
    pub relminmxid: TransactionId,
}
#[test]
fn bindgen_test_layout_FormData_pg_class() {
    assert_eq!(::std::mem::size_of::<FormData_pg_class>() , 136usize);
    assert_eq!(::std::mem::align_of::<FormData_pg_class>() , 4usize);
}
pub type Form_pg_class = *mut FormData_pg_class;
extern "C" {
    #[link_name = "no_such_variable"]
    pub static mut no_such_variable: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct FormData_pg_index {
    pub indexrelid: Oid,
    pub indrelid: Oid,
    pub indnatts: int16,
    pub indisunique: bool_,
    pub indisprimary: bool_,
    pub indisexclusion: bool_,
    pub indimmediate: bool_,
    pub indisclustered: bool_,
    pub indisvalid: bool_,
    pub indcheckxmin: bool_,
    pub indisready: bool_,
    pub indislive: bool_,
    pub indisreplident: bool_,
    pub indkey: int2vector,
}
#[test]
fn bindgen_test_layout_FormData_pg_index() {
    assert_eq!(::std::mem::size_of::<FormData_pg_index>() , 44usize);
    assert_eq!(::std::mem::align_of::<FormData_pg_index>() , 4usize);
}
impl Clone for FormData_pg_index {
    fn clone(&self) -> Self { *self }
}
pub type Form_pg_index = *mut FormData_pg_index;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RewriteRule {
    pub ruleId: Oid,
    pub event: CmdType,
    pub qual: *mut Node,
    pub actions: *mut List,
    pub enabled: ::std::os::raw::c_char,
    pub isInstead: bool_,
}
#[test]
fn bindgen_test_layout_RewriteRule() {
    assert_eq!(::std::mem::size_of::<RewriteRule>() , 32usize);
    assert_eq!(::std::mem::align_of::<RewriteRule>() , 8usize);
}
impl Clone for RewriteRule {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RuleLock {
    pub numLocks: ::std::os::raw::c_int,
    pub rules: *mut *mut RewriteRule,
}
#[test]
fn bindgen_test_layout_RuleLock() {
    assert_eq!(::std::mem::size_of::<RuleLock>() , 16usize);
    assert_eq!(::std::mem::align_of::<RuleLock>() , 8usize);
}
impl Clone for RuleLock {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockRelId {
    pub relId: Oid,
    pub dbId: Oid,
}
#[test]
fn bindgen_test_layout_LockRelId() {
    assert_eq!(::std::mem::size_of::<LockRelId>() , 8usize);
    assert_eq!(::std::mem::align_of::<LockRelId>() , 4usize);
}
impl Clone for LockRelId {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct LockInfoData {
    pub lockRelId: LockRelId,
}
#[test]
fn bindgen_test_layout_LockInfoData() {
    assert_eq!(::std::mem::size_of::<LockInfoData>() , 8usize);
    assert_eq!(::std::mem::align_of::<LockInfoData>() , 4usize);
}
impl Clone for LockInfoData {
    fn clone(&self) -> Self { *self }
}
pub type LockInfo = *mut LockInfoData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ForeignKeyCacheInfo {
    pub type_: NodeTag,
    pub conrelid: Oid,
    pub confrelid: Oid,
    pub nkeys: ::std::os::raw::c_int,
    pub conkey: [AttrNumber; 32usize],
    pub confkey: [AttrNumber; 32usize],
    pub conpfeqop: [Oid; 32usize],
}
#[test]
fn bindgen_test_layout_ForeignKeyCacheInfo() {
    assert_eq!(::std::mem::size_of::<ForeignKeyCacheInfo>() , 272usize);
    assert_eq!(::std::mem::align_of::<ForeignKeyCacheInfo>() , 4usize);
}
impl Clone for ForeignKeyCacheInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct AutoVacOpts {
    pub enabled: bool_,
    pub vacuum_threshold: ::std::os::raw::c_int,
    pub analyze_threshold: ::std::os::raw::c_int,
    pub vacuum_cost_delay: ::std::os::raw::c_int,
    pub vacuum_cost_limit: ::std::os::raw::c_int,
    pub freeze_min_age: ::std::os::raw::c_int,
    pub freeze_max_age: ::std::os::raw::c_int,
    pub freeze_table_age: ::std::os::raw::c_int,
    pub multixact_freeze_min_age: ::std::os::raw::c_int,
    pub multixact_freeze_max_age: ::std::os::raw::c_int,
    pub multixact_freeze_table_age: ::std::os::raw::c_int,
    pub log_min_duration: ::std::os::raw::c_int,
    pub vacuum_scale_factor: float8,
    pub analyze_scale_factor: float8,
}
#[test]
fn bindgen_test_layout_AutoVacOpts() {
    assert_eq!(::std::mem::size_of::<AutoVacOpts>() , 64usize);
    assert_eq!(::std::mem::align_of::<AutoVacOpts>() , 8usize);
}
impl Clone for AutoVacOpts {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct StdRdOptions {
    pub vl_len_: int32,
    pub fillfactor: ::std::os::raw::c_int,
    pub autovacuum: AutoVacOpts,
    pub user_catalog_table: bool_,
    pub parallel_workers: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_StdRdOptions() {
    assert_eq!(::std::mem::size_of::<StdRdOptions>() , 80usize);
    assert_eq!(::std::mem::align_of::<StdRdOptions>() , 8usize);
}
impl Clone for StdRdOptions {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ViewOptions {
    pub vl_len_: int32,
    pub security_barrier: bool_,
    pub check_option_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ViewOptions() {
    assert_eq!(::std::mem::size_of::<ViewOptions>() , 12usize);
    assert_eq!(::std::mem::align_of::<ViewOptions>() , 4usize);
}
impl Clone for ViewOptions {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn RelationIncrementReferenceCount(rel: Relation);
}
extern "C" {
    pub fn RelationDecrementReferenceCount(rel: Relation);
}
extern "C" {
    pub fn RelationHasUnloggedIndex(rel: Relation) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
